window['ymaps_loader_0e9r0l;r16))9t1_191!)*)!1,9u)(1;1j9x1Q1I5Y$H18555$0b0f9W2x9S9T9Y91922D9U2B9X0x0r2b9B9C9E9F9G9K2g9L2l9N2o),):);)@9O9P2r2O2R2X2023265*989699299$9_9.9*9:952-2!2)9;2:0m9j9q2q2z2J3a)i)j)q)z)Q)I3d3g3k3n3r9Q9z3t1y1D6e2(5z3w3A9J3D3N3P9Z3T,d,h,f3W,k30$b,l,a,c32,m38$f,n3$2i0d3i3.3(3:$g3q0D0S05$1$2$5$3$6$8$9$Z$-$_$!$*,D,E,F$,$:$)$@,G,H,K,L,M$q,N,O,P$i$z@2@3@4@5$Q$I-b-c-m-n-p-r-s-u-e-f-h,R-K-E-x,T,V-y-B-C4f$k$l$m$o$p4c$r$t$u$w$x$y$C$D$F$G3J4m4p4t4w4A,o,p,r$R$B4k0M4C,s,t,u,v,w,x4F4K4M0$0)-_494V4Y4245474-0@0z1a5d_75f5h:n:o_9_$___!_*_(5l5m_,_:5o1d5r5s5u5w5x5A5C1@8m1J8D2k8$1g_@_q0t5F5L_i_z_Q_I_Z.b.c5D.h5O5T5V515N.x.y:p!K.E.M52.W.51m_._)_J3*.e.$:r._...!.(.).:.;.q54.j.i.Q565759.J.Z!a0y!c0F5_5-5!5(!d!e!g:s5,5::t:u:v:w:x:y:A:B:C:D:E:F:G:H:K:L:M!h0U025@1o5i5j1r5Q1v5I1x:q!m:j:U:3:4:*:(:):,:::;:@:z:Q:J:I:Z!o;a;b;c;d;e;f:0:2:5!B!D!s;g;h;k;l!E6b!l6f!A!F!H.k!M;m;o;n;p6k!P;t;u;s;y!U!V!X!Y!0!2!3!6!4;A;B!9!$!_6m!R;v;w6o!S;x!86p6s!!!*6u6v6x6D;O*_*R*U.n*!***)086E*:*@6F6K.v$L3).D.H6g6)$M$O6:6@6j6z6I6Z7a7d7e7g7k7n2e$P']([
  ['0e', function(ym) {
    ym.modules.define("Balloon", ["util.defineClass", "Popup", "map.action.Single", "Monitor", "util.pixelBounds", "util.math.areEqual", "util.preset", "vow", "util.fireWithBeforeEvent", "balloon.component.getBalloonMode", "util.scheduler.strategy.Raf", "util.margin", "balloon.metaOptions"], function(e, t, n, s, i, o, a, r, h, l, p, u, c) {
      function g(e, t) {
        g.superclass.constructor.call(this, e, t), this.options.setName("balloon")
      }
      t(g, n, {
        open: function(e, t) {
          this.options.set("panelMode", this._isPanelNeeded());
          var n = this.isOpen(),
            s = g.superclass.open.call(this, e, t);
          return s.then(function(e) {
            var t = this.getOverlaySync().getLayout();
            return t.then(function() {
              return this._shape = this.getOverlaySync().getShape(), n || this._setupListeners(), this._isPanelNeeded() && this.options.get("autoPan") ? this._moveMapCenter() : this.options.get("autoPan") && this.autoPan(), e
            }, this)
          }, this)
        },
        close: function(e) {
          var t = g.superclass.close.call(this, e);
          return t.then(function() {
            this._clearListeners(), this._shape = null
          }, this), t
        },
        setPosition: function(e) {
          return this._positionAtZoom = this._map.getZoom(), g.superclass.setPosition.call(this, e)
        },
        autoPan: function() {
          if (this._isPanelNeeded()) return this.options.get("autoPan") ? this._moveMapCenter() : h.reject();
          var e = this.getOverlaySync(),
            t = this.getMap();
          if (!this.isOpen() || !t || !e) return h.reject();
          var n = this._shape;
          if (!n || "visible" == this.getOverlaySync().getPane().getOverflow()) return h.reject();
          if (!this.isOpen()) return h.reject();
          var i = h.defer(),
            a = t.action.getCurrentState(),
            r = Math.pow(2, a.zoom - t.getZoom()),
            l = (1 == r ? n : n.scale(r)).getBounds(),
            p = this._map.container.getSize(),
            u = this.options.get("autoPanMargin"),
            g = this.options.get("autoPanUseMapMargin", !0) ? c.sum([u, this._map.margin.getMargin()]) : u,
            v = p[0] / 2,
            _ = p[1] / 2,
            d = [
              [a.globalPixelCenter[0] - v, a.globalPixelCenter[1] - _],
              [a.globalPixelCenter[0] + v, a.globalPixelCenter[1] + _]
            ],
            f = o.fit(l, d, g);
          if (f) {
            t.action.stop();
            var M = t.getGlobalPixelCenter(),
              m = new s({
                globalPixelCenter: [M[0] - f[0], M[1] - f[1]],
                zoom: t.getZoom(),
                duration: this.options.get("autoPanDuration", 500),
                timingFunction: "ease-in-out",
                checkZoomRange: this.options.get("autoPanCheckZoomRange", !1)
              }, t);
            this.events.fire("autopanbegin"), t.events.once("actionend", function() {
              this.events.fire("autopanend"), i.resolve()
            }, this), t.action.execute(m)
          } else i.resolve();
          return i.promise()
        },
        _setupListeners: function() {
          this._mapListeners = this.getMap().events.group().add("boundschange", this._onMapBoundsChange, this).add("sizechange", this._applyPanelMode, this), this._overlayListeners = this.getOverlaySync().events.group().add("shapechange", this._onShapeChange, this).add("userclose", this._onUserClose, this), this._panelMaxMapAreaMonitor = new i(this.options).add("panelMaxMapArea", this._applyPanelMode, this)
        },
        _clearListeners: function() {
          this._panelMaxMapAreaMonitor && this._panelMaxMapAreaMonitor.destroy(), this._overlayListeners && this._overlayListeners.removeAll(), this._mapListeners && this._mapListeners.removeAll()
        },
        _onMapBoundsChange: function() {
          this.isOpen() && (this._preventAutoPanOnZoomChange = !0, this.setupGeometry(), this._preventAutoPanOnZoomChange = !1)
        },
        _applyPanelMode: function() {
          var e = this._isPanelNeeded();
          this.options.set("panelMode", e), e && this.options.get("autoPan") && (this.getOverlaySync().getLayoutSync() ? new u(this._moveMapCenter, this).start() : this.getOverlaySync().getLayout().then(this._moveMapCenter, this))
        },
        _onShapeChange: function() {
          if (this.isOpen() && !this._isPanelNeeded()) {
            var e = this.getOverlaySync().getShape();
            if (e && this._shape) {
              var t = e.getBounds(),
                n = this._shape.getBounds();
              if (a(n[0], t[0]) && a(n[1], t[1])) return
            }
            this._shape = e, this.options.get("autoPan") && !this._preventAutoPanOnZoomChange && this.autoPan()
          }
        },
        _moveMapCenter: function() {
          var e = this.getMap(),
            t = this.getOverlaySync();
          if (!this.isOpen() || !e || !t) return h.reject();
          var n = h.defer(),
            s = t.getGeometry().getCoordinates(),
            i = this.options.get("autoPanUseMapMargin", !0);
          if (a(s, e.getGlobalPixelCenter({
              useMapMargin: i
            }))) n.resolve();
          else {
            var o = e.action.getCurrentState().zoom,
              r = this._positionAtZoom;
            if (Math.abs(o - r) > 1e-7) {
              var l = Math.pow(2, o - r);
              s = [s[0] * l, s[1] * l]
            }
            n.resolve(e.setGlobalPixelCenter(s, o, {
              useMapMargin: i,
              duration: 300
            }))
          }
          return n.promise()
        },
        _onUserClose: function() {
          l(this.events, {
            type: "userclose",
            target: this
          }, {
            context: this,
            successCallback: this._onBeforeUserCloseSuccess
          })
        },
        _onBeforeUserCloseSuccess: function(e) {
          this.close(), this.events.fire(e.type, e)
        },
        _isPanelNeeded: function() {
          return "panel" == p(this.getMap(), this.options.get("panelMaxMapArea"))
        }
      }), e(g)
    });
  }],
  ['9r', function(ym) {
    ym.modules.define("balloon.component.getBalloonMode", [], function(e) {
      e(function(e, n) {
        var o = "default";
        if (n) {
          var t = e.container.getSize();
          o = n >= t[0] * t[1] ? "panel" : "default"
        }
        return o
      })
    });
  }],
  ['0l', function(ym) {
    ym.modules.define("balloon.metaOptions", ["map.metaOptions", "map.optionMapper", "constants.zIndex", "interactivityModel.opaque", "map.pane.helper.balloon", "map.pane.helper.shadows"], function(o, l, a, n, e) {
      l.set({
        balloonOverlay: "html#balloon",
        balloonPane: "balloon",
        balloonShadowsPane: "shadows",
        balloonLayout: "islands#balloon",
        balloonPanelLayout: "islands#balloonPanel",
        balloonContentLayout: "default#balloonContent",
        balloonAutoPan: !0,
        balloonAutoPanMargin: 34,
        balloonPanelMaxMapArea: 16e4,
        balloonPanelMaxHeightRatio: .5,
        balloonZIndex: n.balloon,
        balloonInteractivityModel: e,
        balloonCloseButton: !0,
        balloonMaxWidth: 400,
        balloonMaxHeight: 400,
        balloonMinWidth: 85,
        balloonMinHeight: 30
      }), a.setRule({
        name: "balloon",
        rule: "prefixed"
      }).setRule({
        name: "balloon",
        key: ["projection"],
        rule: "plain"
      }), o({})
    });
  }],
  [';r', function(ym) {
    ym.modules.define("BaseObjectManager", ["util.defineClass", "option.Manager", "data.Manager", "vow", "util.bind", "Event", "Monitor", "objectManager.optionMapper", "geoObject.optionMapper", "objectManager.component.ClusterListener", "objectManager.component.Filter", "util.array", "util.extend", "event.Mapper", "objectManager.CollectionMappingTable"], function(e, t, n, i, s, o, l, r, c, a, h, u, b, d, _, j) {
      function f(e, t) {
        return t + e.slice(0, 1).toUpperCase() + e.slice(1)
      }

      function g(e, t) {
        var n = e.replace(t, "");
        return n.slice(0, 1).toLowerCase() + n.slice(1)
      }

      function p(e, t) {
        var n = [];
        return b.each(e, function(e) {
          b.indexOf(t, e) == -1 && n.push(e)
        }), n
      }
      var O = {
          geoObjectBalloonManager: "objectManager#balloon",
          geoObjectHintManager: "objectManager#hint",
          clusterHintManager: "objectManager#hint",
          clusterBalloonManager: "objectManager#balloon"
        },
        v = function(e, t) {
          this._eventManager = t.events, this.geometry = null, this.options = new n(d({}, O, e), (void 0), "objectManager", c), this.options.events.add("change", this._onOptionsChange, this), this.properties = new i, this.state = new i, this._objectsCollection = t.objects, this._objectsCollection.options.setParent(this.options), this._clustersCollection = t.clusters, this._clustersCollection.options.setParent(this.options), this._clusterListener = new h(this);
          var s = new _(this._eventManager, new j(this));
          this._objectsCollection.events.setParent(s), this._clustersCollection.events.setParent(s), this._components = t
        };
      v.NoOverlayError = function() {
        return new Error("ObjectManager doesn't have an overlay.")
      }, t(v, {
        getOverlay: function() {
          return s.reject(new v.NoOverlayError)
        },
        getOverlaySync: function() {
          return null
        },
        onAddToMap: function(e) {
          this._startObjectCollectionListening(), this._showObjects(), this._clusterListener.setMap(e)
        },
        onRemoveFromMap: function(e) {
          this._clusterListener.setMap(null), this._hideObjects(), this._stopObjectCollectionListening()
        },
        setFilter: function(e) {
          if (e != this._filterFunction) {
            var t, n = this._filter,
              i = [],
              s = [];
            n && (i = n.getFilteredObjects(), n.destroy()), this._filterFunction = e, e ? (this._filter = new u(e), this._filter.add(this._objectsCollection.getAll()), t = this._filter.getFilteredObjects(), i.length && (s = p(i, t)), this.getMap() && (this._removeDisplayedObjects(t), s.length && this._addDisplayedObjects(s))) : i.length && (this._filter = null, this._addDisplayedObjects(i))
          }
          return this
        },
        getFilter: function() {
          return this._filterFunction
        },
        getObjectState: function(e) {
          var t = {
            found: !1
          };
          if (this.getMap()) {
            var n = this._objectsCollection.getById(e);
            n && (t = {
              found: !0,
              isFilteredOut: !!this._filter && this._filter.isFilteredOut(n)
            })
          }
          return t
        },
        _addDisplayedObjects: function(e) {
          this._components.addDisplayedObjects.callback.call(this._components.addDisplayedObjects.context, e)
        },
        _removeDisplayedObjects: function(e) {
          this._components.removeDisplayedObjects.callback.call(this._components.removeDisplayedObjects.context, e)
        },
        _startObjectCollectionListening: function() {
          this._objectCollectionListener = this._objectsCollection.events.group().add("objectsadd", this._onObjectsAdd, this).add("objectsremove", this._onObjectsRemove, this)
        },
        _stopObjectCollectionListening: function() {
          this._objectCollectionListener.removeAll()
        },
        _onObjectsAdd: function(e) {
          var t = e.get("objects"),
            n = [];
          if (this._filter && this._filter.add(t), this._filter)
            for (var i = 0, s = t.length; i < s; i++) this._filter.isFilteredOut(t[i]) || n.push(t[i]);
          else n = t;
          this._addDisplayedObjects(n)
        },
        _onObjectsRemove: function(e) {
          var t = e.get("objects"),
            n = [];
          if (this._filter)
            for (var i = 0, s = t.length; i < s; i++) this._filter.isFilteredOut(t[i]) || n.push(t[i]);
          else n = t;
          this._filter && this._filter.remove(t), this._removeDisplayedObjects(n)
        },
        _showObjects: function() {
          if (this._objectsCollection.getLength()) {
            var e;
            e = this._filter ? this._filter.getValidObjects() : this._objectsCollection.getAll(), this._addDisplayedObjects(e)
          }
        },
        _hideObjects: function() {
          if (this._objectsCollection.getLength()) {
            var e = this._components.removeAll;
            e.callback.call(e.context)
          }
        },
        _onOptionsChange: function() {
          this.events.fire("optionschange")
        }
      }), c.setRule({
        name: "objectCollection",
        rule: function(e, t) {
          return [f(e, "geoObject"), e]
        }
      }), c.setRule({
        name: "clusterCollection",
        rule: function(e, t) {
          return [f(e, "cluster"), e]
        }
      }), a.setRule({
        name: "objectManager",
        rule: function(e, t) {
          return 0 == e.indexOf("geoObject") ? g(e, "geoObject") : e
        }
      }), a.setRule({
        name: "objectManager",
        key: ["projection"],
        rule: "plain"
      }), e(v)
    });
  }],
  ['16', function(ym) {
    ym.modules.define("behavior.action", ["util.defineClass", "map.action.Continuous", "util.bind"], function(i, t, e, o) {
      function n() {
        n.superclass.constructor.call(this), this._timeoutID = 0, this._activeBehavior = null, this._activeBehaviorPriority = 0
      }
      t(n, e, {
        capture: function(i, t, e) {
          "undefined" == typeof e && (e = .5), this._activeBehaviorPriority <= e && (this._activeBehavior = t, this._activeBehaviorPriority = e, this._cancelStopping());
          var o = this.getActionManager();
          return o && o.getMap() != i && this.end(), this.isActive() || i.action.execute(this), this
        },
        tick: function(i, t) {
          return t = t || {}, t.behavior != this._activeBehavior ? this : (this._cancelStopping(), n.superclass.tick.call(this, i), "undefined" != typeof t.autoStopTimeout && this._planStopping((i.duration || 0) + t.autoStopTimeout), this)
        },
        release: function(i) {
          return i = i || {}, i.behavior && this._activeBehavior == i.behavior && (this._activeBehavior = null), this._activeBehaviorPriority = 0, this._cancelStopping(), this.isActive() && ("undefined" != typeof i.stopTimeout ? this._planStopping(i.stopTimeout) : this.end()), this
        },
        _planStopping: function(i) {
          this._timeoutID = window.setTimeout(o(function() {
            this._timeoutID = 0, this.end()
          }, this), i)
        },
        _cancelStopping: function() {
          window.clearTimeout(this._timeoutID), this._timeoutID = 0
        }
      }), i(new n)
    });
  }],
  ['))', function(ym) {
    ym.modules.define("behavior.BaseMultiEngine", ["util.defineClass", "constants.mapListenerPriority", "behavior.action", "Event", "DomEvent", "util.math.restrict", "util.coordinates.scaleInvert", "domEvent.manager", "yandex.counter"], function(t, e, i, o, n, s, a, h, r, u) {
      var m = 1 / Math.log(2),
        c = i.blocker,
        l = function(t) {
          this._behavior = t, this._map = null
        };
      e(l, {
        startListening: function() {
          this._map = this._behavior.getMap(), this._map.events.add("multitouchstartdefaultaction", this.onMultiTouchStart, this)
        },
        stopListening: function() {
          this._map.events.remove("multitouchstartdefaultaction", this.onMultiTouchStart, this), this._removeListeners(), this._map = null
        },
        onMultiTouchStart: function(t) {
          this._captureAction(), this._removeListeners(), this._domListeners = r.group(document.documentElement, !0).add("multitouchmove", this.onMultiTouchMove, this, c).add("multitouchend", this.onMultiTouchEnd, this, c), this._preventDomEvent(t.get("originalEvent").get("domEvent")), u.countByKey("control", "multiTouch.multiTouch")
        },
        onMultiTouchMove: function(t) {
          this._preventDomEvent(t)
        },
        onMultiTouchEnd: function(t) {
          if (o.release({
              behavior: this
            }), this._zoomChangeEventFired) {
            this._zoomChangeEventFired = !1;
            var e = this._map.action.getCurrentState();
            this._behavior.events.fire("multitouchzoomend", new n({
              zoomDelta: e.zoom - this._startZoomValue
            }))
          }
          this._removeListeners(), this._preventDomEvent(t)
        },
        processMove: function(t, e, i) {
          var o = this._isZoomChanged(e),
            n = this._isPositionChanged(i),
            s = this._map.action.getCurrentState(),
            a = s.zoom;
          if (o && !this._zoomChangeEventFired && (this._behavior.events.fire("multitouchzoomstart"), this._zoomChangeEventFired = !0, this._startZoomValue = a), n || o) {
            var r = this._getZoomDiff(e, a),
              u = this._map.converter.pageToGlobal(t),
              m = h.fixedToCenter(s.globalPixelCenter, u, Math.pow(2, r));
            this._makeTick([m[0] - i[0], m[1] - i[1]], a + r)
          }
        },
        _captureAction: function() {
          o.capture(this._map, this, 1)
        },
        _isPositionChanged: function(t) {
          var e = this._behavior.options.get("tremor", 2);
          return Math.abs(t[0]) > e || Math.abs(t[1]) > e
        },
        _isZoomChanged: function(t) {
          return Math.abs(1 - t) > this._behavior.options.get("scaleTremor", .1)
        },
        _getZoomDiff: function(t, e) {
          var i = this._map.zoomRange.getCurrent();
          return a(Math.log(t) * m, i[0] - e, i[1] - e)
        },
        _makeTick: function(t, e) {
          o.isActive() || this._captureAction(), o.tick({
            globalPixelCenter: t,
            zoom: e
          }, {
            behavior: this
          })
        },
        _removeListeners: function() {
          this._domListeners && this._domListeners.removeAll()
        },
        _preventDomEvent: function(t) {
          t.callMethod("preventDefault")
        }
      }), t(l)
    });
  }],
  ['9t', function(ym) {
    ym.modules.define("behavior.component.defaultMouseDownDispatcher", ["util.defineClass", "util.Associate"], function(e, n, t) {
      function i(e) {
        e.events.add("mousedowndefaultaction", this._handle, this), this._handlers = {}
      }
      n(i, {
        add: function(e, n, t) {
          if (ym.env.debug && this._handlers[e]) throw new Error("behavior.component.defaultMouseDownDispatcher.add: Обработчик нажатия данной кнопки по умолчанию уже был добавлен ранее.");
          return this._handlers[e] = [n, t], this
        },
        remove: function(e) {
          return delete this._handlers[e], this
        },
        _handle: function(e) {
          var n = this._handlers[e.get("originalEvent").get("domEvent").get("button")];
          n && (n[1] ? n[0].call(n[1], e) : n[0](e))
        }
      }), e(new t(function(e) {
        return new i(e)
      }))
    });
  }],
  ['1_', function(ym) {
    ym.modules.define("behavior.DblClickZoom", ["behavior.storage", "behavior.factory", "util.math.restrict", "util.coordinates.scaleInvert", "map.behavior.optionMapper", "yandex.counter"], function(t, e, i, n, o, a, l) {
      var s = i.create("dblClickZoom", {
        startListening: function() {
          this._listeners = this.getMap().events.group().add("dblclickdefaultaction", this._onDblClick, this).add("contextmenudefaultaction", this._onContextMenu, this)
        },
        stopListening: function() {
          this._listeners.removeAll(), this._lastRightClick = null
        },
        _onDblClick: function(t) {
          var e = t.get("originalEvent");
          this._action(e, 1), this._preventDomEvent(e)
        },
        _onContextMenu: function(t) {
          var e = +new Date,
            i = this.options.get("dblClickTimeout", 400),
            n = t.get("originalEvent");
          this._lastRightClick && e - this._lastRightClick < i ? (this._action(n, -1), this._lastRightClick = null) : this._lastRightClick = e, this._preventDomEvent(n)
        },
        _action: function(t, e) {
          var i = this.getMap();
          i.action.stop();
          var a, s = i.getZoom(),
            r = t.get("globalPixels"),
            c = this.options.get("duration", 200),
            h = i.zoomRange.getCurrent(),
            g = n(s + e, h[0], h[1]),
            u = Math.pow(2, g - s),
            d = this.options.get("centering", !0);
          a = d ? [r[0] * u, r[1] * u] : o.fixedToCenter(i.getGlobalPixelCenter(), r, Math.pow(2, g - s));
          var v = d && this.options.get("useMapMargin", !0);
          i.setGlobalPixelCenter(a, g, {
            duration: c,
            useMapMargin: v
          }), this.events.fire("zoomchange", {
            zoomDelta: e
          }), l.countByKey("control", "dblclick.action")
        },
        _preventDomEvent: function(t) {
          var e = t.get("domEvent");
          e && e.callMethod("preventDefault")
        }
      });
      a.setRule({
        name: "dblClickZoom",
        key: ["centering", "duration"],
        rule: "prefixed"
      }), e.add("dblClickZoom", s), t(s)
    });
  }],
  ['19', function(ym) {
    ym.modules.define("behavior.Drag", ["behavior.storage", "behavior.action", "util.Dragger", "util.math.cubicBezier", "util.scheduler.strategy.Processing", "util.hd", "behavior.factory", "map.behavior.optionMapper", "Monitor", "behavior.component.defaultMouseDownDispatcher"], function(t, i, e, r, n, a, o, s, h, u, g) {
      function c(t, i, e, r, n, a, o) {
        var s = p(i.slice(e)),
          h = t.get(e),
          u = n[1] ? n[1] - h.eventTimestamp : n[0] - h.timestamp,
          g = Math.min(s / u, 1) * (o || 1),
          c = g * a,
          d = l(t.get(r).position, t.get(-1).position),
          m = v(d);
        return {
          targetPath: [d[0] * c / m, d[1] * c / m]
        }
      }

      function d(t, i, e, r, n, a) {
        var o = -.00125,
          s = p(i.slice(e)),
          h = t.get(e),
          u = n[1] ? n[1] - h.eventTimestamp : n[0] - h.timestamp,
          g = Math.min(s / u, 2) * (a || 1),
          c = Math.round(Math.min(Math.max(100, -g / o), 900)),
          d = g * c + o * c * c / 2,
          m = l(t.get(r).position, t.get(-1).position),
          _ = v(m);
        return {
          targetPath: [m[0] * d / _, m[1] * d / _],
          duration: c
        }
      }

      function p(t) {
        for (var i = 0, e = 0; e < t.length; ++e) i += t[e];
        return i
      }

      function m(t, i) {
        for (var e = 0, r = t.length - 1; r >= 0; r--)
          if (e += t[r], e >= i) return r;
        return -1
      }

      function _(t) {
        for (var i = o.getPixelRatio(), e = [], r = 0, n = t.length; r < n - 1; r++) e.push(v(t[r].position, t[r + 1].position) / i);
        return e
      }

      function v(t, i) {
        "undefined" == typeof i && (i = t, t = [0, 0]);
        var e = l(t, i);
        return Math.sqrt(Math.pow(e[0], 2) + Math.pow(e[1], 2))
      }

      function l(t, i) {
        return [i[0] - t[0], i[1] - t[1]]
      }

      function b(t) {
        this._length = t || 1 / 0, this.data = []
      }
      var f = ym.env.browser,
        D = s.create("drag", {
          startListening: function() {
            var t = this.getMap();
            this._moves = new b(30), this._grabCursorKey = this.options.get("cursor"), this._grabbingCursorKey = this.options.get("actionCursor"), this._cursorMonitor = new u(this.options).add("cursor", this._onGrabCursorChange, this).add("actionCursor", this._onGrabbingCursorChange, this), this._grabCursor = t.cursors.push(this._grabCursorKey), this._mapEvents = t.events.group().add("multitouchstart", this._stopInertia, this).add("multitouchend", this._onMultiTouchEnd, this), this._dispatcher = g.get(t).add(0, this._onMouseDown, this)
          },
          stopListening: function() {
            this._dispatcher.remove(0), this._mapEvents.removeAll(), this._grabCursor.remove(), this._cursorMonitor.removeAll()
          },
          _onMouseDown: function(t) {
            var i = t.get("originalEvent").get("domEvent");
            0 == i.get("button") && this._createDragger(i)
          },
          _onMultiTouchEnd: function(t) {
            function i(t) {
              this._mapEvents.remove(["mousemove", "mouseup"], i, this), "mousemove" == t.get("type") && this._createDragger(t)
            }
            var e = t.get("touches");
            e && 1 == e.length && this._mapEvents.add(["mousemove", "mouseup"], i, this)
          },
          _createDragger: function(t) {
            this._draggerEvents && this._draggerEvents.removeAll(), this._dragger = new r({
              tremor: this.options.get("tremor", 2),
              disableBrowserBehavior: !0
            }), this._dragger.start(t), this._draggerEvents = this._dragger.events.group(), this._draggerEvents.add("start", this._onDragStart, this).add("move", this._onDragMove, this).add("cancel", this._onDragCancel, this).add("stop", this._onDragStop, this), this._moved = !1
          },
          _onDragMove: function(t) {
            e.capture(this.getMap()), this._grabbingCursor || (this._grabbingCursor = this.getMap().cursors.push(this._grabbingCursorKey)), this._moved || (this.events.fire("dragstart"), this._moved = !0), e.tick({
              pixelOffset: t.get("delta"),
              duration: 0
            }, {
              autoStopTimeout: this.options.get("autoStopTimeout", 500)
            }), this.options.get("inertia") && this._addMove(t)
          },
          _onDragCancel: function() {
            this._clearDraggerData()
          },
          _onDragStart: function(t) {
            this.options.get("inertia") && this._addMove(t), this._stopInertia()
          },
          _onDragStop: function(t) {
            var i = null;
            this.options.get("inertia") && (i = this._startKinetic(t)), this._clearDraggerData(), i || e.release()
          },
          _addMove: function(t) {
            var i = {
              timestamp: +new Date,
              eventTimestamp: t.get("domEvent").get("timeStamp"),
              position: t.get("position")
            };
            this._moves.add(i)
          },
          _clearDraggerData: function() {
            this._grabbingCursor && (this._grabbingCursor.remove(), this._grabbingCursor = null), this._moved && (this.events.fire("dragend"), this._moved = !1), this._draggerEvents.removeAll()
          },
          _startKinetic: function(t) {
            var i = -1;
            t && (this._addMove(t), i = -2);
            var r = this._moves;
            if (!r.data.length) return !1;
            var o = {
                inertiaDuration: this.options.get("inertiaDuration", 400),
                inertiaTimingFunction: this.options.get("inertiaTimingFunction", "cubic-bezier(0, 0.1, 0.4, 1)"),
                inertiaTimeout: this.options.get("inertiaTimeout", 75),
                inertiaMinDistance: this.options.get("inertiaMinDistance", 10),
                inertiaSpeedDistance: this.options.get("inertiaSpeedDistance", 40),
                inertiaSpeedFactor: this.options.get("inertiaSpeedFactor", 1)
              },
              s = _(r.data),
              h = m(s, o.inertiaMinDistance),
              u = m(s, o.inertiaSpeedDistance),
              g = (new Date).getTime(),
              p = t.get("domEvent").get("timeStamp"),
              v = r.get(i),
              l = v.timestamp,
              b = v.eventTimestamp,
              D = p && b ? p - b : g - l;
            if (D > o.inertiaTimeout) return r.clear(), !1;
            if (h < 0) return r.clear(), !1;
            u < 0 && (u = 0), "string" != typeof o.inertiaTimingFunction && (o.inertiaTimingFunction = "cubic-bezier(" + o.inertiaTimingFunction.toString() + ")");
            var C, M, S, T = this.getMap().action.getCurrentState().globalPixelCenter,
              y = this.getMap().action.getCurrentState().zoom;
            if ("auto" == o.inertiaDuration ? (C = d(r, s, u, h, [g, p], o.inertiaSpeedFactor), S = C.duration) : (C = c(r, s, u, h, [g, p], o.inertiaDuration, o.inertiaSpeedFactor), S = o.inertiaDuration), M = C.targetPath, r.clear(), this.options.get("stepwiseInertia", !0) === !1 || "WebKit" == f.engine && "iOS" == f.osFamily) {
              var w = [T[0] - M[0], T[1] - M[1]];
              e.tick({
                globalPixelCenter: w,
                zoom: y,
                duration: S,
                timingFunction: o.inertiaTimingFunction
              }, {
                autoStopTimeout: 0
              })
            } else {
              var P = +new Date;
              this._kineticProcess && (this._kineticProcess.stop(), this._kineticProcess = null), e.capture(this.getMap()), this._kineticProcess = new a(function() {
                var t = n(o.inertiaTimingFunction).getValue(Math.min((+new Date - P) / S, 1));
                1 != t && e.isActive() ? e.tick({
                  globalPixelCenter: [T[0] - M[0] * t, T[1] - M[1] * t],
                  zoom: y,
                  duration: 0
                }, {
                  autoStopTimeout: 100
                }) : this._stopInertia()
              }, this, {
                duration: S
              }), e.events.once("end", this._stopInertia, this), this._kineticProcess.start()
            }
            return !0
          },
          _stopInertia: function() {
            this._kineticProcess && (this._kineticProcess.stop(), this._kineticProcess = null), e.release()
          },
          _onGrabCursorChange: function(t) {
            this._grabCursorKey = t, this._grabCursor && this._grabCursor.setKey(t)
          },
          _onGrabbingCursorChange: function(t) {
            this._grabbingCursorKey = t, this._grabbingCursor && this._grabbingCursor.setKey(t)
          }
        });
      h.setRule({
        name: "drag",
        key: ["inertia", "inertiaDuration", "inertiaTimingFunction", "inertiaTimeout", "stepwiseInertia", "frameRateCompensation", "inertiaMinDistance", "inertiaSpeedDistance", "inertiaSpeedFactor", "autoStopTimeout", "cursor", "actionCursor"],
        rule: "prefixed"
      }), b.prototype = {
        add: function(t) {
          this.data.push(t), this.data.length > this._length && this.data.shift()
        },
        get: function(t) {
          return t >= 0 ? this.data[t] : this.data[this.data.length + t]
        },
        clear: function() {
          this.data = []
        }
      }, i.add("drag", D), t(D)
    });
  }],
  ['1!', function(ym) {
    ym.modules.define("behavior.factory", ["util.defineClass", "collection.Item", "option.Manager", "util.extend", "theme.islands.behavior.meta"], function(i, t, n, e, s) {
      i({
        create: function(i, a) {
          var o = function(i, t) {
            o.superclass.constructor.call(this, i), this._behaviorEnabled = t, "function" == typeof this.init && this.init()
          };
          return t(o, n, s({
            createOptionManager: function(t) {
              return new e(t, null, i)
            },
            onAddToMap: function() {
              this._behaviorEnabled && this.startListening()
            },
            onRemoveFromMap: function() {
              this._behaviorEnabled && this.stopListening()
            },
            enable: function() {
              this._behaviorEnabled || (this._behaviorEnabled = !0, this.getMap() && this.startListening(), this.events.fire("enable"))
            },
            disable: function() {
              this._behaviorEnabled && (this.getMap() && this.stopListening(), this._behaviorEnabled = !1, this.events.fire("disable"))
            },
            isEnabled: function() {
              return this._behaviorEnabled
            },
            startListening: function() {},
            stopListening: function() {}
          }, a)), o
        }
      })
    });
  }],
  [')*', function(ym) {
    ym.modules.define("behavior.LeftMouseButtonMagnifier", ["behavior.factory", "behavior.magnifier.mouse.Component", "behavior.storage", "map.behavior.optionMapper", "Monitor"], function(o, t, e, i, n, r) {
      var s = t.create("leftMouseButtonMagnifier", {
        startListening: function() {
          this._component = new e(this, 0), this._optionsMonitor = new r(this.options), this._optionsMonitor.add("cursor", this._onCursorChange, this), this._magnifierCursor = this.getMap().cursors.push(this._optionsMonitor.get("cursor"))
        },
        stopListening: function() {
          this._component.destroy(), this._optionsMonitor.destroy(), this._magnifierCursor.remove()
        },
        _onCursorChange: function(o) {
          this._magnifierCursor.setKey(o)
        }
      });
      n.setRule({
        name: "leftMouseButtonMagnifier",
        rule: "prefixed"
      }).setRule({
        name: "leftMouseButtonMagnifier",
        key: ["projection"],
        rule: "plain"
      }), i.add("leftMouseButtonMagnifier", s), o(s)
    });
  }],
  [')!', function(ym) {
    ym.modules.define("behavior.magnifier.mouse.Component", ["util.defineClass", "util.Dragger", "domEvent.manager", "constants.zIndex", "constants.paneZIndex", "Monitor", "geometry.pixel.Rectangle", "pane.EventsPane", "behavior.component.defaultMouseDownDispatcher", "overlay.storage", "util.cancelableCallback", "yandex.counter", "map.pane.helper.controls"], function(t, e, s, o, i, n, a, r, h, _, l, c, u) {
      function g(t, e) {
        this._owner = t, this._activeButton = e || 0, this._map = t.getMap(), 2 == this._activeButton ? _.get(this._map).add(2, function(t) {
          return this._onMouseDown(t.get("originalEvent"))
        }, this) : this._map.events.add("mousedown", this._onMouseDown, this), this._glassPane = null, this._cursor = null, this._monitor = null, this._startPosition = null, this._endPosition = null, this._dragger = null
      }
      e(g, {
        destroy: function() {
          this._dragger && this._clearDragger(), 2 == this._activeButton ? _.get(this._map).remove(2) : this._map.events.remove("mousedown", this._onMouseDown, this)
        },
        _onMouseDown: function(t) {
          var e = t.get("domEvent");
          e && e.get("button") == this._activeButton && (this._setupDragger(e), t.preventDefault())
        },
        _setupDragger: function(t) {
          this._dragger = new s({
            byRightButton: 2 == this._activeButton,
            disableBrowserBehavior: !0
          }), this._dragger.events.add("start", this._onDragStart, this).add("move", this._onDragMove, this).add("stop", this._onDragStop, this), this._dragger.start(t)
        },
        _clearDragger: function() {
          this._dragger.isDragging() && this._dragger.stop(), this._dragger.events.remove("start", this._onDragStart, this).remove("move", this._onDragMove, this).remove("stop", this._onDragStop, this)
        },
        _onDragStart: function(t) {
          this._map.action.stop(), this._canceled = !1, this._startPosition = this._endPosition = this._map.converter.pageToGlobal(t.get("position")), o.add(document, "keydown", this._onKeyDown, this), this._setupOverlay(), this._owner.events.fire("selectionstart", {
            activeButton: this._activeButton
          })
        },
        _onDragMove: function(t) {
          this._endPosition = this._map.converter.pageToGlobal(t.get("position")), this._overlay && this._overlay.setBounds([this._startPosition, this._endPosition])
        },
        _onDragStop: function() {
          this._clearOverlay(), o.remove(document, "keydown", this._onKeyDown, this), this._clearDragger();
          var t = this._owner.options.get("tremor", 2),
            e = Math.abs(this._endPosition[0] - this._startPosition[0]) <= t && Math.abs(this._endPosition[1] - this._startPosition[1]) <= t;
          this._canceled || e ? this._owner.events.fire("selectioncancel", {
            activeButton: this._activeButton
          }) : (u.countByKey("control", "magnifier.action"), this._apply(), this._owner.events.fire("selectionend", {
            activeButton: this._activeButton
          }))
        },
        _onKeyDown: function(t) {
          27 == t.get("keyCode") && (t.callMethod("preventDefault"), this._canceled = !0, this._clearDragger())
        },
        _apply: function() {
          var t = this._map,
            e = [(this._endPosition[0] + this._startPosition[0]) / 2, (this._endPosition[1] + this._startPosition[1]) / 2],
            s = this._computeZoom(),
            o = Math.pow(2, s - t.getZoom());
          t.action.stop(), t.setGlobalPixelCenter([e[0] * o, e[1] * o], s, {
            duration: this._owner.options.get("duration", 300),
            checkZoomRange: !0
          })
        },
        _computeZoom: function() {
          var t = this._map.container.getSize(),
            e = [Math.abs(this._endPosition[0] - this._startPosition[0]), Math.abs(this._endPosition[1] - this._startPosition[1])];
          if (0 == e[0] || 0 == e[1]) return this._map.getZoom();
          var s = t[0] / e[0],
            o = t[1] / e[1],
            i = Math.min(s, o),
            n = this._map.getZoom() + Math.log(i) / Math.log(2);
          return Math.max(n, this._map.getZoom())
        },
        _setupOverlay: function() {
          this._setupGlassPane();
          var t = l.get("html#rectangle");
          null == t ? (this._overlayCallback = c.create(this._createOverlayInstance, this), l.require(["html#rectangle"]).spread(this._overlayCallback)) : this._createOverlayInstance(t)
        },
        _createOverlayInstance: function(t) {
          this._overlayCallback = null, this._overlay = new t(this._createOverlayGeometry([this._startPosition, this._endPosition]), null, {
            zIndex: -1,
            pane: "controls",
            eventsPane: "events"
          }), this._overlay.options.setParent(this._owner.options), this._overlay.setMap(this._map)
        },
        _clearOverlay: function() {
          this._overlayCallback ? this._overlayCallback.cancel() : (this._overlay.setMap(null), this._overlay.options.setParent(null), this._overlay = null), this._clearGlassPane()
        },
        _setupGlassPane: function() {
          var t = this._map.panes.get("controls");
          this._glassPane = new h(this._map, {
            zIndex: (t ? t.getZIndex() : n.controls) + 1
          }), this._map.panes.append("magnifier", this._glassPane), this._monitor = new a(this._owner.options).add("actionCursor", this._onActionCursorChange, this, {
            defaultValue: "crosshair"
          }), this._setupCursor(this._monitor.get("actionCursor"))
        },
        _clearGlassPane: function() {
          this._clearCursor(), this._map.panes.remove(this._glassPane), this._glassPane.destroy()
        },
        _setupCursor: function(t) {
          this._cursor = this._glassPane.cursors.push(t)
        },
        _clearCursor: function() {
          this._cursor && this._cursor.remove()
        },
        _onActionCursorChange: function(t) {
          this._clearCursor(), this._setupCursor(t)
        },
        _createOverlayGeometry: function(t) {
          return new r([
            [Math.min(t[0][0], t[1][0]), Math.min(t[0][1], t[1][1])],
            [Math.max(t[0][0], t[1][0]), Math.max(t[0][1], t[1][1])]
          ])
        }
      }), t(g)
    });
  }],
  ['1,', function(ym) {
    ym.modules.define("behavior.MultiTouch", ["behavior.storage", "behavior.factory", "behavior.MultiTouchEngine", "map.behavior.optionMapper"], function(e, i, t, n, o) {
      var r = t.create("multiTouch", {
        startListening: function() {
          this._engine = new n(this), this._engine.startListening()
        },
        stopListening: function() {
          this._engine.stopListening(), this._engine = null
        }
      });
      o.setRule({
        name: "multiTouch",
        key: ["tremor", "autoStopTimeout", "zoomSensitivity", "scaleTremor", "actionsPerSecond"],
        rule: "prefixed"
      }), i.add("multiTouch", r), e(r)
    });
  }],
  ['9u', function(ym) {
    ym.modules.define("behavior.MultiTouchEngine", ["util.defineClass", "behavior.BaseMultiEngine", "util.throttle"], function(t, i, s, o) {
      var e = function(t) {
        e.superclass.constructor.call(this, t), this._behavior = t
      };
      i(e, s, {
        startListening: function() {
          e.superclass.startListening.call(this), this._onMoveThrottled = o(1e3 / this._behavior.options.get("actionsPerSecond", 20), this._onMove, this)
        },
        onMultiTouchStart: function(t) {
          var i = t.get("originalEvent").get("domEvent");
          i && (e.superclass.onMultiTouchStart.call(this, t), this._distance = this._getDistance(i), this._position = this._getPosition(i))
        },
        onMultiTouchMove: function(t) {
          e.superclass.onMultiTouchMove.call(this, t), this._onMoveThrottled(t)
        },
        onMultiTouchEnd: function(t) {
          e.superclass.onMultiTouchEnd.call(this, t)
        },
        _onMove: function(t) {
          var i = this._getDistance(t),
            s = this._getPosition(t),
            o = i / this._distance;
          this.processMove(s, o, [s[0] - this._position[0], s[1] - this._position[1]]), this._distance = i, this._position = s
        },
        _getDistance: function(t) {
          var i = t.get("touches"),
            s = i[0],
            o = i[1],
            e = s.pageX - o.pageX,
            n = s.pageY - o.pageY,
            a = Math.sqrt(e * e + n * n);
          return Math.max(a, 1)
        },
        _getPosition: function(t) {
          var i = t.get("touches"),
            s = i[0],
            o = i[1];
          return [.5 * (s.pageX + o.pageX), .5 * (s.pageY + o.pageY)]
        }
      }), t(e)
    });
  }],
  [')(', function(ym) {
    ym.modules.define("behavior.RightMouseButtonMagnifier", ["behavior.factory", "behavior.magnifier.mouse.Component", "behavior.storage", "map.behavior.optionMapper"], function(e, i, t, n, o) {
      var r = i.create("rightMouseButtonMagnifier", {
        startListening: function() {
          this._component = new t(this, 2)
        },
        stopListening: function() {
          this._component.destroy()
        }
      });
      o.setRule({
        name: "rightMouseButtonMagnifier",
        rule: "prefixed"
      }).setRule({
        name: "rightMouseButtonMagnifier",
        key: ["projection"],
        rule: "plain"
      }), n.add("rightMouseButtonMagnifier", r), e(r)
    });
  }],
  ['1;', function(ym) {
    ym.modules.define("behavior.RouteEditor", ["behavior.storage", "behavior.factory", "util.array", "route", "map.associate.serviceGeoObjects", "util.cancelableCallback", "yandex.counter"], function(t, e, o, i, s, n, r, a) {
      var u = o.create("routeEditor", {
        startListening: function() {
          !this._route || this._route.getWayPoints().getLength() > 1 ? this._createLoadModulesRequest() : (this._startEditor(), this._bindEvents())
        },
        stopListening: function() {
          this._clearLoadModulesRequest(), this._route && this._route.editor && this._route.editor.options.set("addWayPoints", !1), this._unbindEvents()
        },
        getRoute: function() {
          return this._route
        },
        getState: function() {
          for (var t = [], e = [], o = "", i = this._route.requestPoints, s = 0, n = i.length; s < n; s++) {
            var r = i[s];
            t.push((r.point || r).join(",")), "viaPoint" == r.type && e.push(s)
          }
          return t.length && (o += "rt=" + t.join("~")), e.length && (o += "&via=" + e.join(",")), o
        },
        setState: function(t) {
          this._clearLoadModulesRequest();
          var e = this._route;
          if (this._removeRoute(), !t) return void this._fireRouteChange(e, this._route);
          var o, n = t.split("&"),
            a = n[0] && n[0].substr(3).split("~"),
            u = [];
          if (a && a.length) {
            o = i.map(n[1] && n[1].substr(4).split(",") || [], parseInt);
            for (var d = 0, h = a.length; d < h; d++) u.push({
              type: i.indexOf(o, d) != -1 ? "viaPoint" : "wayPoint",
              point: i.map(a[d].split(","), parseFloat)
            });
            this._loadModuleCallback = r.create(function(t) {
              this._route = t, this._addRouteToMap(), this._startEditor(), this._onRouteUpdate(), this._fireRouteChange(e, this._route)
            }, this), s(u).then(this._loadModuleCallback)
          }
        },
        _startEditor: function() {
          this._route.editor.start({
            addViaPoints: !0,
            addWayPoints: this._route.getWayPoints().getLength() < 2,
            removeViaPoints: !0,
            editWayPoints: !0,
            editViaPoints: !0
          }), a.countByKey("control", "routeEditor.start")
        },
        _addRouteToMap: function() {
          n.get(this.getMap()).add(this._route)
        },
        _removeRouteFromMap: function() {
          n.get(this.getMap()).remove(this._route)
        },
        _removeRoute: function() {
          this._route && (this._unbindEvents(), this._removeRouteFromMap(), this._route = null)
        },
        _bindEvents: function() {
          this._editorEvents = this._route.editor.events.group(), this._editorEvents.add("routeupdate", this._onRouteUpdate, this)
        },
        _unbindEvents: function() {
          this._editorEvents && (this._editorEvents.removeAll(), this._editorEvents = null)
        },
        _onRouteUpdate: function() {
          a.countByKey("control", "routeEditor.routeAdded"), this._route.getWayPoints().getLength() >= 2 && this.disable()
        },
        _fireRouteChange: function(t, e) {
          t !== e && this.events.fire("routechange")
        },
        _createLoadModulesRequest: function() {
          this._loadModuleCallback = r.create(function(t) {
            this._loadModuleCallback = null, this.setState(null), this._route = new t({
              features: [],
              properties: {}
            }), this._addRouteToMap(), this._startEditor(), this._bindEvents()
          }, this), ym.modules.require(["router.Route", "router.addon.editor"], this._loadModuleCallback)
        },
        _clearLoadModulesRequest: function() {
          this._loadModuleCallback && (this._loadModuleCallback.cancel(), this._loadModuleCallback = null)
        }
      });
      e.add("routeEditor", u), t(u)
    });
  }],
  ['1j', function(ym) {
    ym.modules.define("behavior.Ruler", ["behavior.factory", "behavior.storage", "map.behavior.optionMapper", "pane.EventsPane", "hotspot.Manager", "constants.paneZIndex", "geometry.LineString", "localization.common.current", "util.cancelableCallback", "domEvent.manager", "constants.mapListenerPriority", "yandex.counter", "yandex.state.component.RulerBehavior", "behavior.ruler.preset"], function(e, t, n, s, i, r, o, a, l, h, u, c, v, p) {
      function m() {
        if ("iOS" == ym.env.browser.osFamily) {
          var e = u.group(document.documentElement, !0);
          e.add("touchstart", function(t) {
            t.callMethod("preventDefault"), t.callMethod("stopPropagation"), e.removeAll()
          })
        }
        return window.confirm(l.Control.Ruler.sure.split("\\n").join("\n"))
      }
      var _ = "latlong" == ym.env.coordinatesOrder,
        d = function(e) {
          return _ ? [e[1], e[0]] : e
        },
        g = t.create("ruler", {
          init: function(e, t) {
            g.superclass.constructor.call(this, e, t), this.geometry = new a(null, {
              preset: "ruler#line"
            }), this._yandexStateRulerComponent = new p(this)
          },
          onAddToMap: function(e) {
            g.superclass.onAddToMap.call(this, e), this.geometry.options.setParent(e.options), this.geometry.setMap(e)
          },
          onRemoveFromMap: function() {
            this._clearView(), g.superclass.onRemoveFromMap.call(this)
          },
          startListening: function() {
            this._setupEventsPane()
          },
          stopListening: function() {
            this._clearEventsPane()
          },
          getState: function() {
            for (var e = [], t = [0, 0], n = 0, s = this.geometry.getLength(); n < s; n++) {
              var i = d(this.geometry.get(n));
              e.push((i[0] - t[0]).toFixed(8) + "," + (i[1] - t[1]).toFixed(8)), t = i
            }
            return e.join("~")
          },
          setState: function(e) {
            if (e) {
              var t = e.split(/~|,/),
                n = t.length;
              if (n > 1) {
                for (var s = [0, 0], i = [], r = 0; r < n; r += 2) s[0] += parseFloat(t[r]), s[1] += parseFloat(t[r + 1]), i.push(d(s.slice()));
                this._setupView(), this.geometry.setCoordinates(i)
              }
            } else this.geometry.setCoordinates([])
          },
          close: function() {
            return !!(this.geometry.getLength() < 3 || m()) && (this.geometry.setCoordinates([]), !0)
          },
          _setupEventsPane: function() {
            var e = this.getMap();
            this._eventsPane = new i(e, {
              zIndex: o.behaviors
            }), e.panes.append("rulerEvents", this._eventsPane), this._hotspotManager = new r(this._eventsPane), this._view && this._view.setEventsPane("rulerEvents"), e.events.add("click", this._onMapClick, this, c.behaviors), this._cursorHandler = this._eventsPane.cursors.push("arrow")
          },
          _clearEventsPane: function() {
            var e = this.getMap();
            this._cursorHandler.remove(), e.events.remove("click", this._onMapClick, this, c.behaviors), this._view && this._view.setEventsPane("events"), this._hotspotManager.destroy(), this._hotspotManager = null, e.panes.remove(this._eventsPane), this._eventsPane = null
          },
          _onMapClick: function(e) {
            e.stopImmediatePropagation(), e.preventDefault(), this._setupView(), this.geometry.insert(this.geometry.getLength(), e.get("coords")), v.countByKey("control", "ruler.click")
          },
          _setupView: function() {
            this._viewCallback || this._view || !this.getMap() || (this._viewCallback = h.create(function(e) {
              this.geometry.setMap(null), this._viewCallback = null, this._view = new e(this), this._view.setEventsPane(this.isEnabled() ? "rulerEvents" : "events")
            }, this), ym.modules.require(["behavior.ruler.View"], this._viewCallback))
          },
          _clearView: function() {
            this._viewCallback && (this._viewCallback.cancel(), this._viewCallback = null), this._view ? (this._view.destroy(), this._view = null) : this.geometry.setMap(null)
          }
        });
      n.add("ruler", g), s.setRule({
        name: "ruler",
        rule: "prefixed"
      }).setRule({
        name: "ruler",
        key: ["projection"],
        rule: "plain"
      }), e(g)
    });
  }],
  ['9x', function(ym) {
    ym.modules.define("behavior.ruler.preset", ["option.presetStorage"], function(e, i) {
      i.add("ruler#line", {
        coordRendering: "shortestPath",
        simplification: !1,
        geodesic: !0,
        pixelRendering: "static"
      }), e({})
    });
  }],
  ['1Q', function(ym) {
    ym.modules.define("behavior.ScrollZoom", ["util.coordinates.scaleInvert", "behavior.action", "behavior.storage", "behavior.factory", "map.behavior.optionMapper", "util.math.getSign", "domEvent.manager", "util.bind", "yandex.counter"], function(t, e, i, o, n, s, a, r, h, l) {
      var u = 100,
        m = n.create("scrollZoom", {
          startListening: function() {
            this._targetZoom = null, this._startZoom = null, this._setupDocumentListener(), this._started = !1, this._mapListeners = this.getMap().events.group().add("wheeldefaultaction", this._onWheel, this).add("click", this._onClick, this), this._zoomDelta = [0, 0]
          },
          stopListening: function() {
            this._started && (this._unscheduleStop(), this._started = !1, this._lastDocumentWheel = null, this._zoomDelta = [0, 0]), this._teardownDocumentListener(), this._mapListeners.removeAll()
          },
          _setupDocumentListener: function() {
            this._domListeners = r.group(document).add("wheel", this._onDocumentWheel, this)
          },
          _teardownDocumentListener: function() {
            this._domListeners.removeAll()
          },
          _onDocumentWheel: function(t) {
            var e = t.get("deltaX"),
              i = t.get("deltaY");
            this._started || !e && !i || (this._lastDocumentWheel = +new Date)
          },
          _onClick: function() {
            this._lastDocumentWheel = null, this._zoomDelta = [0, 0], this._started = !1
          },
          _onWheel: function(t) {
            var e = +new Date;
            if (!(this._lastDocumentWheel && e - this._lastDocumentWheel < 300)) {
              var i, o = t.get("originalEvent"),
                n = o.get("domEvent");
              if (this._started || (i = !0), n) {
                n.callMethod("preventDefault"), this._zoomDelta[0] += n.get("deltaX"), this._zoomDelta[1] += n.get("deltaY"), i && l.countByKey("control", "scrollZoom.wheel");
                var s = this._zoomDelta[0],
                  r = this._zoomDelta[1];
                if (this._zoomDelta = [0, 0], this._started || r && Math.abs(r) > Math.abs(s)) {
                  if (this._started = !0, this._scheduleStop(), this._checkWheelTrend(r) || this._checkTimeInterval()) {
                    var h = this._getTargetZoom(),
                      u = this._filterByMaximumDelta(this._filterByZoomRange(h + a(r, !0)));
                    h != u ? (this._tick(u, o.get("position")), this.events.fire("zoomchange", {
                      zoomDelta: u - h
                    })) : this._teardownState()
                  }
                  n.callMethod("preventDefault")
                }
              }
            }
          },
          _checkWheelTrend: function(t) {
            var e = this._currentWheelTrend,
              i = a(t, !0);
            return Math.abs(i) > 1e-10 && (this._currentWheelTrend = i, i != e)
          },
          _checkTimeInterval: function() {
            return !this._lastTickTime || new Date - this._lastTickTime > 1e3 / this.options.get("speed", 5)
          },
          _scheduleStop: function() {
            this._started && this._unscheduleStop(), this._stopTimeout = window.setTimeout(h(this._onSeriesStop, this), u)
          },
          _unscheduleStop: function() {
            window.clearTimeout(this._stopTimeout)
          },
          _onSeriesStop: function() {
            this._started = !1, this._zoomDelta = [0, 0], this._lastDocumentWheel = null
          },
          _getTargetZoom: function() {
            return null === this._targetZoom ? this.getMap().action.getCurrentState().zoom : this._targetZoom
          },
          _filterByZoomRange: function(t) {
            var e = this.getMap().zoomRange.getCurrent();
            return Math.min(Math.max(e[0], t), e[1])
          },
          _filterByMaximumDelta: function(t) {
            var e = this.options.get("maximumDelta", 5);
            if ("undefined" != typeof e) {
              var i = t - this._getStartZoom();
              Math.abs(i) > e && (t -= i - a(i) * e)
            }
            return t
          },
          _getStartZoom: function() {
            return null === this._startZoom ? this._startZoom = this.getMap().action.getCurrentState().zoom : this._startZoom
          },
          _tick: function(t, o) {
            this._lastTickTime = new Date, this._targetZoom = t;
            var n = this.getMap();
            this._actionListeners || (i.capture(n), this._actionListeners = i.events.group().add("end", this._teardownState, this));
            var s = n.action.getCurrentState(),
              a = s.zoom,
              r = t - a,
              h = s.globalPixelCenter,
              l = n.container.getSize(),
              u = n.container.getOffset(),
              m = Math.round(1e3 * Math.abs(r) / this.options.get("speed", 5));
            i.tick({
              globalPixelCenter: e.fixedToCenter(h, [h[0] + o[0] - u[0] - l[0] / 2, h[1] + o[1] - u[1] - l[1] / 2], Math.pow(2, r)),
              zoom: t,
              duration: m,
              timingFunction: r > 0 ? "ease-in" : "ease-out"
            }, {
              autoStopTimeout: Math.max(m, 100)
            })
          },
          _teardownState: function() {
            i.release(), this._actionListeners && (this._actionListeners.removeAll(), this._actionListeners = null), this._targetZoom = null, this._startZoom = null, this._lastTickTime = null, this._currentWheelTrend = null
          }
        });
      s.setRule({
        name: "scrollZoom",
        key: ["maximumDelta", "speed"],
        rule: "prefixed"
      }), o.add("scrollZoom", m), t(m)
    });
  }],
  ['1I', function(ym) {
    ym.modules.define("behavior.storage", ["util.Storage"], function(e, o) {
      e(new o)
    });
  }],
  ['5Y', function(ym) {
    ym.modules.define("canvasLayout.storage", ["util.AsyncStorage"], function(a, n) {
      a(new n("canvasLayout"))
    });
  }],
  ['$H', function(ym) {
    ym.modules.define("Circle", ["util.augment", "GeoObject"], function(e, t, n) {
      function r(e) {
        return e && "undefined" == typeof e.length ? e : {
          type: "Circle",
          coordinates: e[0],
          radius: e[1]
        }
      }
      var i = function(e, t, n) {
        i.superclass.constructor.call(this, {
          geometry: r(e),
          properties: t
        }, n)
      };
      t(i, n), e(i)
    });
  }],
  ['18', function(ym) {
    ym.modules.define('circleDotIconWithCaption.layout.html', ["islets-icon-caption", "islets-circle-dot-icon-with-caption"], function(provide) {
      provide([0, "<ymaps class=\"ymaps-2-1-42-islets_circle-dot-icon-with-caption\"><ymaps class=\"ymaps-2-1-42-islets_circle-dot-icon-with-caption__caption-block\"><ymaps class=\"ymaps-2-1-42-islets_icon-caption\">", 2001, ["properties.iconCaption", []], 0, "</ymaps></ymaps>", 2002, ["islands#circleDotIcon", [
        ["name", "\"baseIcon\""]
      ]], 0, "</ymaps>"]);
    });
  }],
  ['55', function(ym) {
    ym.modules.define('cluster-default', ['system.provideCss'], function(provide, provideCss) {
      provideCss(".ymaps-2-1-42-default-cluster{position:absolute;text-align:center;font-family:Arial,Helvetica,sans-serif;font-size:13px}", provide);
    });
  }],
  ['5$', function(ym) {
    ym.modules.define('cluster-night-content', ['system.provideCss'], function(provide, provideCss) {
      provideCss(".ymaps-2-1-42-cluster-night-content{color:#fff}", provide);
    });
  }],
  ['0b', function(ym) {
    ym.modules.define("cluster.default.css", ["cluster-default"], function(e) {
      e({})
    });
  }],
  ['0f', function(ym) {
    ym.modules.define("cluster.nightContent.css", ["cluster-night-content"], function(n) {
      n({})
    });
  }],
  ['9W', function(ym) {
    ym.modules.define("cluster.optionMapper", ["option.Mapper"], function(e, n) {
      e(new n)
    });
  }],
  ['2x', function(ym) {
    ym.modules.define("Clusterer", ["util.defineClass", "geoObject.optionMapper", "clusterer.component.GridClusterer", "util.array", "util.id", "util.bounds", "util.bind", "component.child.MapChild", "Monitor", "ClusterPlacemark", "data.Manager", "option.Manager", "event.Manager", "component.collection.ParentCollection", "event.Mapper", "geoObject.EventMappingTable", "clusterer.optionMapper", "event.globalize", "yandex.counter", "error", "theme.islands.cluster.metaOptions"], function(e, t, n, s, o, r, i, a, c, h, l, u, g, d, p, _, b, m, f, j, v) {
      function C(e, t) {
        return t + e.slice(0, 1).toUpperCase() + e.slice(1)
      }

      function O(e, t) {
        var n = e.replace(t, "");
        return n.slice(0, 1).toLowerCase() + n.slice(1)
      }
      var M = function(e) {
          this.options = new g(e, null, "clusterer", m), this.options.events.add("change", this._onOptionsChange, this), this.events = new d({
            context: this
          }), this._clustererComponent = new s(this.options), this._mapChildComponent = new c({
            onMapChange: {
              callback: this._onMapChange,
              context: this
            },
            onParentChange: {
              callback: this._onParentChange,
              context: this
            }
          }), this._collectionComponent = new p(this, null, new _(this.events, new b(this))), this._objects = {}, this._clusters = {}, this._mapListener = null, this._objectsCounter = 0, this._geoBounds = null, this.events.addController(y), this.events.fire("create")
        },
        y = f(M);
      t(M, {
        add: function(e) {
          var t;
          t = o.isArray(e) ? e : [e], t = this._getNotAddedObjects(t), this._addGeoObjects(t);
          var n = this._getHashesByObjects(t);
          if (ym.env.debug)
            for (var s = 0, r = n.length; s < r; s++) v.warnIf("string" == typeof n[s].geometry.coordinates[0] || "string" == typeof n[s].geometry.coordinates[1], "Warning", "Clusterer: coordinates of added object are strings and must be numbers (" + n[s].geometry.coordinates + ").");
          return this._clustererComponent.add(n), this.events.fire("pixelboundschange"), this
        },
        remove: function(e) {
          var t;
          t = o.isArray(e) ? e : [e], t = this._getAddedObjects(t);
          var n = this._getHashesByObjects(t);
          return this._clustererComponent.remove(n), this._removeGeoObjects(t), this.events.fire("pixelboundschange"), this
        },
        removeAll: function() {
          return this._clustererComponent.removeAll(), this._objects = {}, this._geoBounds = null, this.events.fire("pixelboundschange"), this
        },
        createCluster: function(e, t) {
          var n = "";
          return n = this.options.get("showInAlphabeticalOrder") ? "alphabetical" : "serial", t.sort(a(P[n], this)), new l(e, new u({
            geoObjects: t,
            iconContent: t.length.toString()
          }))
        },
        getObjectState: function(e) {
          var t = this._clustererComponent.getObjectState(r.get(e));
          return {
            isShown: !!t && !!t.isShown,
            isClustered: !!t && !!t.isClustered,
            cluster: t && t.isClustered ? this._clusters[t.cluster.id].clusterObject : null
          }
        },
        getBounds: function() {
          if (!this._geoBounds) {
            var e = [];
            for (var t in this._objects) this._objects.hasOwnProperty(t) && e.push(this._objects[t].geoObject.geometry.getCoordinates());
            this._geoBounds = 0 == e.length ? null : i.fromPoints(e, this.options.get("projection"))
          }
          return this._geoBounds
        },
        getPixelBounds: function() {
          var e = this.getBounds();
          return e && this.getMap() ? i.toGlobalPixelBounds(e, this.getMap().getZoom(), this.options.get("projection")) : null
        },
        getGeoObjects: function() {
          var e = [];
          for (var t in this._objects) e.push(this._objects[t].geoObject);
          return e
        },
        getClusters: function() {
          var e = [];
          for (var t in this._clusters) e.push(this._clusters[t].clusterObject);
          return e
        },
        getMap: function() {
          return this._mapChildComponent.getMap()
        },
        setParent: function(e) {
          return this._mapChildComponent.setParent(e), this
        },
        getParent: function() {
          return this._mapChildComponent.getParent()
        },
        _onMapChange: function(e, t) {
          e && this._removeFromMap(e), t && this._addToMap(t), this.events.fire("mapchange", {
            oldMap: e,
            newMap: t
          })
        },
        _addToMap: function(e) {
          this._mapListener = e.events.group().add("boundschange", this._onMapBoundsChange, this), this._clustererComponent.events.add("statechange", this._onStateChange, this), this._clustererComponent.setMap(e), j.countByKey("modulesUsage", "clusterer.create")
        },
        _removeFromMap: function(e) {
          this._clustererComponent.setMap(null), this._clustererComponent.events.remove("statechange", this._onStateChange, this), this._mapListener.removeAll()
        },
        _onStateChange: function(e) {
          var t = e.get("added"),
            n = e.get("removed"),
            s = e.get("addedClusters"),
            o = e.get("removedClusters");
          this._removeObjectsFromMap(n), this._removeClustersFromMap(o), this._addObjectsToMap(t), this._addClustersToMap(s)
        },
        _addClustersToMap: function(e) {
          for (var t = 0, n = e.length; t < n; t++) this._clusters[e[t].id] = this._createClusterObject(e[t]), this._addObjectToMap(this._clusters[e[t].id].clusterObject)
        },
        _removeClustersFromMap: function(e) {
          for (var t = 0, n = e.length; t < n; t++) {
            var s = this._getClusterByHash(e[t]);
            this._removeObjectFromMap(s), this._clearClusterData(e[t])
          }
        },
        _addObjectsToMap: function(e) {
          for (var t = 0, n = e.length; t < n; t++) {
            var s = this._getObjectByHash(e[t]);
            e[t].singleShown = !0, s.getMap() || this._addObjectToMap(s)
          }
        },
        _removeObjectsFromMap: function(e) {
          for (var t = 0, n = e.length; t < n; t++) {
            var s = this._getObjectByHash(e[t]);
            e[t].singleShown = !1, s.getMap() && this._removeObjectFromMap(s)
          }
        },
        _createClusterObject: function(e) {
          for (var t, n, s = [], o = e.properties.geoObjects, r = 0, i = o.length; r < i; r++) n = this._objects[o[r].id].geoObject, n.options.setParent(this.options), s.push(n);
          t = this.createCluster(e.geometry.coordinates, s);
          for (var r = 0, i = o.length; r < i; r++) this._objects[o[r].id].cluster = t;
          return {
            hash: e,
            clusterObject: t
          }
        },
        _getClusterByHash: function(e) {
          return this._clusters[e.id] ? this._clusters[e.id].clusterObject : null
        },
        _addObjectToMap: function(e) {
          this._collectionComponent.add(e)
        },
        _removeObjectFromMap: function(e) {
          this._collectionComponent.remove(e)
        },
        _getObjectByHash: function(e) {
          return this._objects[e.id].geoObject
        },
        _getAddedObjects: function(e) {
          for (var t = [], n = 0, s = e.length; n < s; n++) this._objects[r.get(e[n])] && t.push(e[n]);
          return t
        },
        _getNotAddedObjects: function(e) {
          for (var t = [], n = 0, s = e.length; n < s; n++) this._objects[r.get(e[n])] || t.push(e[n]);
          return t
        },
        _getHashesByObjects: function(e) {
          for (var t = [], n = 0, s = e.length; n < s; n++) {
            var o = r.get(e[n]);
            this._objects[o] || (this._objects[o] = {
              geoObject: e[n],
              hash: this._createHashFromGeoObject(e[n]),
              order: this._objectsCounter++
            }), t.push(this._objects[o].hash)
          }
          return t
        },
        _addGeoObjects: function(e) {
          if (e.length) {
            for (var t = 0, n = e.length; t < n; t++) e[t].setParent(null);
            this._geoBounds = null
          }
        },
        _removeGeoObjects: function(e) {
          if (e.length) {
            this._geoBounds = null;
            for (var t = 0, n = e.length; t < n; t++) delete this._objects[r.get(e[t])]
          }
        },
        _createHashFromGeoObject: function(e) {
          return {
            id: r.get(e),
            geometry: {
              type: "Point",
              coordinates: e.geometry.getCoordinates()
            }
          }
        },
        _clearClusterData: function(e) {
          for (var t = e.properties.geoObjects, n = 0, s = t.length; n < s; n++) delete this._objects[t[n].id].cluster, this._objects[t[n].id].geoObject.options.setParent(null);
          delete this._clusters[e.id]
        },
        _onParentChange: function(e, t) {
          this.getParent() ? this.options.setParent(this.getParent().options) : this.options.setParent(null), this.events.fire("parentchange", {
            oldParent: e,
            newParent: t
          })
        },
        _onOptionsChange: function() {
          this.events.fire("optionschange")
        },
        _onMapBoundsChange: function(e) {
          e.get("newZoom") != e.get("oldZoom") && this.events.fire("pixelboundschnage")
        }
      }), n.setRule({
        name: "clusterer",
        rule: function(e, t) {
          return 0 == e.indexOf("cluster") ? e : 0 == e.indexOf("geoObject") ? [O(e, "geoObject")] : [C(e, t), e]
        }
      }), n.setRule({
        name: "clusterer",
        key: "projection",
        rule: "plain"
      }), m.setRule({
        name: "geoObject",
        rule: "prefixed"
      }), m.setRule({
        name: "projection",
        rule: "plain"
      });
      var P = {
        alphabetical: function(e, t) {
          var n = e.properties,
            s = t.properties,
            o = n.get("clusterCaption") || n.get("balloonContentHeader") || "",
            i = s.get("clusterCaption") || s.get("balloonContentHeader") || "";
          return o == i ? this._objects[r.get(e)].order - this._objects[r.get(t)].order : o < i ? -1 : 1
        },
        serial: function(e, t) {
          return this._objects[r.get(e)].order - this._objects[r.get(t)].order
        }
      };
      e(M)
    });
  }],
  ['9S', function(ym) {
    ym.modules.define("clusterer.addon.balloon", ["Clusterer", "popup.addonBuilder", "сlusterer.Balloon"], function(e, a, l, n) {
      e(l.build({
        type: "balloon",
        metaEventManager: a.getMetaEventManager(),
        defaultManager: n
      }))
    });
  }],
  ['9T', function(ym) {
    ym.modules.define("clusterer.addon.hint", ["Clusterer", "popup.addonBuilder", "сlusterer.Hint"], function(e, t, n, a) {
      e(n.build({
        type: "hint",
        metaEventManager: t.getMetaEventManager(),
        defaultManager: a
      }))
    });
  }],
  ['9Y', function(ym) {
    ym.modules.define("clusterer.component.Grid", ["util.defineClass"], function(i, r) {
      var t = function() {
        this._grid = {}
      };
      r(t, {
        getCellData: function(i, r) {
          return this._grid[i][r]
        },
        setCellData: function(i, r, t) {
          this._grid[i][r] = t
        },
        clearAll: function() {
          this._grid = {}
        },
        clearCell: function(i, r) {
          this._grid[i] && this._grid[i][r] && (this._grid[i].yCounter--, delete this._grid[i][r], this._grid[i].yCounter || delete this._grid[i])
        },
        clearCells: function(i) {
          if (i)
            for (var r = 0, t = i.length; r < t; r++)
              for (var e = i[r][0][1], n = i[r][1][1], l = i[r][0][0], o = i[r][1][0]; l < o; l++)
                for (var s = e; s < n; s++) this.clearCell(l, s);
          else
            for (var d in this._grid)
              for (var f in this._grid[d]) "yCounter" != f && this.clearCell(d, f)
        },
        createCell: function(i, r, t) {
          this._grid[r] = {}, this._grid[r].yCounter = 0, "undefined" == typeof this._grid[r][t] && (this._grid[r].yCounter++, this._grid[r][t] = i(r, t))
        },
        createCells: function(i, r) {
          for (var t = 0, e = r.length; t < e; t++)
            for (var n = r[t][0][1], l = r[t][1][1], o = r[t][0][0], s = r[t][1][0]; o < s; o++) {
              "undefined" == typeof this._grid[o] && (this._grid[o] = {}, this._grid[o].yCounter = 0);
              for (var d = n; d < l; d++) "undefined" == typeof this._grid[o][d] && (this._grid[o].yCounter++, this._grid[o][d] = i(o, d))
            }
        },
        forEach: function(i, r, t) {
          if (t)
            for (var e = 0, n = t.length; e < n; e++)
              for (var l = t[e][0][1], o = t[e][1][1], s = t[e][0][0], d = t[e][1][0]; s < d; s++)
                for (var f = l; f < o; f++) i.call(r, this.getCellData(s, f));
          else
            for (var a in this._grid)
              for (var h in this._grid[a]) "yCounter" != h && i.call(r, this.getCellData(a, h))
        }
      }), i(t)
    });
  }],
  ['91', function(ym) {
    ym.modules.define("clusterer.component.GridBoundsGetter", ["util.defineClass", "component.TileBoundsGetter"], function(i, t, n) {
      var r = function(i) {
        r.superclass.constructor.call(this, i), this._oldTileBounds = null
      };
      t(r, n, {
        setMap: function(i) {
          r.superclass.setMap.call(this, i), this._applyGridSize()
        },
        update: function() {
          this._applyGridSize(), r.superclass.update.call(this)
        },
        get: function() {
          var i = r.superclass.get.call(this);
          return i != this._oldTileBounds && (i ? this._gridBounds = this._fromTileBoundsToGridBounds(i) : this._gridBounds = null, this._oldTileBounds = i), this._gridBounds
        },
        fireChangeEvent: function(i, t, n, r) {
          this.events.fire("gridboundschange", {
            oldGridBounds: this._fromTileBoundsToGridBounds(i),
            newGridBounds: this._fromTileBoundsToGridBounds(t),
            oldZoom: n,
            newZoom: r
          })
        },
        _fromTileBoundsToGridBounds: function(i) {
          for (var t = [], n = 256 / this._currentGridSize, r = 0, s = i.length; r < s; r++) {
            t[r] = [];
            for (var e = 0, o = i[r].length; e < o; e++) {
              t[r][e] = [];
              for (var d = 0, u = i[r][e].length; d < u; d++) t[r][e][d] = i[r][e][d] * n
            }
          }
          return t
        },
        _applyGridSize: function() {
          this._currentGridSize = Math.min(this.options.get("gridSize", 64), 256), this._currentGridSize = Math.max(this._currentGridSize, 2);
          var i = Math.round(Math.log(this._currentGridSize) / Math.LN2);
          this._currentGridSize = Math.pow(2, i)
        }
      }), i(r)
    });
  }],
  ['92', function(ym) {
    ym.modules.define("clusterer.component.GridClusterer", ["util.defineClass", "clusterer.component.GridBoundsGetter", "clusterer.component.Grid", "component.tileBoundsGetter.util", "util.array", "util.bounds", "util.pixelBounds", "util.id", "util.bind", "util.margin", "util.extend", "util.math.areEqual", "event.Manager", "Monitor"], function(e, t, s, r, i, o, n, h, a, d, u, l, c, p, _) {
      function g(e, t) {
        return h.containsPoint([e[0],
          [e[1][0] - 1, e[1][1] - 1]
        ], t)
      }
      var f = function(e) {
        this.options = e, this._gridBoundsGetter = new s(e), this._objectWrappers = [], this._unprocessedObjects = [], this._grid = new r, this.events = new p({
          context: this
        }), this._optionMonitor = null, this._createCellBindFunction = d(this._getCellData, this), this._wrappersById = {}, this._clustersById = {}
      };
      t(f, {
        add: function(e) {
          var t, s, r = this._map,
            i = [];
          for (t = 0, s = e.length; t < s; t++) "Point" == e[t].geometry.type && i.push(e[t]);
          if (r) {
            var n = this._getSortedObjectWrappers(i);
            this._objectWrappers = o.merge(this._objectWrappers, n, m), this._generateObjectsGridNumbers(n);
            var h = this._addToGrid(n, this._gridBoundsGetter.get());
            this._regenerateClusters(h), this._checkBounds()
          } else this._unprocessedObjects = this._unprocessedObjects.concat(i);
          return this
        },
        remove: function(e) {
          if (this._map) {
            var t = this._removeObjectsFromGrid(e);
            this._regenerateClusters(t)
          } else this._removeUnprocessedObjects(e);
          return this._removeObjectWrappers(e), this._checkBounds(), this
        },
        removeAll: function() {
          return this._map && (this._fireRemoveAll(), this._grid.clearAll(), this._grid.createCells(this._createCellBindFunction, this._gridBoundsGetter.get()), this._checkBounds()), this._clustersById = {}, this._objectWrappers = [], this._unprocessedObjects = [], this._wrappersById = {}, this
        },
        setMap: function(e) {
          this._map = e, e ? (this._gridBoundsGetter.setMap(e), this._addToMap(e)) : (this._removeFromMap(e), this._gridBoundsGetter.setMap(e))
        },
        getMap: function() {
          return this._map
        },
        destroy: function() {
          this._map && this._removeFromMap(this._map), this._map = null, this.removeAll(), this.events.fire("destroy")
        },
        getObjectState: function(e) {
          return this._map && this._wrappersById[e] ? {
            isShown: !!this._wrappersById[e].isShown,
            isClustered: !!this._wrappersById[e].isClustered,
            cluster: this._wrappersById[e].cluster
          } : null
        },
        getObject: function(e) {
          return e in this._wrappersById ? l({}, this._wrappersById[e].hash) : e in this._clustersById ? l({}, this._clustersById[e]) : null
        },
        getAll: function() {
          for (var e = [], t = 0, s = this._objectWrappers.length; t < s; t++) e.push(this._objectWrappers[t].hash);
          return e.concat(this._unprocessedObjects)
        },
        getBounds: function() {
          if (this._map) {
            for (var e = this.getAll(), t = [], s = 0, r = e.length; s < r; s++) t.push(e[s].geometry.coordinates);
            return t.length > 0 ? n.fromPoints(t, this._map.options.get("projection")) : null
          }
          return null
        },
        getPixelBounds: function() {
          if (this._map) {
            for (var e = this.getAll(), t = [], s = this._map.getZoom(), r = this._map.options.get("projection"), i = 0, o = e.length; i < o; i++) t.push(r.toGlobalPixels(e[i].geometry.coordinates, s));
            return h.fromPoints(t)
          }
          return null
        },
        _addToMap: function(e) {
          if (this._applyGridSize(), this._setupOptionMonitor(), this._unprocessedObjects.length) {
            var t = this._getSortedObjectWrappers(this._unprocessedObjects);
            this._objectWrappers = o.merge(this._objectWrappers, t, m), this._unprocessedObjects = []
          }
          this._generateObjectsGridNumbers(this._objectWrappers), this._gridBoundsListener = this._gridBoundsGetter.events.group().add("gridboundschange", this._onGridBoundsChange, this);
          var s = this._gridBoundsGetter.get();
          this._grid.createCells(this._createCellBindFunction, s), this._addToGrid(this._objectWrappers, s), this._grid.forEach(this._generateClusters, this, s), this._showClusters()
        },
        _removeFromMap: function(e) {
          this._clearOptionMonitor(), this._fireRemoveAll(), this._clearClusterData(), this._gridBoundsListener.removeAll(), this._grid.clearAll()
        },
        _getSortedObjectWrappers: function(e) {
          for (var t = [], s = 0, r = e.length; s < r; s++) {
            var i = {
              hash: e[s],
              pixelCoordsAtNull: this._map.options.get("projection").toGlobalPixels(e[s].geometry.coordinates, 0)
            };
            t.push(i), this._wrappersById[e[s].id] = i
          }
          return t.sort(m), t
        },
        _generateObjectsGridNumbers: function(e) {
          for (var t = 0, s = e.length; t < s; t++) e[t].gridNumber = this._getGridNumber(e[t].pixelCoordsAtNull)
        },
        _getGridNumber: function(e) {
          var t = this._currentGridSize,
            s = Math.pow(2, this._map.getZoom()),
            r = [e[0] * s, e[1] * s];
          return r = [Math.floor(r[0] / t), Math.floor(r[1] / t)]
        },
        _addToGrid: function(e, t) {
          for (var s = {}, r = this._getGridNumbersArray(e), i = 0, n = t.length; i < n; i++)
            for (var h = o.findAfterValue(r, t[i][0][0]), d = o.findAfterValue(r, t[i][1][0]), u = h; u < d; u++) {
              var l = r[u];
              if (g(t[i], l)) {
                var c = this._grid.getCellData(l[0], l[1]),
                  p = e[u].pixelCoordsAtNull,
                  _ = e[u].hash,
                  f = Math.pow(2, this._map.getZoom());
                s[a.get(c)] || (s[a.get(c)] = {
                  cell: c,
                  gridX: l[0],
                  gridY: l[1]
                }, this._removeCluster(c)), c.sumX += p[0] * f, c.sumY += p[1] * f, c.geoObjects.push(_)
              }
            }
          return s
        },
        _getGridNumbersArray: function(e) {
          for (var t = [], s = 0, r = e.length; s < r; s++) t.push(e[s].gridNumber);
          return t
        },
        _removeCluster: function(e) {
          if (e.clusters.length || e.geoObjectsWithoutClusters.length) {
            for (var t = 0, s = e.clusters.length; t < s; t++) delete this._clustersById[e.clusters[t].id];
            this._fireStateChange({
              removed: e.geoObjectsWithoutClusters,
              removedClusters: e.clusters
            }), e.clusters = [], e.geoObjectsWithoutClusters = [];
            for (var t = 0, s = e.geoObjects.length; t < s; t++) {
              var r = this._wrappersById[e.geoObjects[t].id];
              delete r.isShown, delete r.isClustered, delete r.cluster
            }
          }
        },
        _regenerateClusters: function(e) {
          for (var t in e) e.hasOwnProperty(t) && (this._generateClusters(e[t].cell), this._showGridCluster(e[t].cell))
        },
        _generateClusters: function(e) {
          if (this._map.getZoom() > this.options.get("maxZoom", Number.POSITIVE_INFINITY))
            for (var t = e.geoObjects, s = 0, r = t.length; s < r; s++) {
              e.geoObjectsWithoutClusters.push(t[s]);
              var i = this._wrappersById[t[s].id];
              i.isShown = !0, i.isClustered = !1
            } else this.options.get("groupByCoordinates", !1) ? this._createGroupedByCoordinatesClusters(e) : this._createCellCluster(e)
        },
        _createGroupedByCoordinatesClusters: function(e) {
          for (var t, s, r = {}, i = this._map.options.get("projection"), o = 0, n = e.geoObjects.length; o < n; o++) {
            var h = e.geoObjects[o];
            s = i.toGlobalPixels(h.geometry.coordinates, 23), t = [Math.floor(s[0]), Math.floor(s[1])].toString(), r[t] || (r[t] = []), r[t].push(h)
          }
          for (t in r) {
            var a, d = r[t];
            if (d.length >= this.options.get("minClusterSize", 2)) {
              var u = this._createCluster(d[0].geometry.coordinates, d);
              e.clusters.push(u);
              for (var o = 0, n = d.length; o < n; o++) a = this._wrappersById[d[o].id], a.isClustered = !0, a.cluster = u, a.isShown = !0
            } else {
              e.geoObjectsWithoutClusters = e.geoObjectsWithoutClusters.concat(d);
              for (var o = 0, n = d.length; o < n; o++) a = this._wrappersById[d[o].id], a.isClustered = !1, a.isShown = !0
            }
          }
        },
        _createCellCluster: function(e) {
          if (e.geoObjects.length >= this.options.get("minClusterSize", 2)) {
            var t = e.geoObjects.length,
              s = [e.sumX / t, e.sumY / t],
              r = this._getCorrectMargin(this.options.get("margin", 10)),
              i = this._map.getZoom(),
              o = this._currentGridSize / 2,
              n = e.center,
              h = Math.max(Math.round(n[0] - (o - r[3])), s[0]);
            h = Math.min(n[0] + (o - r[1]), h);
            var a = Math.max(n[1] - (o - r[0]), s[1]);
            a = Math.min(n[1] + (o - r[2]), a);
            var d = this._map.options.get("projection").fromGlobalPixels([h, a], i),
              u = this._createCluster(d, e.geoObjects);
            e.clusters.push(u);
            for (var l, c = 0, p = e.geoObjects.length; c < p; c++) l = this._wrappersById[e.geoObjects[c].id], l.isClustered = !0, l.cluster = u, l.isShown = !0
          } else {
            e.geoObjectsWithoutClusters = e.geoObjects.slice();
            for (var l, c = 0, p = e.geoObjects.length; c < p; c++) l = this._wrappersById[e.geoObjects[c].id], l.isClustered = !1, l.isShown = !0
          }
        },
        _createCluster: function(e, t) {
          var s = {
            id: a.gen(),
            type: "Cluster",
            geometry: {
              type: "Point",
              coordinates: e
            },
            features: t,
            number: t.length,
            properties: {
              geoObjects: t,
              iconContent: t.length
            },
            options: {}
          };
          return this._clustersById[s.id] = s, s
        },
        _showGridCluster: function(e) {
          e.geoObjects.length && this._fireStateChange({
            added: e.geoObjectsWithoutClusters,
            addedClusters: e.clusters
          })
        },
        _removeObjectWrappers: function(e) {
          for (var t, s = [], r = 0, i = this._objectWrappers.length; r < i; r++) {
            t = !1;
            for (var o = 0, n = e.length; o < n && !t; o++) e[o].id == this._objectWrappers[r].hash.id && (delete this._wrappersById[e[o].id], t = !0);
            t || s.push(this._objectWrappers[r])
          }
          this._objectWrappers = s
        },
        _removeObjectsFromGrid: function(e) {
          var t = this._gridBoundsGetter.get();
          if (t) {
            for (var s = {}, r = this._getGridNumbersArray(this._objectWrappers), i = Math.pow(2, this._map.getZoom()), o = {}, n = 0, h = this._objectWrappers.length; n < h; n++) o[this._objectWrappers[n].hash.id] = n;
            for (var n = 0, h = e.length; n < h; n++) {
              var d = e[n],
                u = o[d.id],
                l = this._objectWrappers[u];
              if (l && !l.deleted) {
                l.deleted = !0;
                for (var c = 0, p = t.length; c < p; c++) {
                  var _ = r[u];
                  if (g(t[c], _)) {
                    var f = this._grid.getCellData(_[0], _[1]),
                      m = l.pixelCoordsAtNull;
                    s[a.get(f)] || (s[a.get(f)] = {
                      cell: f,
                      gridX: _[0],
                      gridY: _[1],
                      removedObjects: {}
                    }, this._removeCluster(f)), f.sumX -= m[0] * i, f.sumY -= m[1] * i, s[a.get(f)].removedObjects[d.id] = !0
                  }
                }
              }
            }
            for (var b = [], n = 0, h = this._objectWrappers.length; n < h; n++) this._objectWrappers.deleted || b.push(this._objectWrappers[n]);
            this._objectWrappers = b;
            for (var n in s)
              if (s.hasOwnProperty(n)) {
                for (var v = [], j = s[n].cell.geoObjects, C = 0, h = j.length; C < h; C++) s[n].removedObjects[j[C].id] || v.push(j[C]);
                s[n].cell.geoObjects = v
              }
            return s
          }
        },
        _indexOfObject: function(e) {
          for (var t = 0, s = this._objectWrappers.length; t < s;) {
            if (e.id == this._objectWrappers[t].hash.id) return t;
            t++
          }
          return -1
        },
        _onGridBoundsChange: function(e) {
          e.get("oldZoom") != e.get("newZoom") ? this._refresh() : this._onGridBoundsMove(e)
        },
        _onGridBoundsMove: function(e) {
          var t = i.getDisjointArea(e.get("newGridBounds"), e.get("oldGridBounds")),
            s = t.added;
          this._grid.createCells(this._createCellBindFunction, s);
          var r = this._addToGrid(this._objectWrappers, s);
          this._regenerateClusters(r);
          var o = t.removed;
          this._grid.forEach(this._removeCluster, this, o), this._grid.clearCells(o)
        },
        _refresh: function() {
          var e = this._getVisibleObjects();
          this._clearClusterData(), this._grid.clearAll(), this._applyGridSize(), this._gridBoundsGetter.update();
          var t = this._gridBoundsGetter.get();
          this._grid.createCells(this._createCellBindFunction, t), this._generateObjectsGridNumbers(this._objectWrappers), this._addToGrid(this._objectWrappers, t), this._grid.forEach(this._generateClusters, this, t);
          var s = this._getVisibleObjects(),
            r = this._getUpdatedObjectArrays(e.objects, s.objects);
          this._fireStateChange({
            added: r.added,
            removed: r.removed,
            update: r.update,
            removedClusters: e.clusters,
            addedClusters: s.clusters
          })
        },
        _getVisibleObjects: function() {
          var e = [],
            t = [];
          return this._grid.forEach(function(s) {
            e = e.concat(s.geoObjectsWithoutClusters), t = t.concat(s.clusters)
          }, this), {
            objects: e,
            clusters: t
          }
        },
        _getUpdatedObjectArrays: function(e, t) {
          e.sort(b), t.sort(b);
          for (var s = [], r = [], i = [], o = 0, n = 0, h = e.length, a = t.length; o < h && n < a;) e[o].id < t[n].id ? (r.push(e[o]), o++) : e[o].id > t[n].id ? (s.push(t[n]), n++) : (i.push(e[o]), o++, n++);
          return o != h && (r = r.concat(e.slice(o))), n != a && (s = s.concat(t.slice(n))), {
            added: s,
            removed: r,
            update: i
          }
        },
        _fireRemoveAll: function() {
          var e = [],
            t = [];
          this._grid.forEach(function(t) {
            e = e.concat(t.geoObjectsWithoutClusters)
          }, this);
          for (var s in this._clustersById) t.push(this._clustersById[s]);
          this._fireStateChange({
            removed: e,
            removedClusters: t,
            sync: !0
          })
        },
        _showClusters: function(e) {
          this._grid.forEach(this._showGridCluster, this, e || this._gridBoundsGetter.get())
        },
        _getCorrectMargin: function(e) {
          for (var t = this._currentGridSize / 2, s = u.correct(e), r = 0; r < 4; r++) s[r] = Math.min(s[r], t);
          return s
        },
        _setupOptionMonitor: function() {
          this._optionMonitor = new _(this.options).add(["gridSize", "viewportMargin", "margin", "minClusterSize", "maxZoom", "groupByCoordinates"], this._refresh, this)
        },
        _clearOptionMonitor: function() {
          this._optionMonitor.destroy()
        },
        _fireStateChange: function(e) {
          this.events.fire("statechange", {
            added: e.added || [],
            removed: e.removed || [],
            addedClusters: e.addedClusters || [],
            removedClusters: e.removedClusters || [],
            update: e.update || [],
            sync: e.sync
          })
        },
        _getCellData: function(e, t) {
          var s = this._currentGridSize;
          return {
            sumX: 0,
            sumY: 0,
            center: [e * s + s / 2, t * s + s / 2],
            geoObjects: [],
            clusters: [],
            geoObjectsWithoutClusters: []
          }
        },
        _removeUnprocessedObjects: function(e) {
          for (var t, s = [], r = 0, i = this._unprocessedObjects.length; r < i; r++) {
            t = !0;
            for (var o = 0, n = e.length; o < n && !t; o++) e[o].id == this._unprocessedObjects[r].id && (t = !1);
            t && s.push(this._unprocessedObjects[r])
          }
          this._unprocessedObjects = s
        },
        _applyGridSize: function() {
          this._currentGridSize = Math.min(this.options.get("gridSize", 64), 256), this._currentGridSize = Math.max(this._currentGridSize, 2);
          var e = Math.round(Math.log(this._currentGridSize) / Math.LN2);
          this._currentGridSize = Math.pow(2, e)
        },
        _clearClusterData: function() {
          this._clustersById = {};
          for (var e in this._wrappersById) this._wrappersById[e].cluster = null, this._wrappersById[e].isClustered = !1, this._wrappersById[e].isShown = !1
        },
        _checkBounds: function() {
          var e = this.getPixelBounds();
          !!this._oldBounds == !!e && e && c(e[0], this._oldBounds[0]) && c(e[1], this._oldBounds[1]) || (this.events.fire("pixelboundschange"), this._oldBounds = e)
        }
      });
      var m = function(e, t) {
          return e.pixelCoordsAtNull[0] - t.pixelCoordsAtNull[0]
        },
        b = function(e, t) {
          return e.id > t.id ? 1 : e.id == t.id ? 0 : -1
        };
      e(f)
    });
  }],
  ['2D', function(ym) {
    ym.modules.define("clusterer.DataManager", ["util.defineClass", "data.BaseManager"], function(e, t, s) {
      function a(e) {
        a.superclass.constructor.call(this), this._sourceDataManager = e, this._sourceDataManager.events.add("change", this._onSourceDataChange, this), this._activeObject = e.get("activeObject");
        for (var t = e.get("geoObjects"), s = 0, i = t.length; s < i; s++) this._setupGeoObjectListeners(t[s]);
        this._activeObject && this._setupGeoObjectListeners(this._activeObject)
      }
      t(a, s, {
        get: function(e, t) {
          var s, a = e.split("."),
            i = this._getChildDataManager(a);
          return s = i ? i.get(this._getSubQuery(e, a["geoObjects" == a[0] ? 2 : 1]), t) : this._sourceDataManager.get(e, t)
        },
        destroy: function() {
          this._sourceDataManager.events.remove("change", this._onSourceDataChange, this);
          for (var e = this._sourceDataManager.get("geoObjects"), t = 0, s = e.length; t < s; t++) this._clearGeoObjectListeners(e[t]);
          this._activeObject && this._clearGeoObjectListeners(this._activeObject), a.superclass.destroy.call(this)
        },
        _onSourceDataChange: function() {
          var e = this._sourceDataManager.get("activeObject");
          this._activeObject != e && (this._activeObject && this._clearGeoObjectListeners(this._activeObject), this._activeObject = e, this._activeObject && this._setupGeoObjectListeners(this._activeObject)), this.fireChangeEvent()
        },
        _getChildDataManager: function(e) {
          var t, s = e.length,
            a = e[0],
            i = null;
          if ("geoObjects" == a && s > 3) {
            if (t = e[2], "state" == t || "properties" == t || "options" == t) {
              var n = e[1],
                c = this._sourceDataManager.get("geoObjects");
              i = c[n] && c[n][t]
            }
          } else if ("activeObject" == a && s > 2 && (t = e[1], "state" == t || "properties" == t || "options" == t)) {
            var r = this._sourceDataManager.get("activeObject");
            i = r && r[t]
          }
          return i
        },
        _getSubQuery: function(e, t) {
          return e.substr(e.indexOf(t) + t.length + 1)
        },
        _setupGeoObjectListeners: function(e) {
          e.properties.events.add("change", this.fireChangeEvent, this), e.state.events.add("change", this.fireChangeEvent, this), e.options.events.add("change", this.fireChangeEvent, this)
        },
        _clearGeoObjectListeners: function(e) {
          e.properties.events.remove("change", this.fireChangeEvent, this), e.state.events.remove("change", this.fireChangeEvent, this), e.options.events.remove("change", this.fireChangeEvent, this)
        }
      }), e(a)
    });
  }],
  ['9U', function(ym) {
    ym.modules.define("clusterer.optionMapper", ["option.Mapper"], function(e, n) {
      e(new n)
    });
  }],
  ['2B', function(ym) {
    ym.modules.define("ClusterPlacemark", ["util.defineClass", "util.bounds", "option.Manager", "collection.Item", "event.globalize", "vow", "data.Manager", "cluster.optionMapper", "clusterer.optionMapper", "geoObject.optionMapper", "clusterPlacemark.View", "geometry.Point", "theme.islands.cluster.metaOptions"], function(e, t, s, n, o, i, r, l, u, a, c, p, h, g) {
      function d(e, t) {
        return t + e.slice(0, 1).toUpperCase() + e.slice(1)
      }
      var m = function(e, t, s) {
          m.superclass.constructor.call(this), this.options = this._createOptionManager(s), "function" == typeof e.getType ? this.geometry = e : this.geometry = new h(e.coordinates || e), this.properties = t, this.state = new l, this._clusterBounds = null, this._clusterListeners = this.events.group(), this.events.addController(f), this.events.fire("create")
        },
        f = i(m);
      t(m, o, {
        getGeoObjects: function() {
          return this.properties.get("geoObjects")
        },
        getOverlay: function() {
          return this._view ? this._view.getOverlay() : r.reject("ClusterPlacemark wasn't added to map.")
        },
        getOverlaySync: function() {
          return this._view ? this._view.getOverlaySync() : null
        },
        onAddToMap: function(e) {
          this.options.get("disableClickZoom") || this._clusterListeners.add("click", this._onClickZoom, this, 100), this.geometry.setMap(e), this.geometry.options.setParent(this.options), this._setupView(e)
        },
        onRemoveFromMap: function(e) {
          this.options.get("disableClickZoom") || this._clusterListeners.removeAll(), this._clearView(), this.geometry.setMap(null), this.geometry.options.setParent(null)
        },
        getBounds: function() {
          return this._clusterBounds || this._calculateClusterBounds(), this._clusterBounds
        },
        _onClickZoom: function(e) {
          if (!e.isDefaultPrevented()) {
            var t = this.getMap();
            t.getZoom() != t.zoomRange.getCurrent()[1] && (this.getBounds(), this._setMapBounds(), e.preventDefault())
          }
        },
        _setupView: function() {
          this._view = new p(this)
        },
        _clearView: function() {
          this._view.destroy()
        },
        _calculateClusterBounds: function() {
          for (var e, t = this.getGeoObjects(), n = [], o = 0, i = t.length; o < i; o++) n.push(t[o].geometry.getCoordinates());
          e = 0 == n.length ? null : s.fromPoints(n, this.options.get("projection")), this._clusterBounds = e
        },
        _setMapBounds: function() {
          var e = this.getMap();
          e.setBounds(this._clusterBounds, {
            preciseZoom: !e.options.get("avoidFractionalZoom"),
            margin: this.options.get("zoomMargin", 0),
            useMapMargin: this.options.get("useMapMargin", !0),
            checkZoomRange: !0
          })
        },
        _createOptionManager: function(e) {
          var t = new n(null, null, "cluster", u);
          return t.get = function(e, t) {
            var s = n.prototype.getNative.call(this, e);
            return "undefined" == typeof s && (s = n.prototype.get.call(this, d(e, "cluster")), "undefined" == typeof s && (s = n.prototype.get.call(this, e, t))), s
          }, t
        }
      }), u.setRule({
        name: ["balloon", "hint"],
        rule: "prefixed"
      }), a.setRule({
        name: "cluster",
        rule: function(e, t) {
          return [d(e, t), e]
        }
      }), a.setRule({
        name: "cluster",
        key: "projection",
        rule: "plain"
      }), c.setRule({
        name: "cluster",
        rule: function(e, t) {
          return [d(e, t), e]
        }
      }), c.setRule({
        name: "cluster",
        key: "projection",
        rule: "plain"
      }), e(m)
    });
  }],
  ['9X', function(ym) {
    ym.modules.define("clusterPlacemark.View", ["util.defineClass", "vow", "util.callbackChunker", "util.cancelableCallback", "constants.zIndex", "option.Manager", "option.Mapper", "Monitor", "geoObject.view.component.Dragger", "overlay.storage", "event.Mapper", "geoObject.view.component.OverlayEventMappingTable", "constants.zIndex"], function(e, t, r, i, n, s, a, l, o, c, v, h, _, s) {
      function u(e, t) {
        return t + e.slice(0, 1).toUpperCase() + e.slice(1)
      }
      var y = {
          defaultValue: !0
        },
        p = function(e) {
          this._cluster = e, this._overlay = null, this._overlayData = null, this._cancelableCallback = null, this._chunker = i.get(this._cluster.getMap()), this._chunkerCallbackId = NaN, this._optionMonitor = new o(this._cluster.options), this._startOverlayCreating(), this._setupVisibilityListener(), this._overlayEventsListener = null, this._previousZIndex = null
        };
      p.GeoObjectIsHiddenError = function() {
        return new Error("GeoObject is not visible")
      }, p.GeoObjectRemovedFromMapError = function() {
        return new Error("GeoObject was removed from map")
      }, p.OverlayWasntFoundError = function() {
        return new Error("Overlay wasn't found")
      }, t(p, {
        getOverlay: function() {
          return this._overlayDeferred || (this._overlayDeferred = r.defer(), this._overlayRejectMessageFunc ? this._overlayDeferred.reject(this._overlayRejectMessageFunc()) : this._overlay && this._overlayDeferred.resolve(this._overlay)), this._overlayDeferred.promise()
        },
        getOverlaySync: function() {
          return this._overlay || null
        },
        destroy: function() {
          this._optionMonitor.removeAll(), this._rejectOverlayPromises(p.GeoObjectRemovedFromMapError), this._clearOverlayAndFire(), this._clearOverlayOptionManager(), this._overlayData = null
        },
        _startOverlayCreating: function() {
          this._overlayDeferred = null, this._constructOverlay()
        },
        _clearOverlayAndFire: function() {
          this._overlayDeferred = null;
          var e = !!this._overlay;
          this._overlay && (this._overlay.events.setParent(null), this._overlay.setMap(null), this._overlay.options.setParent(null), this._stopOverlayEventsListening(), this._clearHoverZIndex()), this._overlay = null, e > 0 && this._fireOverlayChange()
        },
        _constructOverlay: function() {
          this._overlayRejectMessageFunc = null;
          var e = this._cluster.options.get("pointOverlay");
          if ("string" == typeof e) {
            var t = e;
            if (e = v.get(t), "undefined" == typeof e) return this._cancelableCallback = n.create(this._createOverlay, this), void v.require([t]).spread(this._cancelableCallback, function() {
              this._rejectOverlayPromises(p.OverlayWasntFoundError)
            }, this)
          }
          this._createOverlay(e)
        },
        _createOverlay: function(e) {
          this._cancelableCallback = null, this._overlayClass = e, this._cluster.options.get("syncOverlayInit") ? this._setupOverlay() : this._chunkerCallbackId = this._chunker.addCallback(this._setupOverlay, this)
        },
        _fulfillOverlayPromises: function() {
          this._overlayDeferred && this._overlayDeferred.resolve(this._overlay)
        },
        _rejectOverlayPromises: function(e) {
          this._clearAsyncOperations(), this._overlayRejectMessageFunc = e, this._overlayDeferred && this._overlayDeferred.reject(e())
        },
        _clearAsyncOperations: function() {
          this._cancelableCallback && (this._cancelableCallback.cancel(), this._cancelableCallback = null), this._chunkerCallbackId && (this._chunker.removeCallback(this._chunkerCallbackId), this._chunkerCallbackId = NaN)
        },
        _setupOverlay: function() {
          this._chunkerCallbackId = NaN;
          var e = this._overlayData || (this._overlayData = {
              geometry: this._cluster.geometry,
              properties: this._cluster.properties,
              state: this._cluster.state,
              geoObject: this._cluster
            }),
            t = new this._overlayClass(this._cluster.geometry.getPixelGeometry(), e);
          this._setupOverlayOptionManager(), this._setupMappingRules(t.options.getName()), t.options.setParent(this._overlayOptionManager), t.setMap(this._cluster.getMap()), t.events.setParent(new h(this._cluster.events, new _(this._cluster))), this._overlay = t, this._startOverlayEventsListening(), this._fulfillOverlayPromises(), this._fireOverlayChange()
        },
        _fireOverlayChange: function() {
          this._cluster.events.fire("overlaychange", {
            overlay: this._overlay || null
          })
        },
        _setupVisibilityListener: function() {
          this._optionMonitor.add("visible", this._onVisibilityChange, this, y)
        },
        _clearVisibilityListener: function() {
          this._optionMonitor.remove("visible")
        },
        _onVisibilityChange: function() {
          this._optionMonitor.get("visible") ? this._startOverlayCreating() : (this._rejectOverlayPromises(p.GeoObjectIsHiddenError), this._clearOverlayAndFire())
        },
        _setupOverlayOptionManager: function() {
          this._overlayOptionManager && null != this._overlayOptionManager.getParent() || (this._overlayOptionNames = {}, this._overlayOptionMapper = new l, this._overlayOptionManager = new a(null, this._cluster.options, null, this._overlayOptionMapper))
        },
        _clearOverlayOptionManager: function() {
          this._overlayOptionManager && this._overlayOptionManager.setParent(null)
        },
        _setupMappingRules: function(e) {
          this._overlayOptionMapper.setRule({
            name: e,
            rule: function(e) {
              return [u(e, "icon"), e]
            }
          }), this._overlayOptionMapper.setRule({
            name: e,
            key: "projection",
            rule: "plain"
          })
        },
        _startOverlayEventsListening: function() {
          this._overlayEventsListener = this._overlay.events.group().add(["mouseenter", "mouseleave"], this._onOverlayHoverChange, this)
        },
        _stopOverlayEventsListening: function() {
          this._overlayEventsListener.removeAll()
        },
        _onOverlayHoverChange: function(e) {
          "mouseenter" == e.get("type") ? this._setupHoverZIndex() : this._clearHoverZIndex()
        },
        _setupHoverZIndex: function() {
          this._previousZIndex = this._overlay.options.get("zIndex", 0), this._overlay.options.set("zIndex", this._overlay.options.get("zIndexHover", s.hover))
        },
        _clearHoverZIndex: function() {
          null !== this._previousZIndex && (this._overlay.options.set("zIndex", this._previousZIndex), this._previousZIndex = null)
        }
      }), e(p)
    });
  }],
  ['0x', function(ym) {
    ym.modules.define("Collection", ["util.defineClass", "collection.Item", "component.collection.ParentCollection", "event.Mapper", "collection.EventMappingTable"], function(t, e, n, i, o, r) {
      function l(t) {
        this._childrenCount = 0, l.superclass.constructor.call(this, t), this._collectionImplementation = new i(this, {
          onAdd: {
            callback: this._onAdd,
            context: this
          },
          onRemove: {
            callback: this._onRemove,
            context: this
          }
        }, new o(this.events, this.getEventMappingTable()))
      }
      e(l, n, {
        add: function(t) {
          return this._collectionImplementation.add(t), this._childrenCount = this._collectionImplementation.getLength(), this
        },
        remove: function(t) {
          return this._collectionImplementation.remove(t), this._childrenCount = this._collectionImplementation.getLength(), this
        },
        removeAll: function() {
          return this._collectionImplementation.removeAll(), this._childrenCount = 0, this
        },
        getIterator: function() {
          return this._collectionImplementation.getIterator()
        },
        each: function(t, e) {
          return this._collectionImplementation.each(t, e), this
        },
        getLength: function() {
          return this._childrenCount
        },
        filter: function(t) {
          for (var e, n = this.getIterator(), i = [];
            (e = n.getNext()) != n.STOP_ITERATION;) t(e) && i.push(e);
          return i
        },
        get: function(t) {
          if (t > -1 && t < this._childrenCount) {
            for (var e = this.getIterator(), n = 0; n < t; n++) e.getNext();
            return e.getNext()
          }
          return null
        },
        getAll: function() {
          for (var t, e = this.getIterator(), n = [];
            (t = e.getNext()) != e.STOP_ITERATION;) n.push(t);
          return n
        },
        indexOf: function(t) {
          for (var e, n = 0, i = this.getIterator();
            (e = i.getNext()) != i.STOP_ITERATION;) {
            if (t == e) return n;
            n++
          }
          return -1
        },
        getEventMappingTable: function() {
          return new r(this)
        },
        _onAdd: function(t) {
          this.events.fire("add", {
            child: t
          })
        },
        _onRemove: function(t) {
          this.events.fire("remove", {
            child: t
          })
        }
      }), t(l)
    });
  }],
  ['0r', function(ym) {
    ym.modules.define("collection.EventMappingTable", ["util.defineClass", "Event"], function(t, n, e) {
      function i(t) {
        this._currentTarget = t, this.parentchange = !1, this.mapchange = !1, this.optionschange = !1, this["*"] = this._defaultMapping
      }
      n(i, {
        _defaultMapping: function(t) {
          return new e({
            currentTarget: this._currentTarget
          }, t)
        }
      }), t(i)
    });
  }],
  ['2b', function(ym) {
    ym.modules.define("collection.Item", ["event.Manager", "option.Manager", "component.child.MapChild"], function(n, t, e, o) {
      function a(n) {
        this.options = this.createOptionManager(n), this.events = new t({
          context: this
        }), this._itemImplementation = new o({
          onParentChange: {
            callback: this._onParentChange,
            context: this
          },
          onMapChange: {
            callback: this._onMapChange,
            context: this
          }
        }), this.options.events.add("change", function(n) {
          this.events.fire("optionschange")
        }, this)
      }
      a.prototype = {
        getParent: function() {
          return this._itemImplementation.getParent()
        },
        setParent: function(n) {
          return this._itemImplementation.setParent(n), this
        },
        getMap: function() {
          return this._itemImplementation.getMap()
        },
        onAddToMap: function(n) {},
        onRemoveFromMap: function(n) {},
        createOptionManager: function(n) {
          return new e(n)
        },
        _onParentChange: function(n, t) {
          this.events.fire("parentchange", {
            newParent: t,
            oldParent: n
          })
        },
        _onMapChange: function(n, t) {
          n && this.onRemoveFromMap(n), t && this.onAddToMap(t), this.events.fire("mapchange", {
            newMap: t,
            oldMap: n
          })
        }
      }, n(a)
    });
  }],
  ['9B', function(ym) {
    ym.modules.define("component.array.BaseArray", ["util.defineClass", "util.array", "util.ArrayIterator"], function(t, n, e, i) {
      function r(t, n) {
        this._children = t || [], this._callbacks = n || {}
      }
      n(r, {
        set: function(t, n) {
          this._set(t, n)
        },
        get: function(t) {
          return this._children[t]
        },
        add: function(t, n) {
          this._add(t, "undefined" != typeof n ? n : this._children.length)
        },
        remove: function(t) {
          this._remove(e.indexOf(this._children, t))
        },
        removeAll: function() {
          for (var t = 0, n = this._children.length; t < n; t++) this._remove(0)
        },
        splice: function(t, n) {
          for (var e = [], i = Array.prototype.slice.call(arguments, 2), r = i.length, c = 0; c < n && t < this._children.length; c++) e.push(c < r ? this._set(t++, i[c]) : this._remove(t));
          for (; c < r; c++) this._add(i[c], t++);
          return e
        },
        getLength: function() {
          return this._children.length
        },
        getIterator: function() {
          return new i(this._children)
        },
        each: function(t, n) {
          e.each(this._children, t, n)
        },
        indexOf: function(t) {
          return e.indexOf(this._children, t)
        },
        sort: function(t) {
          this._children.sort(t)
        },
        quickSort: function(t) {
          return this._children = e.quickSort(this._children, t), this._children
        },
        toArray: function() {
          return this._children.slice()
        },
        _add: function(t, n) {
          this._children.length < n && (this._children.length = n), this._children.splice(n, 0, t);
          var e = this._callbacks.onAdd;
          e && e.callback.call(e.context, n, t)
        },
        _remove: function(t) {
          var n = this._children.splice(t, 1)[0],
            e = this._callbacks.onRemove;
          return e && e.callback.call(e.context, t, n), n
        },
        _set: function(t, n) {
          var e = this._children[t],
            i = this._callbacks.onSet;
          return this._children[t] = n, i && i.callback.call(i.context, t, e, n), e
        }
      }), t(r)
    });
  }],
  ['9C', function(ym) {
    ym.modules.define("component.array.ParentArray", ["util.defineClass", "component.array.BaseArray", "component.parent.BaseParent"], function(t, e, n, a) {
      function r(t, e, r, o, s) {
        t = t || [], this._callbacks = r || {}, this._parent = e, this._parentEvents = o, this._parentOptions = s, this._parentComponent = new a(e, {
          callback: this._childParentChangeCallback,
          context: this
        });
        for (var i = 0, c = t.length; i < c; i++) this._parentComponent.addChild(t[i]);
        this._baseArrayComponent = new n(t, {
          onAdd: {
            callback: this._addCallback,
            context: this
          },
          onRemove: {
            callback: this._removeCallback,
            context: this
          },
          onSet: {
            callback: this._setCallback,
            context: this
          }
        })
      }
      e(r, {
        get: function(t) {
          return this._baseArrayComponent.get(t)
        },
        set: function(t, e) {
          return this._parent == e.getParent() && this._baseArrayComponent.remove(e), this._baseArrayComponent.set(t, e)
        },
        add: function(t, e) {
          this._parent == t.getParent() && this._baseArrayComponent.remove(t), this._baseArrayComponent.add(t, e)
        },
        remove: function(t) {
          this._baseArrayComponent.remove(t)
        },
        removeAll: function() {
          this._baseArrayComponent.removeAll()
        },
        splice: function(t, e) {
          for (var n = Array.prototype.slice.call(arguments, 2), a = 0, r = n.length; a < r; a++) {
            var o = n[a];
            this._parent == o.getParent() && this._baseArrayComponent.remove(o)
          }
          return this._baseArrayComponent.splice.apply(this._baseArrayComponent, arguments)
        },
        getLength: function() {
          return this._baseArrayComponent.getLength()
        },
        getIterator: function() {
          return this._baseArrayComponent.getIterator()
        },
        each: function(t, e) {
          this._baseArrayComponent.each(t, e)
        },
        indexOf: function(t) {
          return this._baseArrayComponent.indexOf(t)
        },
        sort: function(t) {
          this._baseArrayComponent.sort(t)
        },
        quickSort: function(t) {
          this._baseArrayComponent.quickSort(t)
        },
        toArray: function() {
          return this._baseArrayComponent.toArray()
        },
        _addCallback: function(t, e) {
          this._parentComponent.addChild(e);
          var n = this._callbacks.onAdd;
          n && n.callback.call(n.context, t, e)
        },
        _removeCallback: function(t, e) {
          this._parentComponent.removeChild(e);
          var n = this._callbacks.onRemove;
          n && n.callback.call(n.context, t, e)
        },
        _setCallback: function(t, e, n) {
          this._parentComponent.removeChild(e), this._parentComponent.addChild(n);
          var a = this._callbacks.onSet;
          a && a.callback.call(a.context, t, e, n)
        },
        _childParentChangeCallback: function(t, e, n) {
          this._parent == e && (t.events.setParent(null), t.options.setParent(null), this._baseArrayComponent.indexOf(t) != -1 && this._baseArrayComponent.remove(t)), this._parent == n && (t.events.setParent(this._parentEvents || this._parent.events), t.options.setParent(this._parentOptions || this._parent.options))
        }
      }), t(r)
    });
  }],
  ['9E', function(ym) {
    ym.modules.define("component.child.BaseChild", [], function(t) {
      var n = function(t, n) {
        this._oldParent = null, this._parent = null, this._parentChangeCallback = t, this._context = n
      };
      n.prototype = {
        setParent: function(t) {
          this._parent != t && (this._parent = t, this._parentChangeCallback && this._parentChangeCallback.call(this._context, this._oldParent, this._oldParent = this._parent))
        },
        getParent: function() {
          return this._parent
        }
      }, t(n)
    });
  }],
  ['9F', function(ym) {
    ym.modules.define("component.child.MapChild", ["component.child.BaseChild"], function(t, a) {
      var n = function(t) {
          this._oldMap = null, this._map = null, this._callbacks = t, this._baseItem = new a(this._parentChangeCallback, this)
        },
        e = "mapchange";
      n.prototype = {
        setParent: function(t) {
          this._baseItem.setParent(t)
        },
        getParent: function() {
          return this._baseItem.getParent()
        },
        getMap: function() {
          return this._map
        },
        _parentChangeCallback: function(t, a) {
          t && t.events.remove(e, this._onMapChange, this), this._setupMap(null);
          var n = this._callbacks.onParentChange;
          n && n.callback.call(n.context, t, a), this._setupMap(a && a.getMap()), a && a.events.add(e, this._onMapChange, this)
        },
        _setupMap: function(t) {
          if (this._map != t) {
            this._map = t;
            var a = this._callbacks.onMapChange;
            a && a.callback.call(a.context, this._oldMap, this._oldMap = this._map)
          }
        },
        _onMapChange: function(t) {
          this._setupMap(t.get("newMap"))
        }
      }, t(n)
    });
  }],
  ['9G', function(ym) {
    ym.modules.define("component.collection.BaseCollection", ["util.List"], function(t, i) {
      var e = function(t) {
        this._callbacks = t || {}, this._childList = new i
      };
      e.prototype = {
        add: function(t) {
          if ("undefined" != typeof t && !this._childList.contains(t)) {
            this._childList.insert(t);
            var i = this._callbacks.onAdd;
            i && i.callback.call(i.context, t)
          }
        },
        remove: function(t) {
          if (this._childList.contains(t)) {
            this._childList.remove(t);
            var i = this._callbacks.onRemove;
            i && i.callback.call(i.context, t)
          }
        },
        removeAll: function() {
          for (var t, i = this._childList.getIterator();
            (t = i.getNext()) != i.STOP_ITERATION;) this.remove(t)
        },
        getLength: function() {
          return this._childList.length
        },
        getIterator: function() {
          return this._childList.getIterator()
        },
        each: function(t, i) {
          for (var e, c = this._childList.getIterator();
            (e = c.getNext()) != c.STOP_ITERATION && (i ? t.call(i, e) : t(e)) !== !1;);
        }
      }, t(e)
    });
  }],
  ['9K', function(ym) {
    ym.modules.define("component.collection.ParentCollection", ["component.collection.BaseCollection", "component.parent.BaseParent"], function(t, e, n) {
      var o = function(t, o, a) {
        this._callbacks = o || {}, this._parent = t, this._parentEvents = a, this._parentComponent = new n(t, {
          callback: this._childParentChangeCallback,
          context: this
        }), this._baseCollectionComponent = new e({
          onAdd: {
            callback: this._addCallback,
            context: this
          },
          onRemove: {
            callback: this._removeCallback,
            context: this
          }
        })
      };
      o.prototype = {
        add: function(t) {
          this._baseCollectionComponent.add(t)
        },
        remove: function(t) {
          this._baseCollectionComponent.remove(t)
        },
        removeAll: function() {
          this._baseCollectionComponent.removeAll()
        },
        getLength: function() {
          return this._baseCollectionComponent.getLength()
        },
        getIterator: function() {
          return this._baseCollectionComponent.getIterator()
        },
        each: function(t, e) {
          this._baseCollectionComponent.each(t, e)
        },
        _addCallback: function(t) {
          this._parentComponent.addChild(t);
          var e = this._callbacks.onAdd;
          e && e.callback.call(e.context, t)
        },
        _removeCallback: function(t) {
          this._parentComponent.removeChild(t);
          var e = this._callbacks.onRemove;
          e && e.callback.call(e.context, t)
        },
        _childParentChangeCallback: function(t, e, n) {
          this._parent == e && (t.events.setParent(null), t.options.setParent(null), this._baseCollectionComponent.remove(t)), this._parent == n && (t.events.setParent(this._parentEvents || this._parent.events), t.options.setParent(this._parent.options))
        }
      }, t(o)
    });
  }],
  ['2g', function(ym) {
    ym.modules.define("component.EdgeMove", ["util.defineClass", "util.pixelBounds", "util.vector", "behavior.action", "util.scheduler.strategy.Raf", "util.math.cubicBezier"], function(t, i, e, s, a, n, r) {
      var l = i(function(t, i) {
        this._map = i, this._activePadding = "undefined" != typeof t.activePadding ? t.activePadding : 25, this._activeMargin = "undefined" != typeof t.activeMargin ? t.activeMargin : 150, this._inertiaTimeout = "undefined" != typeof t.inertiaTimeout ? t.inertiaTimeout : 500, this._useMapMargin = "undefined" != typeof t.useMapMargin && t.useMapMargin, this._onTickCallback = t.onTick, this._onTickCallbackThisArg = t.thisArg, this._currentVector = null, this._deltaCallback = null, this._startTime = null, this._process = null
      }, {
        move: function(t) {
          var i = this._getMapGlobalPixelBounds();
          if (e.containsPoint(i, t)) this._process && this._finishProcess();
          else {
            var a = this._getMapGlobalPixelCenter(),
              n = [t[0] - a[0], t[1] - a[1]],
              r = this._getMapBoundsIntersection(i, n);
            n = [t[0] - r.point[0], t[1] - r.point[1]];
            var l = Math.min(10 + s.length(n), this._activeMargin) / 10;
            this._currentVector = s.scale(s.normalize(n), l), this._deltaCallback = this._inDeltaCallback, this._process || this._startProcess()
          }
        },
        stop: function() {
          this._process && this._finishProcess()
        },
        destroy: function() {
          this.stop(), this._map = null, this._onTickCallback = null, this._onTickCallbackThisArg = null
        },
        _startProcess: function() {
          a.capture(this._map, this, 0), a.events.add("end", this._stopProcess, this), this._startTime = +new Date, this._process = new n(this._tick, this), this._process.start()
        },
        _finishProcess: function() {
          this._deltaCallback != this._outDeltaCallback && (this._startTime = +new Date, this._deltaCallback = this._outDeltaCallback)
        },
        _stopProcess: function() {
          this._process && (this._process.stop(), this._process = null), a.events.remove("end", this._stopProcess, this), a.release({
            behavior: this
          })
        },
        _tick: function() {
          var t = r("ease-out").getValue(Math.min((+new Date - this._startTime) / this._inertiaTimeout, 1)),
            i = this._deltaCallback(t);
          i ? (this._onTickCallback && this._onTickCallback.call(this._onTickCallbackThisArg, i), a.tick({
            pixelOffset: s.scale(i, -1),
            duration: 0
          }, {
            behavior: this
          }), this._process.start()) : this._stopProcess()
        },
        _inDeltaCallback: function(t) {
          return s.scale(this._currentVector, t)
        },
        _outDeltaCallback: function(t) {
          if (t < 1) return s.sub(this._currentVector, s.scale(this._currentVector, t))
        },
        _getMapGlobalPixelBounds: function() {
          var t = this._getMapGlobalPixelCenter(),
            i = this._map.container.getSize(),
            e = this._activePadding,
            s = this._useMapMargin ? this._map.margin.getMargin() : [0, 0, 0, 0],
            a = [(i[0] - (s[3] + s[1])) / 2, (i[1] - (s[0] + s[2])) / 2];
          return [
            [t[0] - a[0] + e, t[1] - a[1] + e],
            [t[0] + a[0] - e, t[1] + a[1] - e]
          ]
        },
        _getMapBoundsIntersection: function(t, i) {
          for (var a, n = e.getCenter(t), r = [n, s.add(n, i)], l = [t[0],
              [t[1][0], t[0][1]], t[1],
              [t[0][0], t[1][1]]
            ], o = 0, c = l.length; o < c; o++) {
            var h = [l[o], l[o + 1] || l[0]];
            if (a = s.intersectionPoint(h[0], h[1], r[0], r[1])) break
          }
          return a
        },
        _getMapGlobalPixelCenter: function() {
          var t = this._map.action.getCurrentState().globalPixelCenter.slice();
          if (this._useMapMargin) {
            var i = this._map.margin.getMargin();
            t[0] += (i[3] - i[1]) / 2, t[1] += (i[0] - i[2]) / 2
          }
          return t
        }
      });
      t(l)
    });
  }],
  ['9L', function(ym) {
    ym.modules.define("component.event.Cacher", [], function(e) {
      function t(e, t, n) {
        this._cache = t, this._overrideStorage = n, this._event = e, this._cacheManager = null
      }

      function n(e) {
        return {
          set: function(t, n) {
            e[t] = n
          }
        }
      }
      var i = {};
      t.prototype = {
        get: function(e) {
          var t = this._cache,
            r = t[e];
          if ("undefined" == typeof r) {
            var a = this._overrideStorage.get(e),
              c = this._event;
            if (a && !this._cacheManager && (this._cacheManager = n(t)), r = a ? a(c, this._cacheManager) : c.originalEvent[e], "undefined" == typeof r) return void(t[e] = i);
            t[e] = r
          }
          return r == i ? void 0 : r
        }
      }, e(t)
    });
  }],
  ['2l', function(ym) {
    ym.modules.define("component.EventFreezer", ["util.defineClass"], function(e, t) {
      function n(e, t) {
        this._frozen = !1, this._changed = !1, this._eventCallback = e, this._context = t, this._eventData = null
      }
      t(n, {
        freeze: function() {
          this._frozen = !0
        },
        unfreeze: function() {
          this._frozen = !1, this._changed && (this._changed = !1, this._fire())
        },
        isFrozen: function() {
          return this._frozen
        },
        fire: function(e, t, n) {
          if ("undefined" != typeof e) {
            this._eventData = this._eventData || {};
            var i = "old" + e;
            "undefined" == typeof this._eventData[i] && (this._eventData[i] = t), this._eventData["new" + e] = n
          }
          this._frozen ? this._changed = !0 : this._fire()
        },
        _fire: function() {
          if (this._eventCallback) {
            var e = this._eventData;
            this._eventData = null, this._eventCallback.call(this._context, e)
          }
        }
      }), e(n)
    });
  }],
  ['9N', function(ym) {
    ym.modules.define("component.parent.BaseParent", ["util.defineClass"], function(t, e) {
      function n(t, e) {
        this._context = t, this._childParentChangeCallback = e
      }
      e(n, {
        addChild: function(t) {
          t.getParent() != this._context && (t.events.add("parentchange", this._onChildParentChange, this), t.setParent(this._context))
        },
        removeChild: function(t) {
          t.getParent() == this._context && t.setParent(null)
        },
        _onChildParentChange: function(t) {
          var e = t.get("target"),
            n = t.get("oldParent");
          this._context == n && e.events.remove("parentchange", this._onChildParentChange, this);
          var a = this._childParentChangeCallback;
          a && a.callback.call(a.context, e, n, t.get("newParent"))
        }
      }), t(n)
    });
  }],
  ['2o', function(ym) {
    ym.modules.define("component.ProviderObserver", ["util.defineClass", "util.array", "util.id", "vow"], function(e, t, r, s, i) {
      var n = function(e) {
        this._providers = [], this._stricts = [], this._requests = {}, this._parameters = e
      };
      t(n, {
        destroy: function() {
          this._providers = [];
          for (var e in this._requests)
            if (this._requests.hasOwnProperty(e)) {
              var t = this._requests[e];
              t.deferred.reject("noProvider"), window.clearTimeout(t.timeout)
            }
        },
        addProvider: function(e, t) {
          return r.indexOf(this._providers, e) == -1 && (this._providers.push(e), this._stricts.push(t), this._parameters.changeCallback && (this._parameters.changeEventType && e.events.add(this._parameters.changeEventType, this._parameters.changeCallback, this), this._parameters.changeCallback())), this
        },
        removeProvider: function(e) {
          var t = r.indexOf(this._providers, e);
          return t != -1 && (this._providers.splice(t, 1), this._stricts.splice(t, 1), this._parameters.changeCallback && (this._parameters.changeEventType && e.events.remove(this._parameters.changeEventType, this._parameters.changeCallback, this), this._parameters.changeCallback())), this
        },
        get: function(e) {
          var t = i.defer(),
            r = {
              resolved: [],
              rejected: [],
              stricts: [],
              timeoutExceeded: 0
            },
            n = this._requests,
            a = [],
            o = this._providers.slice(),
            h = o.length,
            d = this._stricts;
          if (h) {
            for (var c = {
                deferred: t,
                result: r,
                pending: h,
                answers: []
              }, u = function(e) {
                return function(t) {
                  a[e].ready = !0, a[e].result = t, --c.pending || l()
                }
              }, p = function(e) {
                return function(t) {
                  a[e].ready = !0, a[e].result = t, a[e].rejected = !0, --c.pending || l()
                }
              }, l = function() {
                window.clearTimeout(c.timeout), delete n[s.get(c)];
                for (var e = 0; e < h; e++) a[e].ready && (a[e].rejected ? r.rejected.push(a[e].result) : (r.resolved.push(a[e].result), r.stricts.push(d[e])));
                t.resolve(r)
              }, v = 0; v < h; v++) a[v] = {}, this._parameters.makeRequest(this._providers[v], e).then(u(v), p(v));
            c.pending && (n[s.get(c)] = c, c.timeout = window.setTimeout(function() {
              r.timeoutExceeded = c.pending, l()
            }, this._parameters.requestTimeout || 3e4))
          } else t.reject("noProvider");
          return t.promise()
        }
      }), e(n)
    });
  }],
  ['),', function(ym) {
    ym.modules.define("component.sharedEntity.captor.Balloon", ["util.defineClass", "component.sharedEntity.captor.Popup", "vow"], function(t, o, n, e) {
      function a(t, o, n, e) {
        a.superclass.constructor.call(this, t, o, n, e)
      }
      o(a, n, {
        getBalloon: function() {
          return this.getPopup()
        },
        autoPan: function() {
          var t = this.getBalloon();
          return t ? t.autoPan() : e.reject("Balloon is not captured.")
        }
      }), t(a)
    });
  }],
  ['):', function(ym) {
    ym.modules.define("component.sharedEntity.captor.Popup", ["util.defineClass", "event.Manager", "event.Mapper", "Event", "sharedEntity.CaptorAccessor", "option.Manager", "projection.idle", "vow", "util.cancelableCallback", "util.extend", "error"], function(t, e, n, s, i, p, r, o, a, u, h, c) {
      function _(t, e, s, i) {
        this._manager = t, this._popupOwner = e, this._optionManagerName = s, this._sharingManager = i, this.events = new n({
          context: this
        }), this._popup = null, this._accessor = null, this._setupAccessor(), this._setupEventMapper()
      }
      e(_, {
        destroy: function() {
          this._sharingManager && this._sharingManager.getOwner() == this._popupOwner && this._sharingManager.capture(null), this._clearEventMapper(), this._accessor = null
        },
        setSharingManager: function(t) {
          this._sharingManager = t
        },
        open: function(t, e, n) {
          this._cancelCaptureRequest();
          var s = a.defer();
          if (this._popup) s.resolve(this._openCaptured(t, e, n));
          else {
            if (this._openDeferred = s, this._captureCallback = u.create(function(i) {
                this._openDeferred = this._captureCallback = null, this._onCapture(i);
                var p = i.isOpen(),
                  r = this._openCaptured(t, e, n);
                p && r.then(this._fireOpen, this), s.resolve(r)
              }, this), ym.env.debug && (!this._sharingManager || "function" != typeof this._sharingManager.capture)) throw new Error("component.sharedEntity.captor.Popup.open: Не найден менеджер разделяемого инфо-объекта.");
            this._sharingManager.capture(this._accessor).then(this._captureCallback)
          }
          return s.promise()
        },
        close: function(t) {
          return this._popup ? this._popup.close(t) : (this._cancelCaptureRequest(), a.resolve())
        },
        isOpen: function() {
          return this._popup && this._popup.isOpen()
        },
        setPosition: function(t) {
          return this._position = t, this._popup ? a.resolve(this._popup.setPosition(this._position)) : a.reject(c.create("StateError", "Popup is not captured at the moment"))
        },
        setData: function(t) {
          return this._data = t, this._popup ? a.resolve(this._popup.setData(this._data)) : a.reject(c.create("StateError", "Popup is not captured at the moment"))
        },
        setOptions: function(t) {
          return this._options = this._specifyOptions(t || {}), this._popup.options.setParent(this._options), a.resolve()
        },
        getPosition: function() {
          return this._position || null
        },
        getData: function() {
          return this._data || null
        },
        getOptions: function() {
          return this._options || null
        },
        getPopup: function() {
          return this._popup || null
        },
        getOwner: function() {
          return this._popupOwner
        },
        getOverlay: function() {
          return this._popup ? this._popup.getOverlay() : a.reject(c.create("StateError", "Popup is not captured at the moment"))
        },
        getOverlaySync: function() {
          return this._popup ? this._popup.getOverlaySync() : null
        },
        setMasterAccessor: function(t) {
          this._accessor.setMaster(t)
        },
        _setupAccessor: function() {
          var t = function() {
              return this._sharingManager.capture(null)
            },
            e = function(t) {
              return t ? a.resolve() : this.close(!0)
            };
          this._accessor = new p(this._popupOwner, {
            capture: e,
            open: t,
            close: t
          }, this._onRelease, this)
        },
        _setupEventMapper: function() {
          var t = this._popupOwner;
          this.events.setParent(new s(this._manager.events, {
            "*": function(e) {
              return new i({
                type: e.get("type"),
                target: t
              })
            }
          }))
        },
        _clearEventMapper: function() {
          this.events.setParent(null)
        },
        _onCapture: function(t) {
          this._popup = t, t.events.setParent(this.events), this.events.fire("capture")
        },
        _onRelease: function() {
          this._popup ? (this.isOpen() && this._fireClose(), this._popup.events.setParent(null), this._popup = null, this.events.fire("release")) : this._cancelCaptureRequest()
        },
        _cancelCaptureRequest: function() {
          this._captureCallback && (this._captureCallback.cancel(), this._captureCallback = null), this._openDeferred && (this._openDeferred.reject(c.create("OperationCanceledReject", "Capturing/opening was canceled")), this._openDeferred = null)
        },
        _openCaptured: function(t, e, n) {
          if (this._position = t, this._data = e, this._options = this._specifyOptions(n), this.isOpen()) {
            var s = this._popup.getOverlaySync(),
              i = s.getMap();
            return s.setMap(null), this._popup.options.setParent(this._options), this._popup.setData(e), this._popup.setPosition(t), s.setMap(i), this._popup.open()
          }
          return this._popup.options.setParent(this._options), this._popup.open(t, e)
        },
        _specifyOptions: function(t) {
          var e = {
            projection: o
          };
          return t && "function" == typeof t.get || (t = new r(t ? h(e, t) : e, this._popupOwner.options, this._optionManagerName)), t
        },
        _fireOpen: function() {
          this.events.fire("open")
        },
        _fireClose: function() {
          this.events.fire("close")
        }
      }), t(_)
    });
  }],
  [');', function(ym) {
    ym.modules.define("component.sharedEntity.manager.Base", ["util.defineClass", "Event", "event.Manager", "event.Mapper", "vow", "util.bind"], function(t, e, r, s, n, i, o) {
      function c(t, e, r, n) {
        this._manager = t, this._sharedEntity = e, this._rootOwner = r, this._proxyClass = n, this.events = new s({
          context: this
        }), this._setupEventMapping()
      }
      e(c, {
        perform: function(t, e, r, s, n, c) {
          r = r || this, s = s || o(function(e) {
            return this._sharedEntity[t].apply(this._sharedEntity, e)
          }, this), n = n || function(t) {
            return t
          }, c = c || s;
          var h;
          if (this._captorAccessor) {
            var a = this._captorAccessor.access(t, e);
            h = i.isPromise(a) ? a.then(function(t) {
              return s.call(r, t && t.length ? t : e)
            }, n, null, r) : a !== !1 ? s.call(r, a && a.length ? a : e) : n.call(r)
          } else h = c.call(r, e);
          return h
        },
        capture: function(t) {
          return this._captorAccessor == t ? i.resolve(this._proxy) : this.perform("capture", [t], this, function(t) {
            return this._clearCaptor(), i.resolve(this._setupCaptor(t[0]))
          }, function(t) {
            return i.reject(t)
          })
        },
        getOwner: function() {
          return this._captorAccessor ? this._captorAccessor.getOwner() : this._rootOwner
        },
        getEntity: function() {
          return this._sharedEntity
        },
        getProxy: function() {
          return this._proxy
        },
        _setupEventMapping: function() {
          this._sharedEntity.events.setParent(new n(this._manager.events, {
            "*": o(function(t) {
              return this._proxy && this._proxy.events.fire(t.get("type")), new r({
                type: t.get("type"),
                target: this.getOwner()
              })
            }, this)
          }))
        },
        _setupCaptor: function(t) {
          return this._captorAccessor = t, t ? (this.events.fire("capture"), this._proxy = new this._proxyClass(this._sharedEntity), this._proxy) : null
        },
        _clearCaptor: function() {
          this._captorAccessor && (this._captorAccessor.drop(), this._captorAccessor = null, this._proxy.destroy(), this._proxy = null, this.events.fire("release"))
        }
      }), t(c)
    });
  }],
  [')@', function(ym) {
    ym.modules.define("component.sharedEntity.manager.Popup", ["util.defineClass", "sharedEntity.proxy.Popup", "component.sharedEntity.manager.Base"], function(t, e, n, o) {
      function s(t, e, o, r) {
        s.superclass.constructor.call(this, t, e, o, r || n)
      }
      for (var r = ["open", "close", "setPosition", "isOpen", "getOverlay", "getOverlaySync", "getPosition", "setData", "getData", "setOptions", "getOptions"], a = {}, i = 0, p = r.length; i < p; i++) a[r[i]] = function(t) {
        return function() {
          return this.perform(t, Array.prototype.slice.call(arguments))
        }
      }(r[i]);
      e(s, o, a), t(s)
    });
  }],
  ['9O', function(ym) {
    ym.modules.define("component.TileBoundsGetter", ["util.defineClass", "event.Manager", "component.tileBoundsGetter.util"], function(t, e, i, o) {
      var s = function(t, e) {
        this._params = e || {}, this.options = t, this.events = new i({
          context: this
        }), this._tileBounds = null, this._mapListener = null
      };
      e(s, {
        update: function() {
          this._applyWorldSize(this._map), this._tileBounds = null
        },
        setMap: function(t) {
          t != this._map && (this._map && this._removeFromMap(this._map), this._map = t, t && this._addToMap(t))
        },
        get: function() {
          return !this._tileBounds && this._map && (this._tileBounds = this._calculateTileBounds()), this._tileBounds
        },
        fireChangeEvent: function(t, e, i, o) {
          this.events.fire("tileboundschange", {
            oldTileBounds: t,
            newTileBounds: e,
            oldZoom: i,
            newZoom: o
          })
        },
        _addToMap: function(t) {
          this._map = t, this._createMapListener(), this._applyWorldSize(t), this._tileBounds = this._calculateTileBounds()
        },
        _removeFromMap: function(t) {
          this._tileBounds = null, this._removeMapListener(), this._worldSize = null, this._map = null
        },
        _createMapListener: function() {
          this._mapListener = this._map.events.group().add("boundschange", function(t) {
            var e = t.get("oldZoom"),
              i = t.get("newZoom");
            if (i == e) this._onMapMove(t);
            else {
              if (this._params.wholeZoom && this._processZoom(i) == this._processZoom(e)) return;
              this._onMapZoomChange(t)
            }
          }, this)
        },
        _removeMapListener: function() {
          this._mapListener.removeAll()
        },
        _onMapMove: function(t) {
          var e = this._calculateTileBounds();
          if (!o.equals(e, this._tileBounds)) {
            var i = this._tileBounds;
            this._tileBounds = e, this.fireChangeEvent(i, e, t.get("oldZoom"), t.get("newZoom"))
          }
        },
        _onMapZoomChange: function(t) {
          this._applyWorldSize(this._map);
          var e = this._tileBounds;
          this._tileBounds = this._calculateTileBounds(), this.fireChangeEvent(e, this._tileBounds, t.get("oldZoom"), t.get("newZoom"))
        },
        _calculateTileBounds: function() {
          var t = this._getMapGlobalPixelBounds(),
            e = this._expandGlobalPixelBounds(t),
            i = this._fitToZeroWorld(e);
          return this._fromPixelBoundsToTiles(i)
        },
        _getMapGlobalPixelBounds: function() {
          var t = this._map,
            e = t.options.get("projection").toGlobalPixels(t.getCenter(), this._processZoom(t.getZoom())),
            i = t.container.getSize(),
            o = this.options.get("viewportMargin", 128),
            s = [.5 * i[0] + o, .5 * i[1] + o],
            n = [
              [e[0] - s[0], e[1] - s[1]],
              [e[0] + s[0], e[1] + s[1]]
            ];
          return n
        },
        _expandGlobalPixelBounds: function(t) {
          return [
            [256 * Math.floor(t[0][0] / 256), 256 * Math.floor(t[0][1] / 256)],
            [256 * Math.ceil(t[1][0] / 256), 256 * Math.ceil(t[1][1] / 256)]
          ]
        },
        _fitToZeroWorld: function(t) {
          var e = this._fitToZeroWorldAxis([t], 0);
          return this._fitToZeroWorldAxis(e, 1)
        },
        _fitToZeroWorldAxis: function(t, e) {
          var i = t[0];
          if (i[1][e] - i[0][e] >= this._worldSize) {
            for (var o = 0, s = t.length; o < s; o++) t[o][0][e] = 0, t[o][1][e] = this._worldSize;
            return t
          }
          if (i[0][e] >= 0 && i[1][e] <= this._worldSize) return t;
          var n, l = this._map.options.get("projection").isCycled();
          if (i[0][e] < 0) {
            if (l[e]) {
              var r = [0, i[1][e], i[0][e] + this._worldSize, this._worldSize];
              n = this._splitBoundsArray(t, e, r)
            } else {
              for (var o = 0, s = t.length; o < s; o++) t[o][0][e] = 0;
              n = t
            }
            return n
          }
          if (l[e]) {
            var r = [i[0][e], this._worldSize, 0, i[1][e] - this._worldSize];
            n = this._splitBoundsArray(t, e, r)
          } else {
            for (var o = 0, s = t.length; o < s; o++) t[o][1][e] = this._worldSize;
            n = t
          }
          return n
        },
        _splitBoundsArray: function(t, e, i) {
          for (var o = [], s = 0, n = t.length; s < n; s++) {
            var l = t[s][0].slice(),
              r = t[s][1].slice();
            l[e] = i[0], r[e] = i[1], o.push([l, r]), l = t[s][0].slice(), r = t[s][1].slice(), l[e] = i[2], r[e] = i[3], o.push([l, r])
          }
          return o
        },
        _fromPixelBoundsToTiles: function(t) {
          for (var e = [], i = 0, o = t.length; i < o; i++) {
            var s = t[i];
            e.push([
              [Math.floor(s[0][0] / 256), Math.floor(s[0][1] / 256)],
              [Math.ceil(s[1][0] / 256), Math.ceil(s[1][1] / 256)]
            ])
          }
          return e
        },
        _applyWorldSize: function(t) {
          this._worldSize = 256 * Math.pow(2, this._processZoom(t.getZoom()))
        },
        _processZoom: function(t) {
          return this._params.wholeZoom ? Math.round(t) : t
        }
      }), t(s)
    });
  }],
  ['9P', function(ym) {
    ym.modules.define("component.tileBoundsGetter.util", ["util.pixelBounds", "util.math.areEqual"], function(n, t, o) {
      n({
        containsBounds: function(n, o) {
          for (var e = 0, u = n.length; e < u; e++)
            if (t.containsBounds(n[e], o)) return !0;
          return !1
        },
        getDisjointArea: function(n, o) {
          var e, u, r = {
              added: [],
              removed: []
            },
            s = [],
            i = [];
          for (e = 0, u = n.length; e < u; e++) this._pushBoundsCoords(s, i, n[e]);
          for (e = 0, u = o.length; e < u; e++) this._pushBoundsCoords(s, i, o[e]);
          for (s = this._getUniqueSorted(s), i = this._getUniqueSorted(i), e = 0, u = s.length - 1; e < u; e++)
            for (var h = 0, d = i.length - 1; h < d; h++) {
              var a = t.fromPoints([
                  [s[e], i[h]],
                  [s[e + 1], i[h + 1]]
                ]),
                f = this.containsBounds(n, a),
                l = this.containsBounds(o, a);
              f && !l ? r.added.push(a) : !f && l && r.removed.push(a)
            }
          return r
        },
        _getUniqueSorted: function(n) {
          var t = [];
          n.sort(function(n, t) {
            return n - t
          });
          for (var o = 0, e = n.length; o < e; o++) n[o] != n[o + 1] && t.push(n[o]);
          return t
        },
        equals: function(n, t) {
          var e = !1;
          if (n.length == t.length) {
            e = !0;
            for (var u = 0, r = n.length; u < r && e; u++) o(n[u][0], t[u][0]) && o(n[u][1], t[u][1]) || (e = !1)
          }
          return e
        },
        _pushBoundsCoords: function(n, t, o) {
          n.push(o[0][0]), t.push(o[0][1]), n.push(o[1][0]), t.push(o[1][1])
        }
      })
    });
  }],
  ['2r', function(ym) {
    ym.modules.define("component.ZoomRangeObserver", ["util.defineClass", "component.ProviderObserver", "vow"], function(e, r, n, t) {
      var o = function(e) {
        o.superclass.constructor.call(this, {
          changeEventType: "zoomrangechange",
          changeCallback: e,
          makeRequest: function(e, r) {
            return e.getZoomRange(r)
          }
        })
      };
      r(o, n, {
        get: function(e) {
          var r, n, a = t.defer();
          return o.superclass.get.call(this, e).then(function(e) {
            if (e.resolved.length) {
              var t = e.resolved[0].slice();
              for (r = 1, n = e.resolved.length; r < n; r++) {
                var o = e.stricts[r];
                t = [(o ? Math.max : Math.min)(t[0], e.resolved[r][0]), (o ? Math.min : Math.max)(t[1], e.resolved[r][1])]
              }
              a.resolve(t)
            } else {
              var s = !0;
              for (r = 0, n = e.rejected.length; r < n; r++)
                if ("noProvider" != e.rejected[r]) {
                  s = !1;
                  break
                }
              s ? a.reject("noProvider") : a.reject("noData")
            }
          }, function(e) {
            a.reject(e)
          }), a.promise()
        }
      }), e(o)
    });
  }],
  ['2O', function(ym) {
    ym.modules.define("constants.editorZIndex", ["constants.zIndex"], function(e, r) {
      e({
        edgeMarker: 100,
        edgeMarkerHover: 101,
        vertexMarker: 200,
        vertexMarkerHover: 201,
        edgeMarkerDrag: 210,
        vertexMarkerDrag: 210,
        vertexMenu: 300,
        guideLines: 400,
        frameEditor: r.drag
      })
    });
  }],
  ['2R', function(ym) {
    ym.modules.define("constants.hotspotEvents", [], function(e) {
      e({
        types: {
          mouseenter: !0,
          mousemove: !0,
          mouseleave: !0,
          mousedown: !0,
          mouseup: !0,
          click: !0,
          contextmenu: !0,
          dblclick: !0,
          wheel: !0,
          multitouchstart: !0,
          multitouchmove: !0,
          multitouchend: !0
        },
        order: ["mousedown", "mousemove", "multitouchstart", "multitouchmove", "multitouchend", "mouseup", "wheel", "click", "contextmenu", "dblclick"]
      })
    });
  }],
  ['2X', function(ym) {
    ym.modules.define("constants.mapDomEvents", [], function(e) {
      e(["click", "dblclick", "contextmenu", "mousedown", "mouseup", "mousemove", "mouseenter", "mouseleave", "wheel", "multitouchstart", "multitouchmove", "multitouchend"])
    });
  }],
  ['20', function(ym) {
    ym.modules.define("constants.mapListenerPriority", [], function(e) {
      e({
        blocker: 1300,
        routeEditor: 1e3,
        behaviors: 800
      })
    });
  }],
  ['23', function(ym) {
    ym.modules.define("constants.paneZIndex", [], function(e) {
      e({
        ground: 100,
        areas: 200,
        routerRoutes: 250,
        shadows: 300,
        places: 400,
        editor: 450,
        events: 500,
        behaviors: 550,
        overlaps: 600,
        editorGlass: 660,
        routerEditorGlass: 660,
        routerPoints: 670,
        balloon: 700,
        outerBalloon: 800,
        controls: 900,
        copyrights: 1e3,
        editorMenu: 1050,
        editorActiveVertex: 1055,
        hint: 1100,
        outerHint: 1200,
        search: 1300
      })
    });
  }],
  ['26', function(ym) {
    ym.modules.define("constants.zIndex", [], function(e) {
      e({
        layer: 200,
        mapTypeLayer: 150,
        overlay: 650,
        icon: 675,
        hover: 700,
        drag: 725,
        behavior: 750,
        active: 755,
        routeViaPointHover: 757,
        balloon: 760,
        activePoint: 775,
        hint: 1100
      })
    });
  }],
  ['5*', function(ym) {
    ym.modules.define('control-manager', ['system.provideCss'], function(provide, provideCss) {
      provideCss(".ymaps-2-1-42-controls__bottom,.ymaps-2-1-42-controls__toolbar{position:absolute;width:100%}.ymaps-2-1-42-controls__toolbar_left{float:left;height:0}.ymaps-2-1-42-controls__toolbar_right{float:right;height:0}.ymaps-2-1-42-controls__control_toolbar{display:inline-block;vertical-align:top}.ymaps-2-1-42-controls__control{display:block;position:absolute;vertical-align:top}.ymaps-2-1-42-controls__control_visibility_hidden{display:none}", provide);
    });
  }],
  ['98', function(ym) {
    ym.modules.define("control.Base", ["util.defineClass", "collection.Item", "data.Manager", "layout.storage", "control.optionMapper", "vow", "util.dom.className", "Monitor", "util.cancelableCallback", "control.component.EventProxy", "util.css", "theme.islands.control.meta"], function(t, e, o, i, a, n, s, l, r, u, h, c) {
      var y = function(t) {
        t = t || {}, this.state = new i(t.state), this.data = new i(t.data), y.superclass.constructor.call(this, t.options), this.eventProxy = new h(this.events), this.options.setMapper(n), this._layout = null, this._layoutDeferred = null
      };
      y.ControlWithoutMapError = function() {
        return new Error("Control wasn't added to map")
      }, y.ControlCanceledError = function() {
        return new Error("Canceled")
      }, y.LayoutNotFound = function() {
        return new Error("Layout wasn't found")
      }, e(y, o, {
        getLayout: function() {
          return this._layoutDeferred ? this._layoutDeferred.promise() : s.reject(y.ControlWithoutMapError())
        },
        getLayoutSync: function() {
          return this._layout
        },
        onAddToMap: function() {
          this._setupLayout(), this._visibilityMonitor = new r(this.options), this._visibilityMonitor.add("visible", this._onVisibilityChange, this)
        },
        onRemoveFromMap: function(t) {
          this._destroyLayout(), this._visibilityMonitor.destroy()
        },
        _setupLayout: function() {
          this._layoutCancelableCallback = u.create(function(t) {
            this._createLayout(t[0], t[1] && t[1][0] || i)
          }, this);
          var t, e, o = [this.getParent().getChildElement(this)],
            i = this.options.get("layout");
          this._layoutDeferred = s.defer(), "string" == typeof i && (e = i, t = {
            control: this,
            options: this.options,
            data: this.data,
            state: this.state
          }, i = a.get(e, t), "undefined" == typeof i && o.push(a.require({
            keys: [e],
            data: t
          }))), s.all(o).then(this._layoutCancelableCallback, function() {
            this._layoutCancelableCallback = null, this._layoutDeferred.reject(y.LayoutNotFound())
          }, this)
        },
        _destroyLayout: function() {
          this._layoutCancelableCallback ? (this._layoutDeferred.reject(y.ControlCanceledError()), this._layoutCancelableCallback.cancel(), this._layoutCancelableCallback = null) : this._layout && (this.eventProxy.removeChildEventManager(this._layout.events), this._layout.destroy(), this._layout = null, this._fireLayoutChangeEvent()), this._layoutDeferred = null
        },
        _createLayout: function(t, e) {
          this._layoutCancelableCallback = null, this._layout = new e({
            control: this,
            options: this.options,
            data: this.data,
            state: this.state
          }), this.eventProxy.addChildEventManager(this._layout.events), this._layout.setParentElement(t), this.events.fire("layoutmapchange"), this._setVisibleState(this.options.get("visible", !0)), this._layoutDeferred.resolve(this._layout), this._fireLayoutChangeEvent()
        },
        _onVisibilityChange: function(t, e) {
          this._layout && this._setVisibleState(t), this.events.fire("visibilitychange")
        },
        _setVisibleState: function(t) {
          var e = this._layout.getParentElement();
          e && (t ? l.remove(e, c.addPrefix("controls__control_visibility_hidden")) : l.add(e, c.addPrefix("controls__control_visibility_hidden")))
        },
        _fireLayoutChangeEvent: function() {
          this.events.fire("layoutchange", {
            layout: this._layout
          })
        }
      }), t(y)
    });
  }],
  ['96', function(ym) {
    ym.modules.define("control.BaseBehaviorButton", ["util.defineClass", "control.Button", "control.optionMapper"], function(e, t, s, a) {
      var i = function(e) {
        i.superclass.constructor.call(this, e), this.options.setName("behaviorButton")
      };
      t(i, s, {
        getBehaviorName: function() {
          return ""
        },
        select: function() {
          i.superclass.select.call(this);
          var e = this.getMap();
          if (e) {
            var t = this.getBehaviorName();
            e.behaviors.isEnabled(t) || e.behaviors.enable(t)
          }
        },
        deselect: function() {
          i.superclass.deselect.call(this);
          var e = this.getMap();
          if (e) {
            var t = this.getBehaviorName();
            e.behaviors.isEnabled(t) && e.behaviors.disable(t)
          }
        },
        onAddToMap: function(e) {
          i.superclass.onAddToMap.call(this, e), this._createMapListeners(e)
        },
        onRemoveFromMap: function(e) {
          this._clearMapListeners(), i.superclass.onRemoveFromMap.call(this, e)
        },
        _createMapListeners: function(e) {
          var t = this.getBehaviorName(),
            s = e.behaviors.get(t);
          this._behaviorListeners = s.events.group().add("enable", function() {
            this.select()
          }, this).add("disable", function() {
            this.deselect()
          }, this), e.behaviors.isEnabled(t) && this.select()
        },
        _clearMapListeners: function() {
          this._behaviorListeners.removeAll()
        }
      }), a.setRule({
        name: "behaviorButton",
        rule: "prefixed"
      }), a.setRule({
        name: "behaviorButton",
        key: ["adjustMapMargin"],
        rule: ["prefixed", "plain"]
      }), e(i)
    });
  }],
  ['99', function(ym) {
    ym.modules.define("control.BaseGroup", ["util.defineClass", "util.array", "control.storage", "component.array.ParentArray", "control.childElementController.GroupController", "control.Base", "Event", "event.Mapper", "control.EventMappingTable", "util.bind", "util.id", "util.cancelableCallback", "util.extend"], function(t, e, n, i, o, l, r, a, s, c, h, d, u, m) {
      function C(t, e) {
        return t.options.get("positionIndex", 0) - e.options.get("positionIndex", 0)
      }
      var p = function(t) {
        var e;
        if (n.isArray(t) && (e = t, t = {}), t && t.items && (t = m({}, t), e = t.items, delete t.items), p.superclass.constructor.call(this, t), this._childElementController = new l(this), this._collectionImplementation = new o([], this, {
            onAdd: {
              callback: this.onChildAdd,
              context: this
            },
            onRemove: {
              callback: this.onChildRemove,
              context: this
            }
          }, new s(this.events, new c(this))), this._topContainer = null, this._setupGroupLayoutEventRules(), e)
          for (var i = 0, r = e.length; i < r; ++i) this.add(e[i])
      };
      e(p, r, {
        add: function(t) {
          return this._childElementController.insert(t), this._collectionImplementation.add(t), this
        },
        remove: function(t) {
          return this._collectionImplementation.remove(t), this
        },
        removeAll: function() {
          return this._collectionImplementation.removeAll(), this
        },
        getIterator: function() {
          return this._collectionImplementation.getIterator()
        },
        each: function(t, e) {
          return this._collectionImplementation.each(t, e), this
        },
        getLength: function() {
          return this._collectionImplementation.getLength()
        },
        filter: function(t) {
          for (var e, n = this.getIterator(), i = [];
            (e = n.getNext()) != n.STOP_ITERATION;) t(e) && i.push(e);
          return i
        },
        get: function(t) {
          return "string" == typeof t ? this._controlsByKey[t] : this._collectionImplementation.get(t)
        },
        getAll: function() {
          for (var t, e = this.getIterator(), n = [];
            (t = e.getNext()) != e.STOP_ITERATION;) n.push(t);
          return n
        },
        indexOf: function(t) {
          return this._collectionImplementation.indexOf(t)
        },
        onChildAdd: function(t, e) {
          this._collectionImplementation.quickSort(C), this.events.fire("add", {
            child: e
          }), e.events.add("update", this._onChildUpdate, this)
        },
        onChildRemove: function(t, e) {
          this._childElementController.remove(e), this.events.fire("remove", {
            child: e
          }), e.events.remove("update", this._onChildUpdate, this)
        },
        getContainer: function() {
          return this._topContainer
        },
        getChildElement: function(t) {
          return this._childElementController.getElement(t)
        },
        onAddToMap: function(t) {
          p.superclass.onAddToMap.call(this, t), this._cancelableCallback = u.create(function(t) {
            this._cancelableCallback = null, this._setChildContainer(t.getChildContainerElement())
          }, this), this.getLayout().then(this._cancelableCallback)
        },
        onRemoveFromMap: function(t) {
          this._cancelableCallback && (this._cancelableCallback.cancel(), this._cancelableCallback = null), p.superclass.onRemoveFromMap.call(this, t)
        },
        _onChildUpdate: function(t) {
          this.events.fire("update", {
            originalEvent: t
          })
        },
        _setupGroupLayoutEventRules: function() {
          this.eventProxy.disableEventFiring("childcontainerchange").setCallback("childcontainerchange", this._onChildContainerSet, this)
        },
        _onChildContainerSet: function(t) {
          this._setChildContainer(t.get("newChildContainerElement"))
        },
        _setChildContainer: function(t) {
          if (this._topContainer != t) {
            var e = this._topContainer;
            this._topContainer = t, this._setChildElementsParent(t), this.events.fire("childcontainerchange", new a({
              newChildContainerElement: this._topContainer,
              oldChildContainerElement: e
            }))
          }
        },
        _setChildElementsParent: function(t) {
          this._childElementController.setParentElement(t)
        }
      }), t(p)
    });
  }],
  ['29', function(ym) {
    ym.modules.define("control.Button", ["util.defineClass", "control.Selectable", "control.component.ToolBarButton", "control.optionMapper", "layout.define"], function(t, e, o, n, s, i) {
      var l = function(t) {
        l.superclass.constructor.call(this, "string" == typeof t ? {
          data: {
            content: t
          }
        } : t), this.options.setName("button"), this._setupLayoutEventRules(), this._toolBarButtonComponent = new n(this)
      };
      e(l, o, {
        _setupLayoutEventRules: function() {
          this.eventProxy.setCallback("click", this._onClick, this, !0)
        },
        _onClick: function(t) {
          this.isEnabled() && (this.events.fire("press"), this.options.get("selectOnClick", !0) && (this.isSelected() ? this.deselect() : this.select()))
        }
      }), s.setRule({
        name: "button",
        rule: ["prefixed", "plain"]
      }), i("islands#buttonLayout", "theme.islands.control.layout.Button"), t(l)
    });
  }],
  ['9$', function(ym) {
    ym.modules.define("control.childElementController.Base", ["util.defineClass", "util.dom.element", "util.id", "util.List", "vow"], function(e, t, n, i, r, l) {
      var s = function(e) {
        this._parent = e, this._childElements = {}, this._childList = new r, this._parentElementDeferred = l.defer()
      };
      t(s, {
        setParentElement: function(e) {
          this._parentElement != e && (this._parentElementDeferred.promise().isResolved() && (this._parentElementDeferred = l.defer()), this._setupParentElement(e))
        },
        getParentElement: function() {
          return this._parentElement
        },
        getElement: function(e) {
          var t = l.defer();
          return this._parentElement ? t.resolve(this._getElementSync(e)) : this._parentElementDeferred.promise().then(function() {
            t.resolve(this._getElementSync(e))
          }, this), t.promise()
        },
        getParent: function() {
          return this._parent
        },
        insert: function(e, t) {
          var r = i.get(e);
          this._childElements[r] = t || n.create(), this._childList.insert(e, this._getBeforeChild(e)), this._parentElement && this._appendToParentByOrder(e)
        },
        remove: function(e) {
          var t = i.get(e);
          this._childElements[t] && (this._parentElement && this._removeFromParent(e), this._childList.remove(e), delete this._childElements[t])
        },
        onChildPositionChange: function(e) {
          this._childList.insert(e, this._getBeforeChild(e)), this._removeFromParent(e), this._appendToParentByOrder(e)
        },
        _appendToParentByOrder: function(e) {
          var t = this._getElementSync(e),
            n = this._getBeforeElement(e);
          null == n ? this._parentElement.appendChild(t) : this._parentElement.insertBefore(t, n)
        },
        _removeFromParent: function(e) {
          var t = this._getElementSync(e);
          t.parentNode.removeChild(t)
        },
        _getBeforeChild: function(e) {
          var t = this.getChildIndex(e);
          if (null == t) return null;
          for (var n, i = this._childList.getIterator();
            (n = i.getNext()) != i.STOP_ITERATION;)
            if (n != e && this.comparator(e, n) < 0) return n;
          return null
        },
        _getBeforeElement: function(e) {
          for (var t, n = this._childList.getIterator();
            (t = n.getNext()) != n.STOP_ITERATION;)
            if (t == e) {
              var i = n.getNext();
              return i == n.STOP_ITERATION ? null : this._getElementSync(i)
            }
        },
        _setupParentElement: function(e) {
          var t, n;
          if (e)
            for (t = this._childList.getIterator();
              (n = t.getNext()) != t.STOP_ITERATION;) e.appendChild(this._getElementSync(n));
          else
            for (t = this._childList.getIterator();
              (n = t.getNext()) != t.STOP_ITERATION;) this._removeFromParent(n);
          this._parentElement = e, e && this._parentElementDeferred.resolve(e)
        },
        _getElementSync: function(e) {
          return this._childElements[i.get(e)]
        },
        getChildIndex: function(e) {
          return null
        },
        comparator: function(e, t) {
          return this.getChildIndex(e) < this.getChildIndex(t) ? -1 : this.getChildIndex(e) > this.getChildIndex(t) ? 1 : 0
        }
      }), e(s)
    });
  }],
  ['9_', function(ym) {
    ym.modules.define("control.childElementController.GroupController", ["util.defineClass", "control.childElementController.Base", "util.id", "Monitor", "util.bind"], function(t, i, o, n, s, e) {
      var l = function(t) {
        l.superclass.constructor.call(this, t), this._childPositionMonitors = {}
      };
      i(l, o, {
        setParentElement: function(t) {
          var i = this.getParentElement();
          l.superclass.setParentElement.call(this, t), i && !t && this._clearChildMonitors(), !i && t && this._setupChildMonitors()
        },
        getChildIndex: function(t) {
          return t.options.get("positionIndex", 0)
        },
        insert: function(t) {
          l.superclass.insert.call(this, t), this.getParentElement() && !this._childPositionMonitors[n.get(t)] && this._setupChildMonitor(t)
        },
        remove: function(t) {
          this._childPositionMonitors[n.get(t)] && this._clearChildMonitor(t), l.superclass.remove.call(this, t)
        },
        _setupChildMonitors: function() {
          this.getParent().each(e(function(t) {
            this._setupChildMonitor(t)
          }, this))
        },
        _clearChildMonitors: function() {
          this.getParent().each(e(function(t) {
            this._clearChildMonitor(t)
          }, this))
        },
        _setupChildMonitor: function(t) {
          this._childPositionMonitors[n.get(t)] = new s(t.options).add("positionIndex", function() {
            this.onChildPositionChange(t)
          }, this)
        },
        _clearChildMonitor: function(t) {
          var i = n.get(t);
          this._childPositionMonitors[i].destroy(), delete this._childPositionMonitors[i]
        }
      }), t(l)
    });
  }],
  ['9.', function(ym) {
    ym.modules.define("control.component.CollapseOnBlur", ["Monitor", "domEvent.manager", "util.id", "util.cancelableCallback", "util.dom.style"], function(t, e, n, o, l, i) {
      var s = function(t) {
        this._context = t, this._optionMonitor = null, this._controlElementListener = null, this._documentListener = null, this._cancelableCallback = null, t.events.add("mapchange", this._onMapChange, this)
      };
      s.prototype = {
        _onMapChange: function(t) {
          var n = t.get("newMap");
          n ? (this._optionMonitor = new e(this._context.options).add("collapseOnBlur", this._checkCollapseOnBlur, this), this._checkCollapseOnBlur()) : (this._optionMonitor.removeAll(), this._context.options.get("collapseOnBlur", !0) && this._stopMouseDownListening())
        },
        _checkCollapseOnBlur: function() {
          this._context.options.get("collapseOnBlur", !0) ? this._startMouseDownListening() : this._stopMouseDownListening()
        },
        _startMouseDownListening: function() {
          this._cancelableCallback = l.create(function(t) {
            this._controlElementListener = n.group(t).add("mousedown", function(t) {
              var e = t.get("propagatedData");
              e.targetControlId = o.get(this._context)
            }, this), this._documentListener = n.group(window.document.documentElement).add("mousedown", function(t) {
              var e = t.get("propagatedData");
              e.targetControlId != o.get(this._context) && this._context.collapse()
            }, this)
          }, this), this._context.getParent().getChildElement(this._context).then(this._cancelableCallback)
        },
        _stopMouseDownListening: function() {
          this._cancelableCallback && (this._cancelableCallback.cancel(), this._cancelableCallback = null), this._controlElementListener && (this._controlElementListener.removeAll(), this._documentListener.removeAll())
        }
      }, t(s)
    });
  }],
  ['9*', function(ym) {
    ym.modules.define("control.component.EventProxy", ["util.bind", "util.array", "Event"], function(t, n, e, i) {
      function r(t, n) {
        var e;
        e = t.context ? t.callback.call(t.context, n) : t.callback(n)
      }

      function a(t) {
        return t.isPropagationStopped && t.isPropagationStopped()
      }
      var l = function(t) {
        this._callbacks = {}, this._disabledEvents = {}, this._parentEvents = t, this._controller = {
          onAfterEventFiring: n(this._onAfterLayoutEventFiring, this)
        }
      };
      l.prototype = {
        addChildEventManager: function(t) {
          e.indexOf(t.params.controllers, this._controller) == -1 && t.addController(this._controller)
        },
        removeChildEventManager: function(t) {
          t.removeController(this._controller)
        },
        setCallback: function(t, n, e, i) {
          return this._callbacks[t] = {
            callback: n,
            context: e,
            afterEventFiring: i
          }, this
        },
        unsetCallback: function(t) {
          return delete this._callbacks[t], this
        },
        disableEventFiring: function(t) {
          return this._disabledEvents[t] = !0, this
        },
        enableEventFiring: function(t) {
          return delete this._disabledEvents[t], this
        },
        isEnabled: function(t) {
          return !this._disabledEvents[t]
        },
        getCallback: function(t) {
          return this._callbacks[t]
        },
        _onAfterLayoutEventFiring: function(t, n, e) {
          if (n.indexOf("defaultaction") == -1 && !a(e)) {
            var l = this.getCallback(n);
            if (l && !l.afterEventFiring && r(l, e), this.isEnabled(n)) {
              var o = new i({
                type: n,
                target: this._parentEvents.params.context
              }, e);
              e.isDefaultPrevented() && o.preventDefault(), this._parentEvents.fire(n, o)
            }
            l && l.afterEventFiring && r(l, e)
          }
        }
      }, t(l)
    });
  }],
  ['9:', function(ym) {
    ym.modules.define("control.component.ToolBarButton", ["Monitor", "util.array"], function(t, e, i) {
      function n(t, e) {
        var n = t.options.get("maxWidth") || 90;
        if (i.isArray(n)) {
          var o = i.indexOf(t.getParent().options.get("states"), e);
          return n[o]
        }
        return n
      }
      var o = function(t) {
        this._context = t, t.events.add("parentchange", this._onParentChange, this), t.options.events.add("change", this._checkOptionSize, this), this._parentStateMonitor = null, this._contextOptionsMonitor = null
      };
      o.prototype = {
        _onParentChange: function(t) {
          var i = t.get("newParent");
          i ? (this._optionSize = this._context.options.get("size"), this._applyStateSize(), this._applyStateMaxWidth(), this._parentStateMonitor = new e(i.state).add("size", this._applyStateSize, this), this._contextOptionsMonitor = new e(this._context.options).add("maxWidth", this._applyStateMaxWidth, this)) : (this._parentStateMonitor.destroy(), this._contextOptionsMonitor.destroy())
        },
        _checkOptionSize: function() {
          var t = this._context.options.get("size");
          t != this._optionSize && (this._optionSize = t, this._applyStateSize())
        },
        _applyStateSize: function() {
          var t = this._context.options.get("size", "auto");
          if ("auto" == t) {
            var e = this._context.getParent();
            this._context.state.set("size", e ? e.state.get("size", "large") : "large")
          } else this._context.state.set("size", t)
        },
        _applyStateMaxWidth: function() {
          var t = this._context.state.get("size", "large");
          this._context.state.set("maxWidth", n(this._context, t))
        }
      }, t(o)
    });
  }],
  ['95', function(ym) {
    ym.modules.define("control.EventMappingTable", ["util.defineClass", "MapEvent"], function(t, n, e) {
      function i(t) {
        this._controlManager = t, this.add = !1, this.remove = !1, this.parentchange = !1, this.mapchange = !1, this.optionschange = !1, this.destroy = !1, this["*"] = this._defaultMapping
      }
      n(i, {
        _defaultMapping: function(t) {
          return new e({
            currentTarget: this._controlManager
          }, t)
        }
      }), t(i)
    });
  }],
  ['2-', function(ym) {
    ym.modules.define("control.FullscreenControl", ["util.defineClass", "control.Button", "control.storage", "control.optionMapper", "layout.define", "yandex.counter"], function(e, n, t, l, s, r, o) {
      var c = function(e) {
        c.superclass.constructor.call(this, e), this.options.setName("fullscreenControl")
      };
      n(c, t, {
        onAddToMap: function(e) {
          c.superclass.onAddToMap.call(this, e), this._mapContainerListener = e.container.events.group().add("fullscreenenter", this._onMapFullscreenEnter, this).add("fullscreenexit", this._onMapFullscreenExit, this), o.countByKey("control", "fullscreen.create")
        },
        onRemoveFromMap: function(e) {
          this._mapContainerListener.removeAll(), c.superclass.onRemoveFromMap.call(this, e)
        },
        select: function() {
          this.getMap().container.isFullscreen() ? c.superclass.select.call(this) : this.enterFullscreen()
        },
        deselect: function() {
          this.getMap().container.isFullscreen() ? this.exitFullscreen() : c.superclass.deselect.call(this)
        },
        enterFullscreen: function() {
          this.getMap().container.enterFullscreen()
        },
        exitFullscreen: function() {
          this.getMap().container.exitFullscreen()
        },
        _onMapFullscreenEnter: function() {
          this.state.set("fullscreen", !0), this.events.fire("fullscreenenter"), this.select(), o.countByKey("control", "fullscreen.enter")
        },
        _onMapFullscreenExit: function() {
          this.state.set("fullscreen", !1), this.events.fire("fullscreenexit"), this.deselect()
        }
      }), s.setRule({
        name: "fullscreenControl",
        rule: ["prefixed"]
      }), s.setRule({
        name: "fullscreenControl",
        key: ["adjustMapMargin"],
        rule: ["prefixed", "plain"]
      }), l.add("fullscreenControl", c), r("islands#fullscreenLayout", "theme.islands.control.layout.Fullscreen"), e(c)
    });
  }],
  ['2!', function(ym) {
    ym.modules.define("control.GeolocationControl", ["util.defineClass", "geolocation", "control.Button", "control.storage", "control.optionMapper", "map.associate.serviceGeoObjects", "localization.common.current", "util.extend", "yandex.counter"], function(t, e, o, s, i, n, a, c, l, r) {
      var h = "geolocationControl",
        u = e(function(t) {
          var e = t && t.data || {};
          u.superclass.constructor.call(this, t), this.data.set(l({
            iconType: "geolocation",
            title: c.Control.ToolBar.geolocation
          }, e)), this.options.setName(h), this.options.set("selectOnClick", !1), this._state = "ready", this._geoObjects = null, this._actualRequest = null
        }, s, {
          onAddToMap: function() {
            u.superclass.onAddToMap.call(this), this.events.add("press", this._onGeolocationPress, this), r.countByKey("control", "geolocation.create")
          },
          onRemoveFromMap: function(t) {
            this.events.remove("press", this._onGeolocationPress, this);
            var e = this._geoObjects;
            e && e.getParent() && (e.getParent().remove(e), this._geoObjects = null, this._actualRequest = null, this._state = "ready"), u.superclass.onRemoveFromMap.call(this, t)
          },
          _onGeolocationPress: function() {
            if ("ready" == this._state) {
              this.disable(), this._state = "pending";
              var t = this._actualRequest = this._getLocation().then(function(e) {
                if (t == this._actualRequest) {
                  this.enable();
                  var o = this._geoObjects;
                  o && o.getParent() && o.getParent().remove(o), this._geoObjects = e.geoObjects, this.options.get("noPlacemark", !1) || a.get(this.getMap()).add(this._geoObjects), this._state = "ready", this.events.fire("locationchange", {
                    position: this._geoObjects.get(0).geometry.getCoordinates(),
                    geoObjects: this._geoObjects
                  })
                }
              }, function() {
                t == this._actualRequest && (this.enable(), this._state = "ready")
              }, null, this)
            }
            r.countByKey("control", "geolocation.click")
          },
          _getLocation: function() {
            return o.get({
              mapStateAutoApply: !0,
              useMapMargin: this.options.get("useMapMargin", !0)
            })
          }
        });
      n.setRule({
        name: h,
        rule: ["prefixed", "plain"]
      }), i.add(h, u), t(u)
    });
  }],
  ['2)', function(ym) {
    ym.modules.define("control.ListBox", ["util.defineClass", "control.BaseGroup", "control.component.ToolBarButton", "control.component.CollapseOnBlur", "control.optionMapper", "layout.define"], function(e, t, s, n, i, a, l) {
      var o = function(e) {
        o.superclass.constructor.call(this, e), this.options.setName("listBox"), this._setupListBoxLayoutEventRules(), this._expanded = this.state.get("expanded"), this._enabled = this.state.get("enabled"), this.state.events.add("change", this._onListBoxStateChange, this), this._toolBarButtonComponent = new n(this), this._collapseOnBlurComponent = new i(this)
      };
      t(o, s, {
        enable: function() {
          return this.isEnabled() || this.state.set("enabled", !0), this
        },
        disable: function() {
          return this.isEnabled() && this.state.set("enabled", !1), this
        },
        isEnabled: function() {
          return this.state.get("enabled", !0)
        },
        expand: function() {
          return this.isExpanded() || this.state.set("expanded", !0), this
        },
        collapse: function() {
          return this.isExpanded() && this.state.set("expanded", !1), this
        },
        isExpanded: function() {
          return this.state.get("expanded", !1)
        },
        _setupListBoxLayoutEventRules: function() {
          this.eventProxy.disableEventFiring("expand").setCallback("expand", this.expand, this).disableEventFiring("collapse").setCallback("collapse", this.collapse, this).disableEventFiring("enable").setCallback("enable", this.enable, this).disableEventFiring("disable").setCallback("disable", this.disable, this).setCallback("click", this._onClick, this, !0)
        },
        _onClick: function(e) {
          this.isEnabled() && (this.events.fire("press"), this.options.get("expandOnClick", !0) && (this.isExpanded() ? this.collapse() : this.expand()))
        },
        _onListBoxStateChange: function() {
          this.state.get("expanded") != this._expanded && (this._expanded = this.state.get("expanded"), this.events.fire(this._expanded ? "expand" : "collapse")), this.state.get("enabled") != this._enabled && (this._enabled = this.state.get("enabled"), this.events.fire(this._enabled ? "enable" : "disable"))
        }
      }), a.setRule({
        name: "listBox",
        rule: ["prefixed", "plain"]
      }), l("islands#listBoxLayout", "theme.islands.control.layout.ListBox"), e(o)
    });
  }],
  ['9;', function(ym) {
    ym.modules.define("control.ListBoxItem", ["util.defineClass", "control.Selectable", "control.optionMapper", "layout.define"], function(t, e, s, i, o) {
      function n(t, e) {
        return e + t.slice(0, 1).toUpperCase() + t.slice(1)
      }
      var l = function(t) {
        l.superclass.constructor.call(this, "string" == typeof t ? {
          data: {
            content: t
          }
        } : t), this.options.setName("listBoxItem"), this._setupItemLayoutEventRules()
      };
      e(l, s, {
        _setupItemLayoutEventRules: function() {
          this.eventProxy.setCallback("click", this._onClick, this, !0)
        },
        _onClick: function(t) {
          this.isEnabled() && this.options.get("selectOnClick", !0) && (this.isSelected() ? this.deselect() : this.select())
        }
      }), i.setRule({
        name: "listBoxItem",
        rule: function(t, e) {
          return [n(t, "item"), n(t, "listBoxItem")]
        }
      }), o("islands#listBoxItemLayout", "theme.islands.control.layout.ListBoxItem"), t(l)
    });
  }],
  ['2:', function(ym) {
    ym.modules.define("control.Manager", ["event.Manager", "option.Manager", "data.Manager", "Monitor", "vow", "control.manager.toolbarElementController", "control.childElementController.Base", "control.manager.predefinedSets", "component.array.BaseArray", "control.storage", "map.pane.helper.controls", "control.optionMapper", "event.Mapper", "control.EventMappingTable", "util.id", "util.bind", "util.array", "util.extend", "util.dom.style", "util.dom.element", "util.dom.className", "util.margin", "util.css", "yandex.counter", "util.defineClass", "control.manager.css"], function(t, e, n, i, o, r, s, a, l, h, c, d, _, g, p, m, f, u, C, v, y, E, M, b, S, P) {
      function A(t, e, n) {
        var i = t.options.get("maxWidth") || 90;
        if (u.isArray(i)) {
          var o = t.options.get("size");
          i = o ? i[u.indexOf(n, o)] : i[e]
        }
        return i
      }

      function x(t) {
        for (var e = {}, n = 0, i = I.length; n < i; n++) {
          var o = I[n],
            r = typeof t[o];
          "number" == r ? e[o] = t[o].toString() + "px" : "undefined" != r && (e[o] = t[o])
        }
        return e
      }

      function w(t) {
        var e = L(t);
        if ("none" != e) return e;
        var n = C({}, K, x(t.options.get("position", {})));
        return "auto" != n.bottom ? "bottom" : "top"
      }

      function L(t) {
        var e = t.options.get("float", O["float"]),
          n = t.options.get("position");
        return n || "none" == e ? "none" : e
      }
      var B = {
          marginLeft: 0,
          marginRight: 0
        },
        K = {
          left: "auto",
          right: "auto",
          top: "auto",
          bottom: "auto",
          marginLeft: 0,
          marginRight: 0
        },
        O = {
          "float": "right",
          floatIndex: 0,
          states: ["small", "medium", "large"],
          margin: 10,
          pane: null,
          toolbarMarginAreaHeight: 28
        },
        I = ["top", "left", "right", "bottom"],
        T = P(function(t, o, r) {
          if (r = r || {}, ym.env.debug && !t) throw new Error("control.Manager: map not found");
          this._map = t, this.events = new e({
            context: this
          }), this._defaultPane = this._map.panes.get("controls"), this.options = new n(C({
            margin: O.margin,
            states: O.states,
            pane: this._defaultPane
          }, r), this._map.options, "controls", _), this._activeState = Math.floor(this.options.get("states", O.states).length / 2), this.state = new i({
            size: this._getActiveState()
          }), this._controlsOrderArray = [], this._controlsArray = new h, this._controlsByKey = {}, this._controlKeys = {}, this._toolbarsMarginAccessors = {
            left: this._map.margin.addArea(0),
            right: this._map.margin.addArea(0)
          }, this._childMonitors = {}, this._childListeners = {}, this._childElementControllers = {
            top: new a(this),
            bottom: new a(this),
            left: s.create(this, "left"),
            right: s.create(this, "right")
          }, this._childElements = {}, this._childSides = {}, this._init(o)
        }, {
          add: function(t, e) {
            var n;
            if ("string" == typeof t && (n = l.get(t))) {
              for (var i = 0, o = n.length; i < o; i++) {
                var r = n[i];
                "string" == typeof r ? this.add(r) : this.add(r.type, r.options)
              }
              S.countByKey("modulesUsage", "controlSet." + t.replace(/[^A-Za-z]/g, "_"))
            } else {
              if ("string" == typeof t) {
                if (this._controlsByKey[t]) {
                  if (ym.env.debug) throw new Error("Control.Manager.add: " + t + " is already added by the key.");
                  return !1
                }
                var s = c.get(t);
                if (ym.env.debug && !s) throw new Error("Control.Manager.add: " + t + " doesn't exist.");
                var a = new s;
                this._controlsByKey[t] = a, this._controlKeys[m.get(a)] = t, t = a
              }
              this._addControlInstance(t, e)
            }
            return this
          },
          getChildElement: function(t) {
            var e = r.defer();
            return e.resolve(this._childElements[m.get(t)]), e.promise()
          },
          remove: function(t) {
            var e;
            if ("string" == typeof t && (e = l.get(t)))
              for (var n = 0, i = e.length; n < i; n++) {
                var o = e[n];
                "string" == typeof o ? this.remove(o) : this.remove(o.type)
              } else {
                if (this.indexOf(t) == -1) return this;
                if ("string" == typeof t) {
                  var r = this._controlsByKey[t];
                  delete this._controlsByKey[t], t = r
                }
                this._removeControlInstance(t), t.setParent(null), t.options.setParent(null), this._applyState()
              }
            return this
          },
          indexOf: function(t) {
            return "string" == typeof t && (t = this._controlsByKey[t]), u.indexOf(this._controlsOrderArray, t)
          },
          getIterator: function() {
            return this._controlsArray.getIterator()
          },
          get: function(t) {
            return "string" == typeof t ? this._controlsByKey[t] : this._controlsArray.get(t)
          },
          getContainer: function() {
            return this.options.get("pane", this._defaultPane).getElement()
          },
          each: function(t, e) {
            return this._controlsArray.each(t, e), this
          },
          getMap: function() {
            return this._map
          },
          destroy: function() {
            this._optionMonitor.destroy(), this._mapStateMonitor.destroy(), this._mapListeners.removeAll();
            var t = [];
            this.each(function(e) {
              t.push(e)
            });
            for (var e = 0, n = t.length; e < n; e++) this.remove(t[e]);
            this.options.setParent(null)
          },
          _addControlInstance: function(t, e) {
            if (this._controlsArray.indexOf(t) != -1) {
              if (ym.env.debug) throw new Error("Control.Manager.add: control is already added");
              return !1
            }
            e && t.options.set(e), this._controlsOrderArray.push(t), this._childElements[m.get(t)] = y.create();
            var n = w(t);
            this._childSides[m.get(t)] = n, this._setupChildElementController(t, n), this._setupControlMonitors(t), this._controlsArray.add(t), this._applyState(), t.options.setParent(this.options), t.events.setParent(new g(this.events, new p(this))), t.setParent(this), this._setupControlListeners(t), this.events.fire("add", {
              child: t
            })
          },
          _removeControlInstance: function(t) {
            var e = m.get(t);
            if (this._controlKeys[m.get(t)]) {
              var n = this._controlKeys[e];
              delete this._controlKeys[e], delete this._controlsByKey[n]
            }
            this._controlsArray.remove(t), u.remove(this._controlsOrderArray, t), this._removeControlMonitors(t), this._clearControlListeners(t), this._clearChildElementController(t, this._childSides[e]), delete this._childSides[e], delete this._childElements[e], this.events.fire("remove", {
              child: t
            })
          },
          _setupControlListeners: function(t) {
            this._childListeners[m.get(t)] = t.events.group().add("mapchange", this._onControlMapChange, this)
          },
          _clearControlListeners: function(t) {
            var e = m.get(t);
            this._childListeners[e].removeAll(), delete this._childListeners[e]
          },
          _setupControlMonitors: function(t) {
            var e = m.get(t);
            this._childMonitors[e] = new o(t.options).add("adjustMapMargin", function() {
              this._recalculateToolbarsMarginAreas()
            }, this).add("float", function() {
              this._onControlFloatChange(t), this._recalculateToolbarsMarginAreas()
            }, this).add("position", function() {
              this._onControlPositionChange(t), this._recalculateToolbarsMarginAreas()
            }, this).add(["maxWidth", "visible", "size"], this._applyState, this)
          },
          _removeControlMonitors: function(t) {
            var e = m.get(t);
            this._childMonitors[e].destroy(), delete this._childMonitors[e]
          },
          _setupChildElementController: function(t, e) {
            var n = this._childElements[m.get(t)];
            if (this._childElementControllers[e].insert(t, n), "right" == e || "left" == e) {
              var i, o = this.options.get("margin", O.margin).toString() + "px";
              i = "left" == e ? {
                marginRight: 0,
                marginLeft: o
              } : {
                marginLeft: 0,
                marginRight: o
              }, v.css(n, C({}, B, i)), E.add(n, b.addPrefix("controls__control_toolbar"))
            } else this._applyCustomPosition(t), E.add(n, b.addPrefix("controls__control"))
          },
          _clearChildElementController: function(t, e) {
            var n = this._childElements[m.get(t)];
            this._childElementControllers[e].remove(t, n), "right" == e || "left" == e ? E.remove(n, b.addPrefix("controls__control_toolbar")) : E.remove(n, b.addPrefix("controls__control"))
          },
          _applyState: function() {
            for (var t = this.options.get("states", O.states), e = this.options.get("pane", this._defaultPane).getViewport(), n = e[1][0] - e[0][0], i = !0; i;) this._getMaxWidth(this._activeState) < n ? this._activeState + 1 < t.length && this._getMaxWidth(this._activeState + 1) < n ? this._activeState++ : i = !1 : this._activeState > 0 ? this._activeState-- : i = !1;
            this.state.set("size", this._getActiveState()), this._recalculateToolbarsMarginAreas()
          },
          _onMarginChange: function(t) {
            t = "undefined" != typeof t ? t : O.margin, v.css(this._toolbarElement, {
              marginTop: t.toString() + "px"
            }), this._applyState()
          },
          _onPaneChange: function() {
            var t = this.getContainer();
            this._toolbarElement.parentNode.removeChild(this._toolbarElement), this._bottomContainerElement.parentNode.removeChild(this._bottomContainerElement), t.appendChild(this._toolbarElement), t.appendChild(this._bottomContainerElement), this._childElementControllers.top.setParentElement(t)
          },
          _onMapSizeChange: function() {
            this._applyState(), this._applyBottomContainerPosition()
          },
          _getActiveState: function() {
            return this.options.get("states", O.states)[this._activeState]
          },
          _getMaxWidth: function(t) {
            var e = this.options.get("states", O.states),
              n = this.options.get("margin", O.margin),
              i = 0,
              o = 0;
            return this._controlsArray.each(function(n) {
              var r = L(n),
                s = n.options.get("visible", !0);
              "none" != r && s && (i += parseInt(A(n, t, e), 10), o++)
            }), i + n * (o + 1)
          },
          _onControlFloatChange: function(t) {
            this._checkChildController(t)
          },
          _onControlPositionChange: function(t) {
            this._checkChildController(t);
            var e = this._childSides[m.get(t)];
            "top" != e && "bottom" != e || this._applyCustomPosition(t)
          },
          _recalculateToolbarsMarginAreas: function() {
            var t = this.options.get("margin", O.margin),
              e = {
                left: 0,
                right: 0
              },
              n = this.options.get("states", O.states);
            this._controlsArray.each(function(i) {
              var o = this._childSides[m.get(i)],
                r = i.options.get("visible", !0);
              e.hasOwnProperty(o) && i.options.get("adjustMapMargin", !1) && r && (e[o] += parseInt(A(i, this._activeState, n), 10) + t)
            }, this);
            for (var i in e)
              if (e.hasOwnProperty(i)) {
                e[i] > 0 && (e[i] -= t);
                var o = {
                  top: t,
                  width: e[i],
                  height: this.options.get("toolbarMarginAreaHeight", O.toolbarMarginAreaHeight)
                };
                o[i] = t, this._toolbarsMarginAccessors[i].setArea(o)
              }
          },
          _onControlMapChange: function(t) {
            var e = t.get("target");
            this._removeControlInstance(e), this._applyState()
          },
          _onMapMarginChange: function() {
            this._applyBottomContainerPosition()
          },
          _checkChildController: function(t) {
            var e = m.get(t),
              n = w(t),
              i = this._childSides[e];
            n != i && (this._clearChildElementController(t, i), this._childSides[e] = n, this._setupChildElementController(t, n))
          },
          _applyCustomPosition: function(t) {
            if ("none" == L(t)) {
              var e = t.options,
                n = C({}, K, x(e.get("position", {}))),
                i = this._childElements[m.get(t)];
              v.css(i, n)
            }
          },
          _applyBottomContainerPosition: function() {
            var t = this._map.state.get("margin"),
              e = this.options.get("pane", this._defaultPane).getViewport(),
              n = e[1][1] - e[0][1];
            n -= M.correct(t)[2], v.css(this._bottomContainerElement, {
              top: n.toString() + "px"
            })
          },
          _init: function(t) {
            if (this._initHTMLContainers(), this._optionMonitor = new o(this.options).add("margin", this._onMarginChange, this).add("states", this._applyState, this).add("pane", this._onPaneChange, this), this._mapListeners = this._map.events.group().add("sizechange", this._onMapSizeChange, this).add("destroy", this.destroy, this), this._mapStateMonitor = new o(this._map.state).add("margin", this._onMapMarginChange, this), t)
              for (var e = 0, n = t.length; e < n; e++) this.add(t[e])
          },
          _initHTMLContainers: function() {
            this._toolbarElement = y.create({
              className: b.addPrefix("controls__toolbar"),
              css: {
                marginTop: this.options.get("margin", O.margin).toString() + "px"
              }
            }), this._bottomContainerElement = y.create({
              className: b.addPrefix("controls__bottom")
            }), this._leftContainerElement = y.create({
              className: b.addPrefix("controls__toolbar_left")
            }), this._rightContainerElement = y.create({
              className: b.addPrefix("controls__toolbar_right")
            });
            var t = this.getContainer();
            t.appendChild(this._toolbarElement), t.appendChild(this._bottomContainerElement), this._toolbarElement.appendChild(this._leftContainerElement), this._toolbarElement.appendChild(this._rightContainerElement), this._applyBottomContainerPosition(), this._childElementControllers.top.setParentElement(t), this._childElementControllers.bottom.setParentElement(this._bottomContainerElement), this._childElementControllers.right.setParentElement(this._rightContainerElement), this._childElementControllers.left.setParentElement(this._leftContainerElement)
          }
        });
      t(T)
    });
  }],
  ['0m', function(ym) {
    ym.modules.define("control.manager.css", ["control-manager"], function(n) {
      n({})
    });
  }],
  ['9j', function(ym) {
    ym.modules.define("control.manager.predefinedSets", ["util.Storage"], function(e, n) {
      e(new n)
    });
  }],
  ['9q', function(ym) {
    ym.modules.define("control.manager.toolbarElementController", ["util.defineClass", "control.childElementController.Base", "Monitor", "util.bind", "util.id"], function(t, i, n, e, o, s) {
      var r = function(t, i) {
        r.superclass.constructor.call(this, t), this._side = i, this._childPositionMonitors = {}
      };
      i(r, n, {
        insert: function(t, i) {
          r.superclass.insert.call(this, t, i), this.getParentElement() && this._setupChildMonitor(t)
        },
        remove: function(t) {
          this.getParentElement() && this._clearChildMonitor(t), r.superclass.remove.call(this, t)
        },
        getChildIndex: function(t) {
          return this.getParent().indexOf(t)
        },
        comparator: function(t, i) {
          var n = t.options.get("floatIndex", 0),
            e = this.getChildIndex(t),
            o = i.options.get("floatIndex", 0),
            s = this.getChildIndex(i);
          return "left" == this._side ? o - n || s - e : n - o || e - s
        },
        setParentElement: function(t) {
          var i = this.getParentElement();
          r.superclass.setParentElement.call(this, t), i && !t && this._clearChildMonitors(), !i && t && this._setupChildMonitors()
        },
        _setupChildMonitors: function() {
          this.getParent().each(o(function(t) {
            this._setupChildMonitor(t)
          }, this))
        },
        _clearChildMonitors: function() {
          this.getParent().each(o(function(t) {
            this._clearChildMonitor(t)
          }, this))
        },
        _setupChildMonitor: function(t) {
          this._childPositionMonitors[s.get(t)] = new e(t.options).add("floatIndex", function() {
            this.onChildPositionChange(t)
          }, this)
        },
        _clearChildMonitor: function(t) {
          var i = s.get(t);
          this._childPositionMonitors[i].destroy(), delete this._childPositionMonitors[i]
        }
      });
      var l = {
        create: function(t, i) {
          return new r(t, i)
        }
      };
      t(l)
    });
  }],
  ['2q', function(ym) {
    ym.modules.define("control.optionMapper", ["option.Mapper"], function(o, n) {
      o(new n)
    });
  }],
  ['2z', function(ym) {
    ym.modules.define("control.RouteEditor", ["util.defineClass", "localization.common.current", "control.storage", "control.optionMapper", "control.BaseBehaviorButton", "util.extend", "yandex.counter", "behavior.RouteEditor"], function(e, t, o, r, i, n, a, s) {
      function u(e) {
        var t = e && e.data || {};
        u.superclass.constructor.call(this, e), this.data.set(a({
          iconType: "routes",
          title: o.Control.RouteEditor
        }, t)), this._behaviorEvents = null, this.options.setName("routeEditor")
      }
      t(u, n, {
        getBehaviorName: function() {
          return "routeEditor"
        },
        getRoute: function() {
          return this.getMap().behaviors.get(this.getBehaviorName()).getRoute()
        },
        onAddToMap: function(e) {
          u.superclass.onAddToMap.call(this, e), this._behaviorEvents = e.behaviors.get(this.getBehaviorName()).events.group().add("disable", this.deselect, this), s.countByKey("control", "routeEditor.create")
        },
        onRemoveFromMap: function(e) {
          this._behaviorEvents.removeAll(), this._behaviorEvents = null, u.superclass.onRemoveFromMap.call(this, e)
        }
      }), i.setRule({
        name: "routeEditor",
        rule: "prefixed"
      }), i.setRule({
        name: "routeEditor",
        key: ["adjustMapMargin"],
        rule: ["prefixed", "plain"]
      }), r.add("routeEditor", u), e(u)
    });
  }],
  ['2J', function(ym) {
    ym.modules.define("control.RulerControl", ["localization.common.current", "control.storage", "control.BaseBehaviorButton", "control.optionMapper", "util.extend", "layout.define", "yandex.counter", "util.defineClass", "behavior.Ruler"], function(e, t, l, r, n, o, i, s, u) {
      function c(e) {
        var l = e && e.data || {};
        c.superclass.constructor.call(this, e), this.data.set(o({
          iconType: "ruler",
          title: t.Control.ToolBar.ruler
        }, l)), this.options.setName("rulerControl"), this._setupRulerButtonEvents(), s.countByKey("control", "ruler.create")
      }
      u(c, r, {
        getBehaviorName: function() {
          return "ruler"
        },
        _setupRulerButtonEvents: function() {
          this.eventProxy.unsetCallback("click").disableEventFiring("click").setCallback("rulerbuttonclick", this._onRulerButtonClick, this).disableEventFiring("rulerbuttonclick")
        },
        _onRulerButtonClick: function() {
          this.events.fire("click"), this.isEnabled() && (this.events.fire("press"), this.options.get("selectOnClick", !0) && (this.isSelected() ? this.deselect() : this.select()))
        }
      }), l.add("rulerControl", c), n.setRule({
        name: "rulerControl",
        rule: "prefixed"
      }), n.setRule({
        name: "rulerControl",
        key: ["adjustMapMargin"],
        rule: ["prefixed", "plain"]
      }), i("islands#rulerLayout", "theme.islands.control.layout.Ruler"), e(c)
    });
  }],
  ['3a', function(ym) {
    ym.modules.define("control.SearchControl", ["control.Base", "control.storage", "control.optionMapper", "yandex.geocodeProvider.storage", "yandex.searchProvider.storage", "control.searchControl.GeocodeProvider", "control.searchControl.SearchProvider", "control.searchControl.component.SearchGeoObjects", "control.searchControl.component.GeocodeGeoObjects", "control.component.ToolBarButton", "Monitor", "util.extend", "util.cancelableCallback", "util.defineClass", "vow", "yandex.state.component.SearchControl", "yandex.counter", "meta.internal", "theme.islands.search.meta"], function(e, t, s, o, n, r, i, a, l, u, h, c, d, g, p, v, _, f, m) {
      function C(e) {
        C.superclass.constructor.call(this, e), this.options.setName("searchControl"), this._toolbarControlComponent = new h(this), this._controlOptionsMonitor = null, this._provider = null, this._providerListener = null, this._geoObjectsComponent = null, this._setupProvider(), this._setupLayoutEventRules(), this._suggestOptionMonitor = null, this._suggestStateMonitor = null, this._providerResolveCallback = null
      }
      var R = "yandex#map";
      p(C, t, {
        onAddToMap: function(e) {
          C.superclass.onAddToMap.call(this, e), this._yandexState = new _(this), this._setupSuggest(), f.countByKey("control", "search.create")
        },
        onRemoveFromMap: function(e) {
          this._yandexState.destroy(), this._yandexState = null, this._teardownSuggest(), C.superclass.onRemoveFromMap.call(this, e)
        },
        search: function(e) {
          var t, s = this.getMap(),
            o = {
              boundedBy: this.options.get("useMapBounds") && s ? s.getBounds() : this.options.get("boundedBy")
            };
          return this._clearState(), t = this._provider.load(e, o), this.state.set("inputValue", e), this.events.fire("submit", {
            request: e
          }), t
        },
        showResult: function(e) {
          var t = this._provider,
            s = t.state.get("found"),
            o = t.getResult(e),
            n = this.getMap(),
            r = v.defer();
          if (!t.isLoaded() || e >= s || !n) {
            var i;
            if (t.isLoaded() ? e >= s ? i = "control.SearchControl.showResult: index is larger then found" : n || (i = "control.SearchControl.showResult: map not found") : i = "control.SearchControl.showResult: results is not loaded", ym.env.debug) throw new Error(i);
            return v.reject(i)
          }
          return o ? (this._selectResult(e), this._geoObjectsComponent.show(e).then(function() {
            r.resolve(o)
          }, this)) : this.getResult(e).then(function() {
            r.resolve(this.showResult(e))
          }, this), r.promise()
        },
        hideResult: function() {
          var e = this.state.get("currentIndex");
          this.events.fire("componenthide"), "number" == typeof e && this.events.fire("resulthide", {
            index: e
          }), this.state.unset("currentIndex")
        },
        getResponseMetaData: function() {
          return this._provider.getResponseMetaData()
        },
        getResult: function(e) {
          var t = v.defer(),
            s = this._provider,
            o = s.state.get("found"),
            n = s.getResult(e);
          if (ym.env.debug) {
            if (!s.isLoaded()) throw new Error("control.SearchControl: Данные ещё не были загружены.");
            if (e >= o) throw new Error("control.SearchControl: индекс больше, чем количество найденных результатов")
          }
          return e < o && (n ? t.resolve(n) : s.load({
            results: e - s.getResults().length + 1,
            type: "loadmore"
          }).then(function(o) {
            return t.resolve(s.getResult(e)), o
          })), t.promise()
        },
        getResultsArray: function() {
          return this._provider.getResults()
        },
        getResultsCount: function() {
          return this._provider.state.get("found")
        },
        getSelectedIndex: function() {
          return this.state.get("currentIndex")
        },
        getRequestString: function() {
          return this._provider.state.get("request")
        },
        destroy: function() {
          this.events.fire("destroy"), this._clearProvider(), this._teardownSuggest(), this._clearState()
        },
        getProvider: function() {
          return this._provider
        },
        clear: function() {
          this._provider.stopLoad(), this.state.unset("currentIndex"), this.events.fire("componenthide", {
            data: !0
          }), this._clearState(), this.events.fire("clear")
        },
        _setupProvider: function() {
          var e, t = this.options.get("provider", R);
          "string" == typeof t && r.isDefined(t) ? (t = new a(this), e = l) : (t = new i(this), e = u), this._provider = t, this._setupProviderListeners(), this._setupGeoObjectsComponent(e)
        },
        _clearProvider: function() {
          this._clearGeoObjectsComponent(), this._clearProviderListeners(), this._provider.destroy(), this._provider = null
        },
        _setupProviderListeners: function() {
          this._providerListener = this._provider.events.group().add("load", this._onRequestLoad, this).add("error", this._onErrorLoad, this), this._providerOptionsMonitor = new c(this.options).add("provider", this._onProviderChange, this, {
            defaultValue: R
          })
        },
        _clearProviderListeners: function() {
          this._providerListener.removeAll(), this._providerOptionsMonitor.destroy()
        },
        _setupGeoObjectsComponent: function(e) {
          var t = new e(this);
          this._geoObjectsComponentListeners = t.events.group().add("show", this._onComponentShowGeoObject, this).add("hide", this._onComponentGeoObjectHide, this), this._geoObjectsComponent = t
        },
        _clearGeoObjectsComponent: function(e) {
          this._geoObjectsComponent && (this._geoObjectsComponentListeners.removeAll(), this._geoObjectsComponent.destroy(), this._geoObjectsComponent = null)
        },
        _setupSuggest: function() {
          this._suggestOptionMonitor = new c(this.options).add("noSuggestPanel", this._checkSuggestNeeded, this), this._suggestStateMonitor = new c(this.state).add("size", this._checkSuggestNeeded, this), this._checkSuggestNeeded()
        },
        _teardownSuggest: function() {
          this._cancelProviderResolve(), this._suggestOptionMonitor.removeAll(), this._suggestStateMonitor.removeAll(), this.state.set("noSuggestPanel", !0)
        },
        _cancelProviderResolve: function() {
          this._providerResolveCallback && (this._providerResolveCallback.cancel(), this._providerResolveCallback = null)
        },
        _checkSuggestNeeded: function() {
          var e = this.state.get("size"),
            t = this.options.get("noSuggestPanel");
          "large" != e || t ? (this._cancelProviderResolve(), this.state.set("noSuggestPanel", !0)) : (this._providerResolveCallback = g.create(function(e) {
            this.state.set("noSuggestPanel", !e), this._providerResolveCallback = null
          }, this), this._provider.hasSuggest().done(this._providerResolveCallback))
        },
        _onComponentShowGeoObject: function(e) {
          var t = e.get("index"),
            s = this.state.get("currentIndex");
          s != t && this._selectResult(t), this.events.fire("resultshow", {
            index: t
          })
        },
        _onComponentSelectGeoObject: function(e) {},
        _onComponentGeoObjectHide: function(e) {
          var t = e.get("index");
          this.state.get("currentIndex") == t && (this.state.unset("currentIndex"), this.events.fire("resulthide", {
            index: t
          }))
        },
        _setupLayoutEventRules: function() {
          this.eventProxy.disableEventFiring("search").setCallback("search", function(e) {
            this.search(e.get("request"))
          }, this).disableEventFiring("loadmore").setCallback("loadmore", function() {
            this._provider.load({
              type: "loadmore"
            })
          }, this).disableEventFiring("resultselect").setCallback("resultselect", this._onResultSelect, this).disableEventFiring("dataclear").setCallback("dataclear", this._onDataClear, this).disableEventFiring("suggest")
        },
        _onResultSelect: function(e) {
          var t = e.get("index");
          this.showResult(t)
        },
        _selectResult: function(e) {
          var t = this.state.get("currentIndex");
          "number" == typeof t && this.events.fire("resulthide", {
            index: t
          }), this.state.set("currentIndex", e), this.events.fire("resultselect", {
            index: e
          })
        },
        _onRequestLoad: function(e) {
          var t = e.get("skip");
          t || this.state.unset("currentIndex"), this._renderResults(), this.events.fire("load", {
            skip: t,
            count: e.get("count")
          })
        },
        _onErrorLoad: function(e) {
          this.events.fire("error", {
            error: e.get("error")
          })
        },
        _onDataClear: function() {
          this.clear()
        },
        _clearState: function() {
          this.getMap() && this.events.fire("componenthide"), this._provider && this._provider.state.unsetAll(), this.state.unset(["popupOpened", "inputValue", "request", "suggest", "correction", "isLoaded", "metaData", "found", "results", "currentIndex"]), this.events.fire("clearstate")
        },
        _renderResults: function() {
          var e, t = this._provider,
            s = t.getType(),
            o = t.getResponseMetaData(),
            n = {};
          switch (s) {
            case "geocode":
              n = o;
              break;
            case "search":
              d(n, o.SearchRequest, o.SearchResponse)
          }
          e = m.displayAdvert && n.Banners && n.Banners[0], this.state.set({
            isLoaded: !0,
            request: n.request,
            correction: n.suggest,
            suggest: n.suggest,
            found: n.found,
            advert: e,
            results: t.getResults()
          })
        },
        _onProviderChange: function() {
          this._cancelProviderResolve(), this._clearProvider(), this.state.get("noSuggestPanel") || this.state.set("noSuggestPanel", !0), this._setupProvider(), this._checkSuggestNeeded()
        }
      }), o.setRule({
        name: "searchControl",
        rule: ["prefixed"]
      }), o.setRule({
        name: "searchControl",
        key: ["adjustMapMargin"],
        rule: ["prefixed", "plain"]
      }), s.add("searchControl", C), e(C)
    });
  }],
  [')i', function(ym) {
    ym.modules.define("control.searchControl.BaseProvider", ["event.Manager", "data.Manager", "option.Manager", "control.optionMapper", "yandex.geocodeProvider.storage", "suggest", "util.extend", "vow", "util.defineClass"], function(t, e, o, s, n, i, r, u, a, g) {
      function l(t) {
        this._control = t, this.events = new e, this.state = new o({
          isLoaded: !1,
          request: null,
          searchOptions: {},
          results: []
        }), this.options = new s, this.options.setMapper(n), this.options.setParent(t.options)
      }
      g(l, {
        getType: function() {
          return "geocode"
        },
        load: function(t, e) {},
        stopLoad: function() {
          var t = this.getLoadDefer();
          t && !t.promise().isResolved() && t.reject("Loading is stopped")
        },
        getLoadDefer: function() {},
        hasSuggest: function() {
          var t = this._control.options.get("provider"),
            e = this.options.get("providerStorage", i);
          return "string" == typeof t ? e.require([t]).then(function(t) {
            return "function" == typeof t[0].suggest
          }) : a.resolve(t && "function" == typeof t.suggest)
        },
        suggest: function(t, e) {
          var o = this._control.options,
            s = this.options.get("suggestResults");
          return e = u({
            provider: o.get("provider"),
            results: o.get("suggestResults", s)
          }, e), r(t, e)
        },
        isLoaded: function() {
          return this.state.get("isLoaded")
        },
        getResponseMetaData: function() {
          return this.state.get("responseMetaData")
        },
        getResult: function(t) {
          var e = this.getResults()[t];
          return "undefined" != typeof e ? e : null
        },
        getResults: function() {
          return this.state.get("results", []).slice()
        },
        getControl: function() {
          return this._control
        },
        destroy: function() {
          this.state.unsetAll(), this._control = null
        }
      }), t(l)
    });
  }],
  [')j', function(ym) {
    ym.modules.define("control.searchControl.component.BaseGeoObjects", ["event.Manager", "GeoObjectCollection", "map.associate.serviceGeoObjects", "util.defineClass"], function(o, t, n, e, i) {
      function s(o) {
        this.events = new t, this._control = o, this._collection = new n, this._isCollectionAdded = null, this._isInited = !1, this._setupComponent()
      }
      i(s, {
        isInited: function() {
          return this._isInited
        },
        initComponent: function() {
          this.addCollectionToMap(), this._setupBaseComponentControlListeners()
        },
        destroy: function() {
          this._isInited && (this.removeCollectionFromMap(), this._clearBaseComponentControlListeners())
        },
        show: function(o) {},
        hide: function(o) {},
        getCollection: function() {
          return this._collection
        },
        getControl: function() {
          return this._control
        },
        isCollectionAddedToMap: function() {
          return this._isCollectionAdded
        },
        addCollectionToMap: function() {
          var o = this._control.getMap(),
            t = e.get(o);
          t.indexOf(this._collection) == -1 && t.add(this._collection), this._isCollectionAdded = !0
        },
        removeCollectionFromMap: function(o) {
          if (o = o || this._control.getMap()) {
            var t = e.get(o);
            t.indexOf(this._collection) != -1 && (this._openBalloonCallback && this._openBalloonCallback.cancel(), t.remove(this._collection)), this._isCollectionAdded = !1
          }
        },
        fireShow: function(o) {
          this.events.fire("show", {
            index: o
          })
        },
        _setupComponent: function() {
          var o = this._control;
          o.getMap() ? (this.initComponent(), this._isInited = !0) : o.events.once("mapchange", this._setupComponent, this)
        },
        _setupBaseComponentControlListeners: function() {
          this._baseComponentControlListeners = this._control.events.group().add("componentshow", this._onBaseComponentControlShow, this).add("componenthide", this._onBaseComponentControlHide, this)
        },
        _clearBaseComponentControlListeners: function() {
          this._baseComponentControlListeners.removeAll()
        },
        _onBaseComponentControlShow: function(o) {
          this.show(o.get("index"))
        },
        _onBaseComponentControlHide: function(o) {
          this.hide(o.get("data"))
        }
      }), o(s)
    });
  }],
  [')q', function(ym) {
    ym.modules.define("control.searchControl.component.GeocodeGeoObjects", ["control.searchControl.component.BaseGeoObjects", "util.cancelableCallback", "util.defineClass", "vow"], function(t, e, o, n, l) {
      function a(t) {
        this._controlListeners = null, this._currentGeoObject = null, this._openBalloonCallback = null, a.superclass.constructor.call(this, t)
      }
      n(a, e, {
        show: function(t) {
          this.hide();
          var e, o, n = this.getControl(),
            a = n.getMap(),
            s = n.getResultsArray()[t],
            i = this.getCollection(),
            c = n.options,
            r = c.get("noCentering"),
            h = c.get("noPlacemark");
          if (!r) {
            var u = s.properties.get("boundedBy") || s.geometry.getBounds();
            e = a.setBounds(u, {
              checkZoomRange: !0,
              zoomMargin: c.get("zoomMargin", 0),
              useMapMargin: c.get("useMapMargin", !0)
            }), o = e
          }
          if (!h)
            if (this._currentGeoObject = s, i.add(s), r) s.options.set("balloonAutoPan", !1), o = s.balloon.open().then(function() {
              s.options.set("balloonAutoPan", !0)
            });
            else {
              var p = this._geoOpenBalloonCancelableCallback();
              e.then(p)
            }
          return o || (o = l.resolve(!0)), o.then(function() {
            this.fireShow(t)
          }, this)
        },
        hide: function() {
          var t = this._currentGeoObject,
            e = this.getCollection();
          t && (this._openBalloonCallback && (this._openBalloonCallback.cancel(), this._openBalloonCallback = null), this._requestCallback && (this._requestCallback.cancel(), this._requestCallback = null), e.removeAll(), this._currentGeoObject = null)
        },
        initComponent: function() {
          a.superclass.initComponent.call(this), this._setupListeners()
        },
        destroy: function() {
          this.isInited() && (this._openBalloonCallback && (this._openBalloonCallback.cancel(), this._openBalloonCallback = null), this._clearListeners()), a.superclass.destroy.call(this)
        },
        _setupListeners: function() {
          var t = this.getControl();
          this._controlListeners = t.events.group().add("submit", this._onSubmit, this).add("load", this._onLoad, this).add("mapchange", this._onMapChange, this)
        },
        _clearListeners: function() {
          this._controlListeners.removeAll()
        },
        _onSubmit: function() {
          this.hide()
        },
        _onLoad: function(t) {
          var e = this.getControl();
          0 != t.get("skip") || 1 != e.state.get("found") || e.options.get("noSelect") || this.show(0)
        },
        _onMapChange: function(t) {
          var e = t.get("oldMap"),
            o = t.get("newMap"),
            n = this._currentGeoObject,
            l = this.getControl().state,
            a = this.getCollection(),
            s = l.get("request") && l.get("found");
          e && this.isCollectionAddedToMap() && this.removeCollectionFromMap(e), o && (s && !a.getLength() && n && a.add(n), this.addCollectionToMap())
        },
        _geoOpenBalloonCancelableCallback: function() {
          var t = this._currentGeoObject;
          return this._openBalloonCallback && this._openBalloonCallback.cancel(), this._openBalloonCallback = o.create(function() {
            this._openBalloonCallback = null, t.getMap() && t.balloon.open()
          }, this), this._openBalloonCallback
        }
      }), t(a)
    });
  }],
  [')z', function(ym) {
    ym.modules.define("control.searchControl.component.SearchGeoObjects", ["control.searchControl.component.BaseGeoObjects", "util.cancelableCallback", "yandex.counter", "vow", "util.array", "util.defineClass"], function(e, t, o, s, n, i, r) {
      function l(e) {
        this._controlListeners = null, this._geoObjectListeners = null, this._deferredBalloonOpen = null, this._isFirstLoad = null, l.superclass.constructor.call(this, e)
      }
      r(l, t, {
        show: function(e) {
          var t, o = this.getControl(),
            s = this.getCollection(),
            n = o.getResponseMetaData().SearchResponse.display,
            i = o.getResultsArray()[e],
            r = this._getInnerGeoObjectIndex(i),
            l = i;
          return r != -1 && (l = s.get(r)), this._setProcessingState(), l.balloon.isOpen() ? t = l.balloon.autoPan().then(this._unsetProcessingState, this) : ("multiple" != n && (this._clearCollection(), s.add(l), this.isCollectionAddedToMap() || this.addCollectionToMap()), t = l.getOverlay().then(function() {
            return this._openBalloon(l)
          }, this), this._logCardShow(l)), t.then(function() {
            this.fireShow(e)
          }, this)
        },
        hide: function(e) {
          var t = this.getControl(),
            o = t.getMap(),
            s = n.resolve();
          return o && (o.balloon.isOpen() && (s = o.balloon.close()), e && (this.removeCollectionFromMap(), this._clearCollection())), s
        },
        initComponent: function() {
          var e = this.getControl(),
            t = this.getCollection(),
            o = e.state,
            s = o.get("request") && o.get("found");
          s && !t.getLength() && this._addItems(), this._setupListeners(), this._setupCollectionOptions(), l.superclass.initComponent.call(this)
        },
        destroy: function() {
          this.isInited() && (this._requestCallback && (this._requestCallback.cancel(), this._requestCallback = null), this._clearGeoObjectListeners(), this._clearListeners()), l.superclass.destroy.call(this)
        },
        _setupCollectionOptions: function() {
          var e = this.getCollection(),
            t = this.getControl();
          e.options.set({
            preset: t.options.get("geoObjectStandardPreset")
          })
        },
        _setupListeners: function() {
          var e = this.getControl(),
            t = this.getCollection();
          this._controlListeners = e.events.group().add("submit", this._onSubmit, this).add("load", this._onLoad, this).add("mapchange", this._onMapChange, this), this._collectionListeners = t.events.group().add("click", this._onGeoObjectClick, this)
        },
        _clearListeners: function() {
          this._controlListeners.removeAll(), this._collectionListeners.removeAll()
        },
        _onSubmit: function() {
          this.removeCollectionFromMap(), this._clearCollection(), this._isFirstLoad = !0
        },
        _onLoad: function(e) {
          var t = this.getControl(),
            o = t.getMap(),
            s = t.getResponseMetaData().SearchResponse,
            n = "multiple" == s.display,
            i = e.get("skip");
          if (i) n && this._addItems(i);
          else if (this._addItemsDiff(), n && this.addCollectionToMap(), this._isFirstLoad && s.found) {
            this._setProcessingState();
            var r = o.setBounds(s.boundedBy, {
              checkZoomRange: !0
            });
            1 == s.found && r.then(function() {
              this.show(0)
            }, this), r.then(this._unsetProcessingState, this)
          }
          this._isFirstLoad = !1
        },
        _onMapChange: function(e) {
          var t = e.get("oldMap"),
            o = e.get("newMap"),
            s = this.getCollection(),
            n = this.getControl(),
            i = n.state,
            r = i.get("request") && i.get("found");
          t && this.isCollectionAddedToMap() && this.removeCollectionFromMap(t), o && (r && !s.getLength() && this._addItems(), this.addCollectionToMap())
        },
        _logCardShow: function(e) {
          var t = e.properties.get("advert.counter");
          t && s.directCount(t), s.countByKey("modulesUsage", "search.showCard." + e.properties.get("type", "unknown"))
        },
        _openBalloon: function(e) {
          var t = n.defer(),
            o = e.getMap();
          return this._deferredBalloonOpen && this._deferredBalloonOpen.reject("show: new request"), this._clearGeoObjectListeners(), o ? (e.balloon.open().then(this._unsetProcessingState, this).then(function() {
            t.resolve(!0)
          }), this._geoObjectListeners = e.events.group().add("balloonclose", this._onBalloonClose, this)) : t.reject("show: map not found"), this._deferredBalloonOpen = t, t.promise()
        },
        _clearGeoObjectListeners: function() {
          this._geoObjectListeners && this._geoObjectListeners.removeAll()
        },
        _setProcessingState: function() {
          var e = this.getControl();
          e.state.set("processing", !0)
        },
        _unsetProcessingState: function() {
          var e = this.getControl();
          e.state.set("processing", !1)
        },
        _clearCollection: function() {
          var e = this.getCollection();
          e.removeAll(), this._clearGeoObjectListeners()
        },
        _onGeoObjectClick: function(e) {
          var t, o = e.get("target");
          o.balloon.isOpen() || (t = this._getGeoObjectIndex(o), this._logCardShow(o), this.fireShow(t)), this._clearGeoObjectListeners(), this._geoObjectListeners = o.events.group().add("balloonclose", this._onBalloonClose, this)
        },
        _onBalloonClose: function(e) {
          var t = e.get("target"),
            o = this._getGeoObjectIndex(t);
          this.events.fire("hide", {
            index: o
          }), this._clearGeoObjectListeners()
        },
        _addItems: function(e) {
          var t = this.getControl(),
            o = t.getResultsArray();
          e && (o = o.slice(e)), i.each(o, this._addItem, this)
        },
        _addItemsDiff: function() {
          var e = this.getControl(),
            t = this.getCollection(),
            o = e.getResultsArray(),
            s = [],
            n = {};
          t.each(function(e) {
            var t = e.properties.get("id");
            t ? n[t] = {
              geoObject: e,
              needToRemove: !0
            } : s.push(e)
          });
          for (var r = 0, l = o.length; r < l; r++) {
            var a = o[r],
              c = a.properties.get("id");
            n[c] ? n[c].needToRemove = !1 : this._addItem(a)
          }
          for (var h in n)
            if (n.hasOwnProperty(h)) {
              var d = n[h];
              d.needToRemove && t.remove(d.geoObject)
            }
          s.length && i.each(s, t.remove, t)
        },
        _addItem: function(e) {
          var t = this.getCollection(),
            o = this.getControl(),
            s = (e.properties.get("type"), o.options.get("geoObjectGeoproductPreset"));
          e.properties.get("advert") && e.options.set("preset", s), t.add(e)
        },
        _getGeoObjectIndex: function(e) {
          var t = this.getControl(),
            o = t.getResultsArray(),
            s = i.indexOf(o, e);
          return s != -1 ? s : this._findGeoObjectIndex(o, e)
        },
        _getInnerGeoObjectIndex: function(e) {
          var t = [],
            o = this.getCollection(),
            s = o.indexOf(e),
            n = e.properties.get("id");
          return s == -1 && "undefined" != typeof n && (o.each(function(e) {
            t.push(e)
          }), s = this._findGeoObjectIndex(t, e)), s
        },
        _findGeoObjectIndex: function(e, t) {
          var o = t.properties.get("id"),
            s = function(e) {
              return e.properties.get("id") == o
            };
          return i.findIndex(e, s)
        }
      }), e(l)
    });
  }],
  [')Q', function(ym) {
    ym.modules.define("control.searchControl.GeocodeProvider", ["control.searchControl.BaseProvider", "control.optionMapper", "map.metaOptions", "yandex.geocodeProvider.storage", "geocode", "util.extend", "vow", "util.defineClass"], function(e, t, r, s, o, i, n, d, a) {
      function c(e) {
        c.superclass.constructor.call(this, e), this._control = e, this.options.setName("geocodeProvider")
      }
      a(c, t, {
        load: function(e, t) {
          if ("string" == typeof e) t = t || {}, t = this._getRequestOptions(this._control.options, t), this._clearData(), this.state.set({
            request: e,
            searchOptions: t
          });
          else {
            if (ym.env.debug && !this.isLoaded()) throw new Error("control.searchControl.Provider: Для дозагрузки данных сначала нужно загрузить запрос");
            var r, s = this.state.get("results", []),
              o = this.options.get("results"),
              a = this.state.get("searchOptions");
            r = {
              skip: s.length,
              results: this._control.options.get("results", o)
            }, t = "object" == typeof e ? n({}, a, r, e) : n({}, a, r), e = this.state.get("request")
          }
          this._deferred && !this._deferred.promise().isResolved() && this._deferred.reject("control.searchControl.GeocodeProvider: New request");
          var c = this._deferred = d.defer();
          return i(e, t).then(function(e) {
            c.promise().isRejected() || (this._onLoad(e), c.resolve(e))
          }, function(e) {
            c.reject(e), this._onLoadError(e)
          }, this), this.events.fire("submit"), c.promise()
        },
        destroy: function() {
          this._clearData(), c.superclass.destroy.call(this)
        },
        getLoadDefer: function() {
          return this._deferred
        },
        _onLoad: function(e) {
          var t = e.metaData.geocoder;
          return this._updateResults(e.geoObjects, t.skip), this.state.set({
            isLoaded: !0,
            request: t.request,
            correction: t.suggest,
            suggest: t.suggest,
            found: t.found,
            results: this.getResults(),
            responseMetaData: t
          }), this.events.fire("load", {
            skip: t.skip,
            count: t.results
          }), e
        },
        _onLoadError: function(e) {
          this.events.fire("error", {
            error: e
          })
        },
        _getRequestOptions: function(e, t) {
          return n({
            provider: e.get("provider"),
            boundedBy: e.get("boundedBy"),
            strictBounds: e.get("strictBounds"),
            kind: e.get("kind"),
            results: e.get("results", this.options.get("results")),
            searchCoordOrder: e.get("searchCoordOrder", this.options.get("coordOrder")),
            origin: "jsapi2searchcontrol"
          }, t)
        },
        _updateResults: function(e, t) {
          var r = t || 0,
            s = this.state.get("results", []);
          e.each(function(e) {
            s[r] = e, r++
          }), this.state.set("results", s)
        },
        _clearData: function() {
          this.state.unsetAll()
        }
      }), r.setRule({
        name: "geocodeProvider",
        rule: ["prefixed"]
      }), r.setRule({
        name: "geocodeProvider",
        key: ["adjustMapMargin"],
        rule: ["prefixed", "plain"]
      }), s.set({
        searchControlGeocodeProviderProviderStorage: o,
        searchControlGeocodeProviderCoordOrder: "latlong",
        searchControlGeocodeProviderResults: 10,
        searchControlGeocodeProviderSuggestResults: 5
      }), e(c)
    });
  }],
  [')I', function(ym) {
    ym.modules.define("control.searchControl.SearchProvider", ["control.searchControl.BaseProvider", "control.optionMapper", "map.metaOptions", "search", "yandex.searchProvider.storage", "localization.common.current", "formatter", "util.array", "yandex.counter", "util.cancelableCallback", "util.extend", "vow", "util.defineClass", "meta.internal"], function(e, t, s, o, r, n, i, a, l, d, u, h, c, p, g) {
      function _(e) {
        _.superclass.constructor.call(this, e), this._control = e, this.options.setName("searchProvider"), this._isLoadMoreRequest = null, this._requestCallback = null, this._setupListeners(), d.countByKey("modulesUsage", "searchProvider.create")
      }
      var v = "loadmore",
        b = "boundschange",
        f = i.ppo.Card;
      p(_, t, {
        getType: function() {
          return "search"
        },
        load: function(e, t) {
          var s = this._control.options;
          if (d.countByKey("business_search", "search." + (e && e.type || "direct")), "string" == typeof e) t = t || {}, t = this._getRequestOptions(s, t), this._clearData(), this.state.set({
            request: e,
            searchOptions: t
          });
          else {
            if (ym.env.debug && !this.isLoaded()) throw new Error("control.searchControl.SearchProvider: Для дозагрузки данных сначала нужно загрузить запрос");
            var o, n = this.state,
              i = n.get("requestContext"),
              a = n.get("display"),
              l = n.get("searchOptions"),
              p = this.options.get("results"),
              g = n.get("results", []).length,
              _ = h({}, l, {
                context: i
              }),
              b = this._control.getMap();
            this._isLoadMoreRequest = e && e.type == v, !this._isLoadMoreRequest && b && (_.boundedBy = b.getBounds(), l.boundedBy = _.boundedBy), ("multiple" != a || this._isLoadMoreRequest) && (o = e && e.results ? e.results : this._isLoadMoreRequest ? s.get("loadMoreResults") : s.get("results", p), h(_, {
              results: o,
              skip: g
            })), t = "object" == typeof e ? h(_, e) : _, e = this.state.get("request")
          }
          this._deferred && !this._deferred.promise().isResolved() && this._deferred.reject("control.searchControl.SearchProvider: new request.");
          var f = this._deferred = c.defer();
          return this._requestCallback = u.create(function(e) {
            f.promise().isRejected() || (this._onLoad(e), f.resolve(e))
          }, this), r(e, t, "searchProvider").then(this._requestCallback, function(e) {
            f.reject(e), this._onLoadError(e)
          }, this), this.events.fire("submit"), f.promise()
        },
        destroy: function() {
          this._clearData(), this._clearListeners(), _.superclass.destroy.call(this)
        },
        getLoadDefer: function() {
          return this._deferred
        },
        _clearData: function() {
          this._isLoadMoreRequest = null, this.state.unsetAll()
        },
        _setupListeners: function() {
          var e = this._control;
          e.getMap() && this._setupMapListeners(), this._controlListeners = e.events.group().add("mapchange", this._onMapChange, this)
        },
        _clearListeners: function() {
          this._clearMapListeners(), this._controlListeners.removeAll()
        },
        _setupMapListeners: function() {
          var e = this._control.getMap();
          this._mapListeners = e.events.group().add("boundschange", this._onBoundsChange, this).add("balloonopen", this._onMapBalloonOpen, this)
        },
        _clearMapListeners: function() {
          this._mapListeners && this._mapListeners.removeAll()
        },
        _onMapChange: function(e) {
          var t = e.get("newMap");
          this._clearMapListeners(), t && this._setupMapListeners()
        },
        _onBoundsChange: function() {
          var e = this._control,
            t = this.state.get("display"),
            s = e.getMap();
          !this.isLoaded() || "multiple" != t || e.state.get("processing") || s.balloon.isOpen() || this.load({
            type: b
          })
        },
        _onMapBalloonOpen: function() {
          this._deferred && !this._deferred.promise().isResolved() && this._requestCallback.cancel()
        },
        _getRequestOptions: function(e, t) {
          var s = this._control.getMap();
          return "undefined" == typeof t.boundedBy && s && (t.boundedBy = s.getBounds()), h({
            provider: e.get("provider"),
            boundedBy: e.get("boundedBy"),
            results: e.get("results", this.options.get("results")),
            searchCoordOrder: e.get("searchCoordOrder", this.options.get("coordOrder")),
            origin: "jsapi2SearchControl"
          }, t)
        },
        _onLoad: function(e) {
          var t, s = e.geoObjects,
            o = s.properties.getAll(),
            r = o.resultsArray.slice();
          return "multiple" != o.display || this._isLoadMoreRequest ? (l.each(r, this._prepareItem, this), t = this.state.get("results", []), t = t.concat(r)) : (t = r, l.each(t, this._prepareItem, this)), this.state.set(h({}, o, {
            isLoaded: !0,
            results: t,
            correction: o.suggest
          })), this.events.fire("load", {
            skip: o.skip || 0,
            count: o.results
          }), o.counter && d.directCount(o.counter), e
        },
        _onLoadError: function(e) {
          this.events.fire("error", {
            error: e
          })
        },
        _prepareItem: function(e) {
          e.properties.set("displayAdvert", g.displayAdvert);
          var t = e.properties.get("type");
          "business" == t && (this._setLocalization(e), this._setBalloonOptions(e)), "public-map-object" != t && "toponym" != t || this._setBalloonOptions(e)
        },
        _setLocalization: function(e) {
          var t = e.properties,
            s = t.get("rating.reviews", 0),
            o = t.get("rating.ratings", 0);
          e.properties.set("loc", {
            timeClosedUntil: f.timeClosedUntil.replace("%s", t.get("workingStatus.time", "")),
            timeOpenUntil: f.timeOpenUntil.replace("%s", t.get("workingStatus.time", "")),
            ratingReviews: a.numeral(s, f.ratingReviews),
            ratingRatings: a.numeral(o, f.ratingRatings)
          })
        },
        _setBalloonOptions: function(e) {
          var t = this.options;
          e.options.set({
            balloonContentLayout: t.get("balloonContentLayout"),
            balloonCardStatusLayout: t.get("balloonStatusLayout"),
            balloonCardOpenInYmapsLayout: t.get("balloonOpenInYmapsLayout"),
            balloonCardAddReviewButtonLayout: t.get("balloonAddReviewButtonLayout"),
            balloonCardShowAdvert: t.get("balloonShowAdvert"),
            balloonCardShowReviewLink: t.get("balloonShowReviewLink"),
            balloonCardAddOrgUrl: t.get("balloonAddOrgUrl"),
            balloonMaxHeight: t.get("balloonMaxHeight"),
            balloonMinWidth: t.get("balloonMinWidth"),
            balloonMaxWidth: t.get("balloonMaxWidth")
          }), "business" == e.properties.get("type") && e.options.set("balloonPanelMaxMapArea", t.get("balloonBusinessPanelMaxMapArea"))
        }
      }), s.setRule({
        name: "searchProvider",
        rule: ["prefixed"]
      }), o.set({
        searchControlSearchProviderProviderStorage: n,
        searchControlSearchProviderCoordOrder: "latlong",
        searchControlSearchProviderResults: 20,
        searchControlSearchProviderSuggestResults: 5
      }), e(_)
    });
  }],
  ['3d', function(ym) {
    ym.modules.define("control.Selectable", ["util.defineClass", "control.Base"], function(e, t, s) {
      var i = function(e) {
        i.superclass.constructor.call(this, e), this.state.get("enabled", !0) && this.enable(), this.state.events.add("change", this._onStateChange, this), this._selected = this.state.get("selected"), this._enabled = this.state.get("enabled"), this._setupSelectableEventRules()
      };
      t(i, s, {
        select: function() {
          this.isSelected() || this.state.set("selected", !0)
        },
        deselect: function() {
          this.isSelected() && this.state.set("selected", !1)
        },
        isSelected: function() {
          return this.state.get("selected", !1)
        },
        enable: function() {
          this.state.set("enabled", !0)
        },
        disable: function() {
          this.state.set("enabled", !1)
        },
        isEnabled: function() {
          return this.state.get("enabled", !0)
        },
        _onStateChange: function() {
          this.state.get("selected") != this._selected && (this._selected = this.state.get("selected"), this.events.fire(this._selected ? "select" : "deselect")), this.state.get("enabled") != this._enabled && (this._enabled = this.state.get("enabled"), this.events.fire(this._enabled ? "enable" : "disable"))
        },
        _setupSelectableEventRules: function() {
          this.eventProxy.disableEventFiring("select").setCallback("select", this.select, this).disableEventFiring("deselect").setCallback("deselect", this.deselect, this).disableEventFiring("enable").setCallback("enable", this.enable, this).disableEventFiring("disable").setCallback("disable", this.disable, this)
        }
      }), e(i)
    });
  }],
  ['3g', function(ym) {
    ym.modules.define("control.storage", ["util.Storage"], function(e, o) {
      e(new o)
    });
  }],
  ['3k', function(ym) {
    ym.modules.define("control.TrafficControl", ["control.component.ToolBarButton", "control.component.CollapseOnBlur", "control.Selectable", "control.storage", "Monitor", "control.optionMapper", "traffic.provider.storage", "util.bind", "util.defineClass", "theme.islands.traffic.metaOptions", "layout.define", "traffic.provider.Actual", "traffic.provider.Archive", "traffic.provider.Forecast", "yandex.counter"], function(t, e, i, r, o, s, a, n, h, c, f, d, l, p, v, u) {
      var y = function(t) {
        y.superclass.constructor.call(this, t), this.options.setName("trafficControl"), "undefined" == typeof this.state.get("providerKey") && this.state.set("providerKey", "traffic#actual"), this._providers = {}, this._providerListeners = {}, this._currentProviderKey = null, this._stateMonitor = null, this._setupTrafficLayoutEventRules(), this._trafficShown = this.state.get("trafficShown"), this._expanded = this.state.get("expanded"), this.state.events.add("change", this._onTrafficStateChange, this), this._toolBarButtonComponent = new e(this), this._collapseOnBlurComponent = new i(this)
      };
      c(y, r, {
        onAddToMap: function(t) {
          y.superclass.onAddToMap.call(this, t), this._stateMonitor = new s(this.state).add(["trafficShown", "providerKey"], this._onVisibleProviderChange, this), this.state.get("trafficShown") && this._addProviderToMap(this.state.get("providerKey")), u.countByKey("control", "traffic.create")
        },
        onRemoveFromMap: function(t) {
          this._stateMonitor.removeAll(), y.superclass.onRemoveFromMap.call(this, t), this.state.get("trafficShown") && this._removeProviderFromMap(this.state.get("providerKey"))
        },
        showTraffic: function() {
          this.isTrafficShown() || this.state.set("trafficShown", !0)
        },
        hideTraffic: function() {
          this.isTrafficShown() && this.state.set("trafficShown", !1)
        },
        isTrafficShown: function() {
          return this.state.get("trafficShown")
        },
        expand: function() {
          this.isExpanded() || this.state.set("expanded", !0)
        },
        collapse: function() {
          this.isExpanded() && this.state.set("expanded", !1)
        },
        isExpanded: function() {
          return this.state.get("expanded", !1)
        },
        _setupTrafficLayoutEventRules: function() {
          this.eventProxy.disableEventFiring("showtraffic").setCallback("showtraffic", this.showTraffic, this).disableEventFiring("hidetraffic").setCallback("hidetraffic", this.hideTraffic, this).disableEventFiring("expand").setCallback("expand", this.expand, this).disableEventFiring("collapse").setCallback("collapse", this.collapse, this).disableEventFiring("collapse").setCallback("providerkeychange", function(t) {
            this.state.set("providerKey", t.get("newProviderKey"))
          }, this)
        },
        getProvider: function(t) {
          return t = t || this.state.get("providerKey"), this._providers[t] || (this._providers[t] = this._createProvider(t), this._providerListeners[t] = this._providers[t].events.group().add("mapchange", this._getProviderCallback(t), this)), this._providers[t]
        },
        _createProvider: function(t) {
          var e = n.get(t);
          if (!e && ym.env.debug) throw new Error("control.TrafficControl.getProvider: can't find provider constructor by the key.");
          var i = new e;
          return i.options.setParent(this.options), i
        },
        _getProviderCallback: function(t) {
          return h(function(e) {
            var i = e.get("newMap");
            this._currentProviderKey == t ? i || this.state.get("providerKey") != t || this.state.set("trafficShown", !1) : i && this.state.set("providerKey", t)
          }, this)
        },
        _addProviderToMap: function(t) {
          this._currentProviderKey = t;
          var e = this.getProvider(t);
          e.setMap(this.getMap()), this.events.fire("providerkeychange", {
            newProviderKey: t,
            oldProviderKey: null
          }), u.countByKey("control", "traffic." + t.replace("traffic#", "") + "Provider"), "traffic#archive" == t && u.countByKey("traffic.archive")
        },
        _removeProviderFromMap: function(t) {
          var e = this.getProvider(t);
          e.setMap(null), this._currentProviderKey = null, this.events.fire("providerkeychange", {
            newProviderKey: null,
            oldProviderKey: t
          })
        },
        _changeProvider: function(t, e) {
          var i = this.getProvider(t),
            r = this.getProvider(e);
          i.setMap(null), r.options.setParent(this.options), r.setMap(this.getMap()), this._currentProviderKey = e, this.events.fire("providerkeychange", {
            newProviderKey: e
          }), i.options.setParent(null), u.countByKey("control", "traffic." + e.replace("traffic#", "") + "Provider"), "traffic#archive" == e && u.countByKey("traffic.archive")
        },
        _onVisibleProviderChange: function() {
          this._applyProvider(this.state.get("providerKey"))
        },
        _applyProvider: function(t) {
          var e = this.state,
            i = this._currentProviderKey;
          e.get("trafficShown") ? t != i && (this._providers[i] ? this._changeProvider(i, t) : this._addProviderToMap(t)) : this._removeProviderFromMap(i)
        },
        _onTrafficStateChange: function() {
          this.state.get("expanded") != this._expanded && (this._expanded = this.state.get("expanded"), this.events.fire(this._expanded ? "expand" : "collapse")), this.state.get("trafficShown") != this._trafficShown && (this._trafficShown = this.state.get("trafficShown"), this.events.fire(this._trafficShown ? "showtraffic" : "hidetraffic"))
        }
      }), a.setRule({
        name: "trafficControl",
        rule: ["prefixed", "plain"]
      }), a.setRule({
        name: "routeEditor",
        key: ["adjustMapMargin"],
        rule: ["prefixed", "plain"]
      }), d("islands#trafficControlLayout", "theme.islands.traffic.layout.Control"), d("islets#trafficControlLayout", "theme.islets.traffic.layout.Control"), o.add("trafficControl", y), t(y)
    });
  }],
  ['3n', function(ym) {
    ym.modules.define("control.TypeSelector", ["util.defineClass", "control.ListBox", "control.ListBoxItem", "mapType.storage", "localization.common.current", "control.storage", "util.array", "control.optionMapper", "util.bind", "util.extend", "map.metaOptions", "yandex.counter"], function(e, t, s, p, i, a, r, n, o, l, c, y, m) {
      function h(e) {
        return "string" == typeof e ? i.get(e) : e
      }
      var u = a.Control.TypeControl.layers,
        T = function(e) {
          n.isArray(e) && (e = {
            mapTypes: e
          });
          var t = e && e.data || {};
          T.superclass.constructor.call(this, e), this.data.set(c({
            content: u,
            iconType: "layers"
          }, t)), this._selectedMapType = null, this._mapTypeListItems = [], this._createMapTypeItems(e && e.mapTypes), this.options.setName("typeSelector"), this._mapListeners = null
        };
      t(T, s, {
        addMapType: function(e, t) {
          if (ym.env.debug && !h(e)) throw new Error("TypeSelector: undefined map type " + e);
          if (this._getItem(e)) return this;
          if ("undefined" == typeof t) {
            var s = y.get("typeSelectorMapTypePositions");
            "string" == typeof e && s[e] && (t = s[e])
          }
          var p = this._createItem(e, t),
            i = this.getMap(),
            a = !!i && i.getType() === e;
          return this._mapTypeListItems.push(p), this.add(p.listItem), a && this._selectMapType(i.getType()), this
        },
        removeMapType: function(e) {
          var t = this._getItem(e);
          if (t) {
            t = t.listItem, e = t.mapType;
            for (var s = this.getMap(), p = !!s && s.getType() === e, i = 0; this._mapTypeListItems[i].listItem != t;) i++;
            this._mapTypeListItems[i].listener.removeAll(), this._mapTypeListItems.splice(i, 1), this.remove(t), p && this._selectMapType(null)
          }
          return this
        },
        removeAllMapTypes: function() {
          for (; this._mapTypeListItems.length;) this.removeMapType(this._mapTypeListItems[0].mapType);
          return this
        },
        onAddToMap: function(e) {
          T.superclass.onAddToMap.call(this, e), this._mapListeners = e.events.group().add("typechange", function(t) {
            this._selectMapType(e.getType())
          }, this);
          var t = this.isExpanded();
          this._selectMapType(e.getType()), t && this.expand(), m.countByKey("control", "typeSelector.create")
        },
        onRemoveFromMap: function(e) {
          this._mapListeners.removeAll(), T.superclass.onRemoveFromMap.call(this, e)
        },
        _createMapTypeItems: function(e) {
          e || (e = y.get("typeSelectorMapTypes"));
          for (var t = 0, s = e.length; t < s; ++t) this.addMapType(e[t])
        },
        _getItem: function(e) {
          for (var t, s = 0, p = this._mapTypeListItems.length; s < p; ++s)
            if (t = this._mapTypeListItems[s], t.mapType === e) return t;
          return null
        },
        _selectMapType: function(e) {
          var t = !1;
          if (this._selectedMapType) {
            var s = this._getItem(this._selectedMapType);
            s && s.listItem.deselect(), t = !0
          }
          if (this._selectedMapType = e, e) {
            var p = this._getItem(e);
            p && p.listItem.select()
          } else t = !1;
          t && m.countByKey("control", "typeSelector." + typeof e == "string" ? e.replace(/[^A-Za-z]/g, "_") : "other")
        },
        _createItem: function(e, t) {
          var s = new p({
            data: {
              content: h(e).getName(),
              mapType: e
            },
            options: {
              positionIndex: t,
              selectOnClick: !0
            }
          });
          s.deselect = l(function() {
            return this.getMap() && e == this.getMap().getType() ? void this.collapse() : void p.prototype.deselect.call(s)
          }, this);
          var i = s.events.group().add(["select"], function() {
            var t = this.getMap();
            t.getType() != e && ("string" == typeof e && m.countByKey("control", "typeSelector." + e.replace(/[^A-Za-z]/g, "_")), this.getMap().setType(e)), this.collapse()
          }, this);
          return {
            mapType: e,
            listItem: s,
            listener: i
          }
        }
      }), o.setRule({
        name: "typeSelector",
        rule: ["prefixed", "plain"]
      }), o.setRule({
        name: "routeEditor",
        key: ["adjustMapMargin"],
        rule: ["prefixed", "plain"]
      }), r.add("typeSelector", T), e(T)
    });
  }],
  ['3r', function(ym) {
    ym.modules.define("control.ZoomControl", ["util.defineClass", "control.storage", "control.Base", "control.optionMapper", "Monitor", "map.action.Continuous", "layout.define", "yandex.counter"], function(t, o, e, n, a, i, s, h, m) {
      var r = function(t) {
        r.superclass.constructor.call(this, t), this.options.setName("zoomControl"), this._map = null, this._mapListeners = null, this._zoomRangeListeners = null, this._mapAction = null;
        var o = this.options.get("size");
        this.state.set("size", "auto" == o ? "small" : o)
      };
      o(r, n, {
        onAddToMap: function(t) {
          this._map = t, this.state.set({
            zoom: this._map.getZoom(),
            zoomRange: this._map.zoomRange.getCurrent(),
            mapHeight: this._map.container.getSize()[1] - this._map.state.get("margin", [0, 0, 0, 0])[2]
          }), r.superclass.onAddToMap.call(this, t), this._setupLayoutEventRules(), this._setupZoomListeners(), m.countByKey("control", "zoom.create")
        },
        onRemoveFromMap: function(t) {
          this._clearZoomListeners(), r.superclass.onRemoveFromMap.call(this, t)
        },
        _setupZoomListeners: function() {
          this._mapListeners = this._map.events.group().add("sizechange", this._onMapSizeChange, this).add("boundschange", this._onMapBoundsChange, this), this._mapMarginMonitor = new i(this._map.state).add("margin", this._onMapSizeChange, this), this._zoomRangeListeners = this._map.zoomRange.events.group().add("change", this._onZoomRangeChange, this)
        },
        _clearZoomListeners: function() {
          this._mapListeners.removeAll(), this._mapMarginMonitor.removeAll(), this._zoomRangeListeners.removeAll()
        },
        _setupLayoutEventRules: function() {
          this.eventProxy.disableEventFiring("zoomchange").disableEventFiring("dragstart").disableEventFiring("dragstop"), this.eventProxy.setCallback("zoomchange", this._onZoomChange, this).setCallback("dragstart", this._onDragStart, this).setCallback("dragstop", this._onDragStop, this)
        },
        _onDragStart: function() {
          this._dragging = !0, this._initialZoom = this._map.getZoom(), m.countByKey("control", "zoom.drag")
        },
        _onDragStop: function() {
          this._dragging = !1, this._mapAction && (this._mapAction.end(), this._mapAction = null), m.countByKey("control", "zoom.change." + Math.abs(Math.round(this._map.getZoom() - this._initialZoom)))
        },
        _onZoomRangeChange: function(t) {
          this.state.set("zoomRange", t.get("newZoomRange"))
        },
        _onMapBoundsChange: function(t) {
          var o = t.get("newZoom"),
            e = t.get("oldZoom");
          !this._dragging && Math.abs(o - e) > .001 && this.state.set("zoom", o)
        },
        _onZoomChange: function(t) {
          var o = t.get("newZoom");
          if (this._dragging) this._mapAction || (this._mapAction = new s, this._map.action.execute(this._mapAction)), this._mapAction.tick({
            zoom: o
          });
          else if (this._map.options.get("avoidFractionalZoom") && (o = Math.floor(o)), Math.abs(o - this.state.get("zoom")) > .001) {
            var e = this._map.getZoom();
            this.state.set("zoom", o), this._map.setZoom(o, {
              duration: this.options.get("zoomDuration")
            }), m.countByKey("control", "zoom.change." + Math.abs(Math.round(o - e)))
          }
        },
        _onMapSizeChange: function() {
          this.state.set("mapHeight", this._map.container.getSize()[1] - this._map.state.get("margin", [0, 0, 0, 0])[2])
        }
      }), a.setRule({
        name: "zoomControl",
        rule: "prefixed"
      }), a.setRule({
        name: "zoomControl",
        key: ["adjustMapMargin"],
        rule: ["prefixed", "plain"]
      }), e.add("zoomControl", r), h("islands#zoomLayout", "theme.islands.control.layout.Zoom"), t(r)
    });
  }],
  ['9Q', function(ym) {
    ym.modules.define("coordSystem.cartesian", ["coordSystem.Cartesian"], function(e, n) {
      e(new n(1))
    });
  }],
  ['9z', function(ym) {
    ym.modules.define("coordSystem.Cartesian", ["util.extend"], function(t, n) {
      function e(t) {
        t = t || [1, 1], this._scale = "number" == typeof t ? [t, t] : t
      }

      function i(t) {
        var n = Math.sqrt(Math.pow(t[0], 2) + Math.pow(t[1], 2));
        return [t[0] / n, t[1] / n]
      }
      n(e.prototype, {
        solveDirectProblem: function(t, n, e) {
          n = i(n);
          var o = n[0] * e / this._scale[0],
            r = n[1] * e / this._scale[1];
          return {
            startPoint: t,
            startDirection: n,
            endPoint: [t[0] + o, t[1] + r],
            endDirection: n,
            distance: e,
            pathFunction: function(e) {
              return {
                point: [t[0] + o * e, t[1] + r * e],
                direction: n
              }
            }
          }
        },
        solveInverseProblem: function(t, n) {
          var e = n[0] - t[0],
            i = n[1] - t[1],
            o = this._getUnitDistance(t, n),
            r = [e / o, i / o];
          return {
            startPoint: t,
            startDirection: r,
            endPoint: n,
            endDirection: r,
            distance: this.getDistance(t, n),
            pathFunction: function(n) {
              return {
                point: [t[0] + e * n, t[1] + i * n],
                direction: r
              }
            }
          }
        },
        getDistance: function(t, n) {
          return Math.sqrt(Math.pow((n[0] - t[0]) * this._scale[0], 2) + Math.pow((n[1] - t[1]) * this._scale[1], 2))
        },
        _getUnitDistance: function(t, n) {
          return Math.sqrt(Math.pow(n[0] - t[0], 2) + Math.pow(n[1] - t[1], 2))
        }
      }), e.prototype.distance = e.prototype.getDistance, t(e)
    });
  }],
  ['3t', function(ym) {
    ym.modules.define("coordSystem.geo", ["util.math.cycleRestrict"], function(t, a) {
      var n = ym.env.coordinatesOrder,
        h = function(t) {
          return t < 0 ? -1 : t > 0 ? 1 : 0
        },
        M = 6378137,
        s = .00669437999014,
        i = 1 - Math.sqrt(1 - s),
        o = (1 - i) * M,
        c = 1e-10,
        e = function(t) {
          return t * t
        },
        r = function(t) {
          return Math.abs(t - h(t) * Math.PI / 2) < c ? h(t) * Math.PI / 2 : Math.atan((1 - i) * Math.tan(t))
        },
        l = function(t) {
          return [t[1], t[0]]
        },
        P = function(t) {
          return Math.max(Math.min(t, 89.999), -89.999)
        },
        u = {
          solveDirectProblem: function(t, s, e) {
            "longlat" == n && (t = l(t), s = l(s)), t[0] = P(t[0]);
            var r = t[0] * Math.PI / 180,
              u = t[1] * Math.PI / 180,
              d = Math.sqrt(s[0] * s[0] + s[1] * s[1]),
              I = s[0] / d,
              v = s[1] / d,
              f = (1 - i) * Math.tan(r),
              g = h(Math.cos(r)) * Math.sqrt(1 / (1 + f * f)),
              m = Math.sqrt(1 - g * g) * h(f),
              D = Math.atan2(f, I),
              b = g * v,
              q = (1 - b) * (1 + b),
              p = q * (M * M / (o * o) - 1),
              y = 1 + p * (4096 + p * (-768 + p * (320 - 175 * p))) / 16384,
              w = p * (256 + p * (-128 + p * (74 - 47 * p))) / 1024,
              x = function(t) {
                var h, M = e * t,
                  s = M / (o * y),
                  r = D + s / 2,
                  P = Math.cos(2 * r),
                  d = 0,
                  f = 0;
                do {
                  var p = w * Math.sin(s) * (P + .25 * w * (Math.cos(s) * (-1 + 2 * P * P) - 1 / 6 * w * P * (-3 + 4 * Math.sin(s) * Math.sin(s)) * (-3 + 4 * P * P))),
                    h = p - f;
                  f = p, s = M / (o * y) + p, d++
                } while (Math.abs(h) > c && d < 10);
                var x = m * Math.sin(s) - g * Math.cos(s) * I,
                  F = Math.atan2(m * Math.cos(s) + g * Math.sin(s) * I, (1 - i) * Math.sqrt(b * b + x * x)),
                  O = Math.atan2(Math.sin(s) * v, g * Math.cos(s) - m * Math.sin(s) * I),
                  R = i / 16 * q * (4 + i * (4 - 3 * q)),
                  S = O - (1 - R) * i * b * (s + R * Math.sin(s) * (P + R * Math.cos(s) * (-1 + 2 * P * P))),
                  j = Math.atan2(b, -m * Math.sin(s) + g * Math.cos(s) * I),
                  k = [180 * F / Math.PI, a(180 * (u + S) / Math.PI, -180, 180)],
                  z = [Math.cos(j), Math.sin(j)];
                return {
                  point: "longlat" == n ? l(k) : k,
                  direction: "longlat" == n ? l(z) : z
                }
              },
              F = x(1);
            return {
              startPoint: "longlat" == n ? l(t) : t,
              startDirection: "longlat" == n ? l(s) : s,
              endPoint: F.point,
              endDirection: F.direction,
              distance: e,
              pathFunction: x
            }
          },
          solveInverseProblem: function(t, s, u) {
            var d, I = this.solveDirectProblem;
            if (t == s || t[0] == s[0] && t[1] == s[1]) d = {
              startPoint: t,
              startDirection: [1, 1],
              endPoint: s,
              endDirection: [1, 1],
              distance: 0
            };
            else {
              "longlat" == n && (t = l(t), s = l(s)), t[0] = P(t[0]), s[0] = P(s[0]);
              var v, f = t[0] * Math.PI / 180,
                g = s[0] * Math.PI / 180,
                m = (s[1] - t[1]) * Math.PI / 180,
                D = r(f),
                b = r(g),
                q = m,
                p = q,
                y = 0,
                w = [],
                x = [],
                F = 0;
              if (0 == f && 0 == g) {
                var O = a(s[1] - t[1], u ? -360 : -180, u ? 360 : 180);
                w = x = [0, O > 0 ? 1 : -1], F = 2 * Math.PI * M / 360 * Math.abs(O)
              } else {
                var R, S, j, k, z, A, B;
                do R = Math.sqrt(e(Math.cos(b) * Math.sin(q)) + e(Math.cos(D) * Math.sin(b) - Math.sin(D) * Math.cos(b) * Math.cos(q))), S = Math.sin(D) * Math.sin(b) + Math.cos(D) * Math.cos(b) * Math.cos(q), z = u ? 2 * Math.PI - Math.atan2(R, S) : Math.atan2(R, S), j = Math.cos(D) * Math.cos(b) * Math.sin(q) / Math.sin(z), k = 1 - e(j), A = Math.cos(z) - 2 * Math.sin(D) * Math.sin(b) / k, B = i / 16 * k * (4 + i * (4 - 3 * k)), q = Math.min(Math.max(m + (1 - B) * i * j * (z + B * Math.sin(z) * (A + B * Math.cos(z) * (-1 + 2 * A * A))), -2 * Math.PI), 2 * Math.PI), v = Math.abs(p - q), p = q, y++; while (v > c && y < 10);
                var C = k * (M * M - o * o) / (o * o),
                  E = 1 + C * (4096 + C * (-768 + C * (320 - 175 * C))) / 16384,
                  G = C * (256 + C * (-128 + C * (74 - 47 * C))) / 1024,
                  H = G * Math.sin(z) * (A + .25 * G * (Math.cos(z) * (-1 + 2 * A * A) - 1 / 6 * G * A * (-3 + 4 * Math.sin(z) * Math.sin(z)) * (-3 + 4 * A * A))),
                  J = Math.atan2(Math.cos(b) * Math.sin(q), Math.cos(D) * Math.sin(b) - Math.sin(D) * Math.cos(b) * Math.cos(q)),
                  K = Math.atan2(Math.cos(D) * Math.sin(q), -Math.sin(D) * Math.cos(b) + Math.cos(D) * Math.sin(b) * Math.cos(q));
                F = o * E * (z - H), u && (J -= h(J - Math.PI) * Math.PI, K -= h(K - Math.PI) * Math.PI), w = [Math.cos(J), Math.sin(J)], x = [Math.cos(K), Math.sin(K)]
              }
              d = {
                startPoint: "longlat" == n ? l(t) : t,
                startDirection: "longlat" == n ? l(w) : w,
                endPoint: "longlat" == n ? l(s) : s,
                endDirection: "longlat" == n ? l(x) : x,
                distance: F
              }
            }
            return d.pathFunction = function(t) {
              var a = I(d.startPoint, d.startDirection, d.distance * t);
              return {
                point: a.endPoint,
                direction: a.endDirection
              }
            }, d
          },
          getDistance: function(t, a) {
            return this.solveInverseProblem(t, a).distance
          }
        };
      u.distance = u.getDistance, t(u)
    });
  }],
  ['1y', function(ym) {
    ym.modules.define("copyright", function(n) {
      return [this.name + (n.env.browser.oldIE ? ".ie8" : ".standards")]
    }, function(n) {
      n({})
    });
  }],
  ['1D', function(ym) {
    ym.modules.define("copyright__logo", function(n) {
      return [this.name + (n.env.browser.oldIE ? ".ie8" : ".standards")]
    }, function(n) {
      n({})
    });
  }],
  ['6e', function(ym) {
    ym.modules.define('copyright__logo.standards', ['system.provideCss'], function(provide, provideCss) {
      provideCss(".ymaps-2-1-42-copyright__logo{display:block;width:46px;height:20px;position:relative;top:-2px;opacity:.7;background-position:0 100%;background-repeat:no-repeat;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0NS45OSIgaGVpZ2h0PSIyMC4wMiIgdmlld0JveD0iMC4wMSAtMS4wMjMgNDUuOTg5IDIwLjAyMSI+PHBhdGggZmlsbD0icmVkIiBkPSJNOC43NyAxSDYuNTJDNC4zIDEgMi40NCAyLjY3IDIuNDQgNS45NWMwIDEuOTcuOSAzLjQyIDIuNTIgNC4xNGwtMy4wMiA1LjQ4Yy0uMS4xOCAwIC4zMi4xNi4zMmgxLjRjLjEyIDAgLjItLjA0LjI0LS4xNGwyLjc0LTUuMzloLjk5djUuNGMwIC4wNS4wNi4xMy4xMy4xM2gxLjIzYy4xMiAwIC4xNi0uMDYuMTYtLjE2VjEuMmMwLS4xNC0uMDktLjItLjIyLS4yem0tMS4zIDguMWgtLjg0Yy0xLjMgMC0yLjU2LS45NS0yLjU2LTMuMzQgMC0yLjQ4IDEuMTgtMy41IDIuMzktMy41aDFWOS4xeiIvPjxwYXRoIGQ9Ik0xNi4xOCA1LjkzaC0xLjIyYy0uMSAwLS4xNi4wOC0uMTYuMTR2My44aC0yLjI3di0zLjhjMC0uMS0uMDQtLjE0LS4xNC0uMTRoLTEuMjJjLS4xIDAtLjE2LjA2LS4xNi4xNHY5LjY2YzAgLjEuMDQuMTYuMTQuMTZoMS4yNGMuMDggMCAuMTQtLjA2LjE0LS4xNnYtNC42aDIuMjd2NC42YzAgLjEuMDYuMTYuMTYuMTZoMS4yMmMuMSAwIC4xNC0uMDguMTQtLjE2VjYuMDdhLjEzLjEzIDAgMCAwLS4xNC0uMTR6bTI3LjkyIDkuMzNsLS4xNi0uNjgtLjEtLjA4Yy0uMSAwLS42My4yMi0xLjQuMjItMS41IDAtMi4yMi0xLjQ1LTIuMjItMy43NSAwLTIuMDMuNi00LjA0IDEuNjMtNC4wNC4yOCAwIC42Mi4wOCAxLjE1LjU4LjA2LjA2LjEuMDguMTUuMDguMDYgMCAuMTItLjA0LjE4LS4xNGwuNTMtLjg4LjA3LS4xOGMwLS4wOC0uMDgtLjE0LS4yLS4yYTMuNzkgMy43OSAwIDAgMC0xLjg0LS41Yy0xLjg1IDAtMy4zIDIuMjMtMy4zIDUuNzEgMCAzIDEuMzkgNC43MyAzLjM2IDQuNzMuODMgMCAxLjcyLS40IDIuMDctLjY1LjA4LS4wNi4xLS4xNC4wOC0uMjJ6bS04LjU3LTQuODNsMi4zNi00LjM2Yy4wNS0uMDYuMDItLjE0LS4wNS0uMTRoLTEuMTdjLS4zMyAwLS40NS4xMi0uNTcuMzhsLTEuNzcgMy43MmMtLjEuMjItLjIuMzYtLjMuNDJWNi4wN2MwLS4wOC0uMDQtLjE0LS4xMi0uMTRoLTEuMjhjLS4wNiAwLS4xMi4wNi0uMTIuMTR2OS42OGMwIC4wNi4wNC4xNC4xMi4xNGgxLjI4Yy4wOCAwIC4xMi0uMDYuMTItLjE0di00Ljk5Yy4wNi4wNC4xLjEuMTQuMThsMi4yNSA0LjY1Yy4xMS4yNC4zLjMuNTUuM2gxLjI2Yy4wOCAwIC4xLS4wOC4wNi0uMTRsLTIuNzYtNS4zM3ptLTExLjMgNC4yMWgtLjI0Yy0uMyAwLS4zNy0uMTItLjM3LS4zNnYtOC4yYzAtLjEtLjA0LS4xNS0uMTItLjE1aC0zLjk0Yy0uMSAwLS4xNi4wNi0uMTYuMTR2LjcyYzAgMi40LS4xNCA1LjUtMS40IDcuODVoLS40NGMtLjExIDAtLjE1LjA2LS4xNS4xNnYyLjljMCAuMS4wNy4xNC4xMy4xNGguOTVjLjIyIDAgLjMtLjE2LjMtLjNWMTUuOUgyM3YxLjgxYzAgLjA4LjA3LjE0LjE0LjE0aDFjLjEzIDAgLjI1LS4xLjI1LS4zVjE0LjhjMC0uMS0uMDYtLjE2LS4xNi0uMTZ6bS0yLjEzIDBoLTIuODZjMS0xLjczIDEuNC0zLjY4IDEuNTQtNi4wNi4wNC0uNTIuMDYtMS4wNS4wNi0xLjRoMS4yNnY3LjQ2em02LjE1LTguOTVjLTIuMTMgMC0zLjA4IDIuNy0zLjA4IDUuNjUgMCAzIDEuMzUgNC43OSAzLjMyIDQuNzkuOTYgMCAxLjgxLS4zOCAyLjI0LS42Ni4wOC0uMDQuMS0uMS4wOC0uMTdsLS4xNS0uNjhjLS4wMy0uMDgtLjA2LS4xMi0uMTYtLjEyLS4wOCAwLS42NS4yMi0xLjQ2LjIyLTEuNTIgMC0yLjIzLTEuMzMtMi4yMy0zLjA4di0uNDdzLjc3LjA5IDEuMjMuMDloMi44N3YtLjg0YzAtMy4wOC0xLjA4LTQuNzMtMi42Ni00Ljczem0tLjIxIDQuMzJjLS40NiAwLTEuMTcuMDgtMS4xNy4wOHMwLS4zLjA0LS42MmMuMTgtMS42OS42LTIuNTQgMS4yOC0yLjU0LjY0IDAgMS4wMy44NyAxLjEzIDIuNC4wMi4zMi4wMi42OC4wMi42OGgtMS4zeiIvPjwvc3ZnPg==)}.ymaps-2-1-42-copyright_color_white .ymaps-2-1-42-copyright__logo{opacity:.95;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0NS45OSIgaGVpZ2h0PSIyMC4wMiIgdmlld0JveD0iMC4wMSAtMS4wMjMgNDUuOTg5IDIwLjAyMSI+PHBhdGggZD0iTTguNzcgMUg2LjUyQzQuMyAxIDIuNDMgMi42NyAyLjQzIDUuOTVjMCAxLjk3LjkxIDMuNDIgMi41MyA0LjE0bC0zLjAyIDUuNDhjLS4xLjE4IDAgLjMyLjE2LjMyaDEuNGMuMTIgMCAuMi0uMDQuMjQtLjE0bDIuNzQtNS4zOWguOTl2NS40YzAgLjA1LjA1LjEzLjEzLjEzaDEuMjNjLjEyIDAgLjE2LS4wNi4xNi0uMTZWMS4yYzAtLjE0LS4wOS0uMi0uMjItLjJ6bS0xLjMgOC4xaC0uODRjLTEuMyAwLTIuNTYtLjk1LTIuNTYtMy4zNCAwLTIuNDggMS4xOC0zLjUgMi4zOS0zLjVoMVY5LjF6bTguNzEtMy4xN2gtMS4yMmMtLjEgMC0uMTYuMDgtLjE2LjE0djMuOGgtMi4yN3YtMy44YzAtLjEtLjA0LS4xNC0uMTQtLjE0aC0xLjIyYy0uMSAwLS4xNi4wNi0uMTYuMTR2OS42NmMwIC4xLjA0LjE2LjE0LjE2aDEuMjRjLjA4IDAgLjE0LS4wNi4xNC0uMTZ2LTQuNmgyLjI3djQuNmMwIC4xLjA1LjE2LjE1LjE2aDEuMjNjLjEgMCAuMTMtLjA4LjEzLS4xNlY2LjA3YS4xMy4xMyAwIDAgMC0uMTMtLjE0em0yNy45MiA5LjMzbC0uMTYtLjY4LS4xLS4wOGMtLjEgMC0uNjMuMjItMS40LjIyLTEuNSAwLTIuMjItMS40NS0yLjIyLTMuNzUgMC0yLjAzLjYtNC4wNCAxLjYzLTQuMDQuMjggMCAuNjIuMDggMS4xNS41OC4wNi4wNi4xLjA4LjE1LjA4cy4xMi0uMDQuMTgtLjE0bC41My0uODguMDctLjE4YzAtLjA4LS4wOC0uMTQtLjItLjJhMy43OSAzLjc5IDAgMCAwLTEuODQtLjVjLTEuODUgMC0zLjMgMi4yMy0zLjMgNS43MSAwIDMgMS4zOSA0LjczIDMuMzYgNC43My44MyAwIDEuNzItLjQgMi4wNy0uNjUuMDgtLjA2LjEtLjE0LjA4LS4yMnptLTguNTctNC44M2wyLjM2LTQuMzZjLjA1LS4wNi4wMi0uMTQtLjA1LS4xNGgtMS4xN2MtLjMzIDAtLjQ1LjEyLS41Ny4zOGwtMS43NyAzLjcyYy0uMS4yMi0uMi4zNi0uMy40MlY2LjA3YzAtLjA4LS4wNC0uMTQtLjEyLS4xNGgtMS4yOGMtLjA2IDAtLjEyLjA2LS4xMi4xNHY5LjY4YzAgLjA2LjA0LjE0LjEyLjE0aDEuMjhjLjA4IDAgLjEyLS4wNi4xMi0uMTR2LTQuOTljLjA2LjA0LjEuMS4xNC4xOGwyLjI1IDQuNjVjLjEyLjI0LjMuMy41NS4zaDEuMjZjLjA4IDAgLjEtLjA4LjA2LS4xNGwtMi43Ni01LjMzem0tMTEuMyA0LjIxaC0uMjRjLS4zIDAtLjM4LS4xMi0uMzgtLjM2di04LjJjMC0uMS0uMDMtLjE1LS4xMS0uMTVoLTMuOTVjLS4xIDAtLjE2LjA2LS4xNi4xNHYuNzJjMCAyLjQtLjEzIDUuNS0xLjQgNy44NWgtLjQzYy0uMTIgMC0uMTYuMDYtLjE2LjE2djIuOWMwIC4xLjA4LjE0LjE0LjE0aC45NWMuMjEgMCAuMy0uMTYuMy0uM1YxNS45SDIzdjEuODFjMCAuMDguMDYuMTQuMTQuMTRoMWMuMTMgMCAuMjUtLjEuMjUtLjNWMTQuOGMwLS4xLS4wNi0uMTYtLjE2LS4xNnptLTIuMTMgMGgtMi44NmMxLTEuNzMgMS40LTMuNjggMS41NC02LjA2LjA0LS41Mi4wNi0xLjA1LjA2LTEuNGgxLjI2djcuNDZ6bTYuMTUtOC45NWMtMi4xMyAwLTMuMDggMi43LTMuMDggNS42NSAwIDMgMS4zNCA0Ljc5IDMuMzIgNC43OS45NiAwIDEuOC0uMzggMi4yNC0uNjYuMDgtLjA0LjEtLjEuMDgtLjE3bC0uMTYtLjY4Yy0uMDItLjA4LS4wNi0uMTItLjE1LS4xMi0uMDggMC0uNjUuMjItMS40Ni4yMi0xLjUyIDAtMi4yMy0xLjMzLTIuMjMtMy4wOHYtLjQ3cy43Ny4wOSAxLjIyLjA5aDIuODh2LS44NGMwLTMuMDgtMS4wOC00LjczLTIuNjYtNC43M3ptLS4yMSA0LjMyYy0uNDYgMC0xLjE3LjA4LTEuMTcuMDhzMC0uMy4wNC0uNjJjLjE4LTEuNjkuNi0yLjU0IDEuMjgtMi41NC42NCAwIDEuMDMuODcgMS4xMyAyLjQuMDIuMzIuMDIuNjguMDIuNjhoLTEuM3oiIGZpbGw9IiNmZmYiLz48L3N2Zz4=)}.ymaps-2-1-42-copyright .ymaps-2-1-42-copyright__logo:hover{opacity:1}.ymaps-2-1-42-copyright__logo_lang_en{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0NS45OSIgaGVpZ2h0PSIyMC4wMiIgdmlld0JveD0iMC4wMSAtMS4wMjMgNDUuOTg5IDIwLjAyMSI+PHBhdGggZD0iTTEyLjYzIDUuNzhjLS42MSAwLTEuNTMuMjMtMi4xMy41LS4xNy4wNy0uMjYuMTUtLjE1LjRsLjQzLjg3Yy4wMy4xLjEuMTMuMTUuMTNsLjE4LS4wNmMuNjEtLjQgMS4wNC0uNiAxLjQtLjYuNDYgMCAuNzYuMy45NC43NS4yLjQ0LjI2IDEuMDUuMjYgMS43M3YuMmEzLjQzIDMuNDMgMCAwIDAtMS4zOC0uMzZjLTEuNzUgMC0yLjcgMS42OC0yLjcgMy40NyAwIDEuOTYgMS4xMiAzLjM2IDIuNDQgMy4zNi43NSAwIDEuNDItLjQzIDEuODctLjk3bC4yNS42Yy4wNC4xMS4xLjEzLjIuMTNoLjcxYy4wNiAwIC4xMy0uMDQuMTMtLjE1VjEwLjJjMC0xLjM4LS4xLTIuNDMtLjQ1LTMuMTNhMi4yOSAyLjI5IDAgMCAwLTIuMTUtMS4yOXptMS4wOCA4LjU5Yy0uMzcuMzYtLjc3LjUzLTEuMTUuNTMtMS4wNiAwLTEuMy0xLjMtMS4zLTIuMTkgMC0xLjA1LjQtMi4xMyAxLjItMi4xMy40IDAgLjg2LjEgMS4yNS40M3YzLjM2em02LjgyLTguNDZjLS45NyAwLTEuOTYuNzItMS45Ni43MnYtLjQ3YzAtLjA4LS4wNy0uMTUtLjEzLS4xNWgtMS4yNWEuMTUuMTUgMCAwIDAtLjE0LjE1djkuNjJjMCAuMS4wMi4xNS4xNC4xNWgxLjI1Yy4wNiAwIC4xMy0uMDYuMTMtLjE1VjcuNTNzLjU3LS4zNSAxLjI5LS4zNWMuNjUgMCAxLjE3LjMzIDEuMTcgMXY3LjZjMCAuMS4wNy4xNS4xNy4xNWgxLjJjLjE0IDAgLjE1LS4wNi4xNS0uMTVWNy43NWMwLTEuMi0uNzMtMS44NC0yLjAyLTEuODR6bTkuNS00LjgzSDI4LjhjLS4xIDAtLjE0LjA3LS4xNC4xNHY0Ljg2Yy0uNS0uMi0uOTMtLjMtMS4yNS0uMy0yLjAyIDAtMy4zNiAxLjktMy4zNiA1LjU4IDAgMy4xNCAxLjMgNC44MyAzLjA2IDQuODMuNzIgMCAxLjMzLS40MiAxLjc1LS44bC4yNy40NGMuMDUuMDkuMDcuMS4xNy4xaC43NWMuMDggMCAuMTItLjA2LjEyLS4xNVYxLjIyYzAtLjEtLjA0LS4xNC0uMTItLjE0em0tMS4zOSAxMy41Yy0uMzIuMTctLjcuMzItMS4xLjMyLTEuMzMgMC0xLjg4LTEuNTctMS44OC0zLjg2IDAtMi4wMi41Ny00LjAxIDEuOC00LjAxLjM4IDAgLjc4LjE1IDEuMTguNDJ2Ny4xM3ptNi4wOC04LjhjLTIuMTIgMC0zLjA4IDIuNzEtMy4wOCA1LjYzIDAgMi45OCAxLjMzIDQuNzYgMy4zMiA0Ljc2Ljk1IDAgMS44LS4zNyAyLjI2LS42OC4wNi0uMDQuMDgtLjA2LjA2LS4xNWwtLjE1LS42OGMtLjAyLS4wOC0uMDUtLjEzLS4xNC0uMTMtLjEgMC0uNjguMjQtMS40OC4yNC0xLjUyIDAtMi4yMi0xLjM0LTIuMjItMy4wOXYtLjQ3cy43Ni4xIDEuMi4xaDIuOXYtLjgyYzAtMy4wOS0xLjEtNC43MS0yLjY3LTQuNzF6bS0uMjMgNC4yOWMtLjQ0IDAtMS4xNi4xLTEuMTYuMXMwLS4zLjA0LS42M2MuMjItMS42OS41OC0yLjUzIDEuMy0yLjUzLjYyIDAgMS4wMi44NyAxLjExIDIuMzkuMDIuMzIuMDIuNjcuMDIuNjdoLTEuM3ptOS4zNi00LjA2aC0xLjA3Yy0uMTMgMC0uMjEuMDctLjI0LjE3LS4wNS4xNS0uNTMgMS40LS43IDEuODlsLS41MiAxLjRoLS4wNGwtLjQyLTEuMTJjLS4xLS4zMy0uNzEtMS45Mi0uNzktMi4xMi0uMDMtLjEtLjEyLS4yMi0uMjUtLjIyaC0xLjJjLS4xNCAwLS4yLjE1LS4xNS4yNGwxLjkyIDQuNDQtMi4wNyA0Ljk3Yy0uMDcuMTQuMDIuMjcuMTUuMjdoMS4wM2MuMiAwIC4yNS0uMDguMzItLjI1bC43LTEuOS41Mi0xLjY3aC4wNGwuNSAxLjQyLjgzIDIuMmMuMDQuMTIuMTIuMi4yNi4yaDEuMTZjLjEyIDAgLjE5LS4xMy4xMi0uMjUtLjE1LS4yOC0xLjI0LTMuMDQtMi4wNC00LjgyTDQ0IDYuMjVjLjAyLS4xMS4wMi0uMjQtLjE1LS4yNHoiLz48cGF0aCBmaWxsPSJyZWQiIGQ9Ik0xMC45NS0uMjZoLTEuM2MtLjE0IDAtLjIuMDUtLjI0LjE4bC0yLjM5IDYuN2MtLjI4Ljc1LS42IDIuMDQtLjYgMi4wNGgtLjA4cy0uNTItMS41Mi0uNjUtMi4wMUM1LjUgNi4xIDMuODEgMS40NiAzLjc3IDEuM2MtLjAyLS4xMS0uMDktLjI0LS4yNi0uMjRIMi4yYy0uMiAwLS4yMi4xNy0uMTUuMy4yNS42NyAyLjU3IDYuNTggMy41IDguOTV2NS40M2MwIC4xLjA1LjE1LjE2LjE1aDEuMjRjLjA2IDAgLjEzLS4wNi4xMy0uMTV2LTUuMzljLjgyLTIuMyA0LTEwLjMyIDQuMDMtMTAuMzkuMDUtLjEyLjAyLS4yMi0uMTUtLjIyeiIvPjwvc3ZnPg==)}.ymaps-2-1-42-copyright_color_white .ymaps-2-1-42-copyright__logo_lang_en{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0NS45OSIgaGVpZ2h0PSIyMC4wMiIgdmlld0JveD0iMC4wMSAtMS4wMjMgNDUuOTg5IDIwLjAyMSI+PHBhdGggZD0iTTEyLjYzIDUuNzhjLS42MSAwLTEuNTMuMjMtMi4xMy41LS4xNy4wNy0uMjYuMTUtLjE1LjRsLjQzLjg3Yy4wMy4xLjEuMTMuMTUuMTNsLjE4LS4wNmMuNjEtLjQgMS4wNC0uNiAxLjQtLjYuNDYgMCAuNzYuMy45NC43NS4yLjQ0LjI2IDEuMDUuMjYgMS43M3YuMmEzLjQzIDMuNDMgMCAwIDAtMS4zOC0uMzZjLTEuNzUgMC0yLjcgMS42OC0yLjcgMy40NyAwIDEuOTYgMS4xMiAzLjM2IDIuNDQgMy4zNi43NSAwIDEuNDItLjQzIDEuODctLjk3bC4yNS42Yy4wNC4xMS4xLjEzLjIuMTNoLjcxYy4wNiAwIC4xMy0uMDQuMTMtLjE1VjEwLjJjMC0xLjM4LS4xLTIuNDMtLjQ1LTMuMTNhMi4yOSAyLjI5IDAgMCAwLTIuMTUtMS4yOXptMS4wOCA4LjU5Yy0uMzcuMzYtLjc3LjUzLTEuMTUuNTMtMS4wNiAwLTEuMy0xLjMtMS4zLTIuMTkgMC0xLjA1LjQtMi4xMyAxLjItMi4xMy40IDAgLjg2LjEgMS4yNS40M3YzLjM2em02LjgyLTguNDZjLS45NyAwLTEuOTYuNzItMS45Ni43MnYtLjQ3YzAtLjA4LS4wNy0uMTUtLjEzLS4xNWgtMS4yNWEuMTUuMTUgMCAwIDAtLjE0LjE1djkuNjJjMCAuMS4wMi4xNS4xNC4xNWgxLjI1Yy4wNiAwIC4xMy0uMDYuMTMtLjE1VjcuNTNzLjU3LS4zNSAxLjI5LS4zNWMuNjUgMCAxLjE3LjMzIDEuMTcgMXY3LjZjMCAuMS4wNy4xNS4xNy4xNWgxLjJjLjE0IDAgLjE1LS4wNi4xNS0uMTVWNy43NWMwLTEuMi0uNzMtMS44NC0yLjAyLTEuODR6bTkuNS00LjgzSDI4LjhjLS4xIDAtLjE0LjA3LS4xNC4xNHY0Ljg2Yy0uNS0uMi0uOTMtLjMtMS4yNS0uMy0yLjAyIDAtMy4zNiAxLjktMy4zNiA1LjU4IDAgMy4xNCAxLjMgNC44MyAzLjA2IDQuODMuNzIgMCAxLjMzLS40MiAxLjc1LS44bC4yNy40NGMuMDUuMDkuMDcuMS4xNy4xaC43NWMuMDggMCAuMTItLjA2LjEyLS4xNVYxLjIyYzAtLjEtLjA0LS4xNC0uMTItLjE0em0tMS4zOSAxMy41Yy0uMzIuMTctLjcuMzItMS4xLjMyLTEuMzMgMC0xLjg4LTEuNTctMS44OC0zLjg2IDAtMi4wMi41Ny00LjAxIDEuOC00LjAxLjM4IDAgLjc4LjE1IDEuMTguNDJ2Ny4xM3ptNi4wOC04LjhjLTIuMTIgMC0zLjA4IDIuNzEtMy4wOCA1LjYzIDAgMi45OCAxLjMzIDQuNzYgMy4zMiA0Ljc2Ljk1IDAgMS44LS4zNyAyLjI2LS42OC4wNi0uMDQuMDgtLjA2LjA2LS4xNWwtLjE1LS42OGMtLjAyLS4wOC0uMDUtLjEzLS4xNC0uMTMtLjEgMC0uNjguMjQtMS40OC4yNC0xLjUyIDAtMi4yMi0xLjM0LTIuMjItMy4wOXYtLjQ3cy43Ni4xIDEuMi4xaDIuOXYtLjgyYzAtMy4wOS0xLjEtNC43MS0yLjY3LTQuNzF6bS0uMjMgNC4yOWMtLjQ0IDAtMS4xNi4xLTEuMTYuMXMwLS4zLjA0LS42M2MuMjItMS42OS41OC0yLjUzIDEuMy0yLjUzLjYyIDAgMS4wMi44NyAxLjExIDIuMzkuMDIuMzIuMDIuNjcuMDIuNjdoLTEuM3ptOS4zNi00LjA2aC0xLjA3Yy0uMTMgMC0uMjEuMDctLjI0LjE3LS4wNS4xNS0uNTMgMS40LS43IDEuODlsLS41MiAxLjRoLS4wNGwtLjQyLTEuMTJjLS4xLS4zMy0uNzEtMS45Mi0uNzktMi4xMi0uMDMtLjEtLjEyLS4yMi0uMjUtLjIyaC0xLjJjLS4xNCAwLS4yLjE1LS4xNS4yNGwxLjkyIDQuNDQtMi4wNyA0Ljk3Yy0uMDcuMTQuMDIuMjcuMTUuMjdoMS4wM2MuMiAwIC4yNS0uMDguMzItLjI1bC43LTEuOS41Mi0xLjY3aC4wNGwuNSAxLjQyLjgzIDIuMmMuMDQuMTIuMTIuMi4yNi4yaDEuMTZjLjEyIDAgLjE5LS4xMy4xMi0uMjUtLjE1LS4yOC0xLjI0LTMuMDQtMi4wNC00LjgyTDQ0IDYuMjVjLjAyLS4xMS4wMi0uMjQtLjE1LS4yNHpNMTAuOTUtLjI2aC0xLjNjLS4xNCAwLS4yLjA1LS4yNC4xOGwtMi4zOSA2LjdjLS4yOC43NS0uNiAyLjA0LS42IDIuMDRoLS4wOHMtLjUyLTEuNTItLjY1LTIuMDFDNS41IDYuMSAzLjgxIDEuNDYgMy43NyAxLjNjLS4wMi0uMTEtLjA5LS4yNC0uMjYtLjI0SDIuMmMtLjIgMC0uMjIuMTctLjE1LjMuMjUuNjcgMi41NyA2LjU4IDMuNSA4Ljk1djUuNDNjMCAuMS4wNS4xNS4xNi4xNWgxLjI0Yy4wNiAwIC4xMy0uMDYuMTMtLjE1di01LjM5Yy44Mi0yLjMgNC0xMC4zMiA0LjAzLTEwLjM5LjA1LS4xMi4wMi0uMjItLjE1LS4yMnoiIGZpbGw9IiNmZmYiLz48L3N2Zz4=)}", provide);
    });
  }],
  ['2(', function(ym) {
    ym.modules.define('copyright.layout.html', ["copyright", "copyright__logo"], function(provide) {
      provide([0, "<ymaps class=\"ymaps-2-1-42-copyright\"><ymaps class=\"ymaps-2-1-42-copyright__fog\">…</ymaps><ymaps class=\"ymaps-2-1-42-copyright__wrap\"><ymaps class=\"ymaps-2-1-42-copyright__layout\"><ymaps class=\"ymaps-2-1-42-copyright__content-cell\"><ymaps class=\"ymaps-2-1-42-copyright__content\"><ymaps class=\"ymaps-2-1-42-copyright__text\"></ymaps><ymaps class=\"ymaps-2-1-42-copyright__agreement\">&nbsp;<a class=\"ymaps-2-1-42-copyright__link\" target=\"_blank\" href=\"", 2001, ["localization.Copyrights.agreementLink", []], 0, "\">", 2003, "data.get(\"state.size\") == \"large\"", 2001, ["localization.Copyrights.agreement", []], 2004, null, 2001, ["localization.Copyrights.agreementCompact", []], 2005, null, 0, "</a></ymaps></ymaps></ymaps><ymaps class=\"ymaps-2-1-42-copyright__logo-cell\"><a class=\"ymaps-2-1-42-copyright__logo\" href=\"\" target=\"_blank\"></a></ymaps></ymaps></ymaps></ymaps>"]);
    });
  }],
  ['5z', function(ym) {
    ym.modules.define('copyright.standards', ['system.provideCss'], function(provide, provideCss) {
      provideCss(".ymaps-2-1-42-copyright{position:relative;z-index:1;display:block;height:20px;top:-20px;float:right}.ymaps-2-1-42-copyright_float_left{float:left}.ymaps-2-1-42-copyright_fog_yes{float:none}.ymaps-2-1-42-copyright__wrap{display:block;overflow:hidden}.ymaps-2-1-42-copyright__layout{position:relative;z-index:1;top:1px;display:table;float:right}.ymaps-2-1-42-copyright__content-cell,.ymaps-2-1-42-copyright__logo-cell{display:table-cell;vertical-align:top}.ymaps-2-1-42-copyright__logo-cell{padding-left:4px}.ymaps-2-1-42-copyright__content-cell{height:20px}.ymaps-2-1-42-copyright__content{display:inline-block;float:right;padding:0 4px 1px;white-space:nowrap;border-radius:3px;background-color:rgba(255,255,255,.75);font:11px/14px Verdana,Arial,sans-serif}.ymaps-2-1-42-copyright_fog_yes .ymaps-2-1-42-copyright__content{background-color:transparent}.ymaps-2-1-42-copyright_fog_yes .ymaps-2-1-42-copyright__wrap{margin-left:17px}.ymaps-2-1-42-copyright_fog_yes:after{position:absolute;z-index:-1;top:1px;right:50px;left:17px;height:15px;content:'';border-radius:0 3px 3px 0;background-color:rgba(255,255,255,.75)}.ymaps-2-1-42-copyright_logo_no.ymaps-2-1-42-copyright_fog_yes:after{right:0}.ymaps-2-1-42-copyright_logo_no .ymaps-2-1-42-copyright__logo-cell,.ymaps-2-1-42-copyright_providers_no .ymaps-2-1-42-copyright__text,.ymaps-2-1-42-copyright_ua_no .ymaps-2-1-42-copyright__agreement,.ymaps-2-1-42-copyright_ua_no.ymaps-2-1-42-copyright_providers_no .ymaps-2-1-42-copyright__content-cell{display:none}.ymaps-2-1-42-copyright__fog{position:absolute;z-index:2;top:1px;left:0;display:none;width:12px;height:15px;padding-left:5px;border-radius:3px 0 0 3px;background:rgba(255,255,255,.75);font:11px/14px Verdana,Arial,sans-serif}.ymaps-2-1-42-copyright_fog_yes .ymaps-2-1-42-copyright__fog{display:block}.ymaps-2-1-42-copyright__extend{margin-left:.4em}.ymaps-2-1-42-copyright__link{text-decoration:underline!important;color:#333!important}.ymaps-2-1-42-copyright__link:hover{color:#c00!important}", provide);
    });
  }],
  ['3w', function(ym) {
    ym.modules.define("data.Adapter", ["util.defineClass", "data.BaseManager", "Event"], function(t, e, i, s) {
      function n(t, e, i, s) {
        n.superclass.constructor.call(this), this._object = t, this._events = e, this._fields = i || {}, this._all = s || {}, this._isDirect = r(this._fields), t.events.add(e, this.fireChangeEvent, this)
      }

      function r(t) {
        if ("function" == typeof Object.keys) {
          var e = Object.keys(t);
          return 0 == e.length && "*" === e[0]
        }
        for (var i in t)
          if ("*" != i && t.hasOwnProperty(i)) return !1;
        return !0
      }
      e(n, i, {
        getObject: function() {
          return this._object
        },
        singleSet: function(t, e) {
          var i = this._parsePath(t);
          i && this._fields[i.field].set(this._object, e, i.postfix)
        },
        singleUnset: function(t) {
          var e = this._parsePath(t);
          e && this._fields[e.field].unset(this._object, e.postfix)
        },
        unsetAll: function() {
          return "function" == typeof this._all.unset && this._all.unset(this._object), this
        },
        get: function(t, e) {
          var i = this._parsePath(t);
          if (i) {
            var s = this._fields[i.field].get(this._object, i.postfix);
            return "undefined" != typeof s ? s : e
          }
          return e
        },
        getAll: function() {
          if ("function" == typeof this._all.get) return this._all.get(this._object)
        },
        destroy: function() {
          this._object.events.remove(this._events, this.fireChangeEvent, this)
        },
        _changeCallback: function() {
          this.events.fire("change", new s({
            type: "change",
            target: this
          }))
        },
        _parsePath: function(t) {
          if (this._fields.hasOwnProperty(t)) return {
            field: t
          };
          if (this._isDirect) return {
            field: "*",
            postfix: t
          };
          var e = t.split("."),
            i = [];
          for (e.push("*"); !this._fields.hasOwnProperty(t = e.join("."));) {
            if (e.length -= 1, !e.length) return null;
            i.push(e.pop()), e.push("*")
          }
          return i.length > 1 && i.reverse(), {
            field: t,
            postfix: i.join(".")
          }
        }
      }), t(n)
    });
  }],
  ['3A', function(ym) {
    ym.modules.define("data.Aggregator", ["util.defineClass", "data.Manager"], function(t, e, i) {
      function s(t) {
        s.superclass.constructor.call(this, t), this._children = {};
        for (var e in t) t.hasOwnProperty(e) && this._testDataManager(t[e]) && this.addChild(e, t[e])
      }
      e(s, i, {
        singleSet: function(t, e) {
          var i = this._parsePath(t);
          if (i) {
            if (i.postfix) return void i.child.set(i.postfix, e);
            this.removeChild(t, i.child)
          }
          s.superclass.singleSet.call(this, t, e), this._testDataManager(e) && this.addChild(t, e)
        },
        singleUnset: function(t) {
          var e = this._parsePath(t);
          if (e) {
            if (e.postfix) return void e.child.unset(e.postfix);
            this.removeChild(t, e.child)
          }
          s.superclass.singleUnset.call(this, t)
        },
        unsetAll: function() {
          return this._clearAll(), s.superclass.unsetAll.call(this), this
        },
        get: function(t, e) {
          var i = this._parsePath(t);
          return i ? i.postfix ? i.child.get(i.postfix, e) : i.child : s.superclass.get.call(this, t, e)
        },
        destroy: function() {
          this._clearAll(), s.superclass.destroy.call(this)
        },
        addChild: function(t, e) {
          this._children[t] = e, e.events.add("change", this.fireChangeEvent, this)
        },
        removeChild: function(t, e) {
          e.events.remove("change", this.fireChangeEvent, this), delete this._children[t]
        },
        _testDataManager: function(t) {
          return t && "function" == typeof t.get && t.events && "function" == typeof t.events.add
        },
        _parsePath: function(t) {
          var e, i, s = t.indexOf(".");
          if (s != -1 ? (e = t.slice(0, s), i = t.slice(s + 1)) : e = t, this._children.hasOwnProperty(e)) return {
            child: this._children[e],
            postfix: i
          }
        },
        _clearAll: function() {
          for (var t in this._children) this._children.hasOwnProperty(t) && this._children[t].events.remove("change", this.fireChangeEvent, this);
          this._children = {}
        }
      }), t(s)
    });
  }],
  ['9J', function(ym) {
    ym.modules.define("data.BaseManager", ["util.defineClass", "util.array", "event.manager.Base", "Event", "component.EventFreezer"], function(e, n, t, r, i, s) {
      function f() {
        this.events = new r, this._internalFreezer = new s(h, this), this._freezer = new s(a, this)
      }

      function h() {
        this._freezer.fire()
      }

      function a() {
        this.events.fire("change", new i({
          type: "change",
          target: this
        }))
      }
      n(f, {
        set: function(e, n) {
          if ("string" == typeof e || e instanceof String) this.singleSet(e, n);
          else {
            this._internalFreezer.freeze();
            for (var t in e) e.hasOwnProperty(t) && this.singleSet(t, e[t]);
            this._internalFreezer.unfreeze()
          }
          return this
        },
        singleSet: function(e, n) {},
        unset: function(e) {
          if (t.isArray(e)) {
            this._internalFreezer.freeze();
            for (var n = 0, r = e.length; n < r; n++) this.singleUnset(e[n]);
            this._internalFreezer.unfreeze()
          } else this.singleUnset(e);
          return this
        },
        singleUnset: function(e) {},
        freeze: function() {
          return this._freezer.freeze(), this
        },
        unfreeze: function() {
          return this._freezer.unfreeze(), this
        },
        isFrozen: function() {
          return this._freezer.isFrozen()
        },
        fireChangeEvent: function() {
          this._internalFreezer.fire()
        },
        destroy: function() {}
      }), e(f)
    });
  }],
  ['3D', function(ym) {
    ym.modules.define("data.Manager", ["util.defineClass", "util.extend", "data.BaseManager", "util.array", "util.safeAccess"], function(t, e, n, a, i, s) {
      function h(t) {
        h.superclass.constructor.call(this), this._data = t || {}, this._preventInputChange = !!t
      }
      e(h, a, {
        singleSet: function(t, e) {
          var n = t.split("."),
            a = n.pop(),
            i = s(this._data, n);
          if ("undefined" != typeof i) this._preventInputChange && (i = this._checkInputChange(i)), i[a] = e, this.fireChangeEvent();
          else if (ym.env.debug) throw new Error("data.Manager: некорректный путь к данным: " + t)
        },
        _checkInputChange: function(t) {
          return t == this._data && (t = this._data = n({}, this._data), this._preventInputChange = !1), t
        },
        singleUnset: function(t) {
          var e = t.split("."),
            n = e.pop(),
            a = s(this._data, e);
          if ("undefined" != typeof a) this._preventInputChange && (a = this._checkInputChange(a)), delete a[n], this.fireChangeEvent();
          else if (ym.env.debug) throw new Error("data.Manager: некорректный путь к данным: " + t)
        },
        unsetAll: function() {
          return this._data = {}, this.fireChangeEvent(), this
        },
        setAll: function(t) {
          return this._data = t, this._preventInputChange = !0, this.fireChangeEvent(), this
        },
        get: function(t, e) {
          var n = s(this._data, t);
          return "undefined" != typeof n ? n : e
        },
        getAll: function() {
          return this._data
        }
      }), t(h)
    });
  }],
  ['3N', function(ym) {
    ym.modules.define("data.Sync", ["util.defineClass"], function(n, t) {
      function s(n) {
        this._managers = n;
        for (var t = 0, s = n.length; t < s; t++) n[t].events.add("change", this._onChange, this);
        this._onSync = !1, this._sync(n[0])
      }
      t(s, {
        destroy: function() {
          for (var n = 0, t = this._managers.length; n < t; n++) this._managers[n].events.remove("change", this._onChange, this)
        },
        _sync: function(n) {
          var t = n.getAll();
          this._onSync = !0;
          for (var s = 0, e = this._managers.length; s < e; s++) {
            var a = this._managers[s];
            a != n && a.setAll(t)
          }
          this._onSync = !1
        },
        _onChange: function(n) {
          this._onSync || this._sync(n.get("target"))
        }
      }), n(s)
    });
  }],
  ['3P', function(ym) {
    ym.modules.define("DomEvent", ["util.defineClass", "domEvent.Base", "domEvent.overrideStorage", "component.event.Cacher"], function(e, t, c, n, h) {
      function i(e, t) {
        i.superclass.constructor.call(this, e, t), this._cache = {
          type: t || e.type
        }, this._cacher = null
      }
      t(i, c, {
        get: function(e) {
          return this._cacher || (this._cacher = new h(this, this._cache, n)), this._cacher.get(e)
        },
        clone: function(e) {
          return new i(e, this._cache.type)
        }
      }), e(i)
    });
  }],
  ['9Z', function(ym) {
    ym.modules.define("domEvent.Base", ["util.defineClass", "Event"], function(t, a, e) {
      function o(t, a) {
        o.superclass.constructor.call(this, t), this._dataKey = "domEventData" + a
      }
      a(o, e, {
        callMethod: function(t) {
          return this.get(t).apply(this.originalEvent, Array.prototype.slice.call(arguments, 1))
        },
        stopImmediatePropagation: function() {
          var t = this._getPropagatedData();
          t.immediatePropagationStopped = !0, t.propagationStopped = !0
        },
        isImmediatePropagationStopped: function() {
          return this._getPropagatedData().immediatePropagationStopped
        },
        stopPropagation: function() {
          this._getPropagatedData().propagationStopped = !0
        },
        isPropagationStopped: function() {
          return this._getPropagatedData().propagationStopped
        },
        preventDefault: function() {
          this._getPropagatedData().defaultPrevented = !0
        },
        isDefaultPrevented: function() {
          return this._getPropagatedData().defaultPrevented
        },
        allowMapEvent: function() {
          this._getPropagatedData().mapEventAllowed = !0
        },
        disallowMapEvent: function() {
          this._getPropagatedData().mapEventAllowed = !1
        },
        isMapEventAllowed: function() {
          return this._getPropagatedData().mapEventAllowed
        },
        _getPropagatedData: function() {
          var t = this.get("propagatedData");
          return t[this._dataKey] || (t[this._dataKey] = {})
        }
      }), t(o)
    });
  }],
  ['3T', function(ym) {
    ym.modules.define("domEvent.manager", ["util.defineClass", "util.id", "util.data", "DomEvent", "event.manager.Base", "event.Group", "domEvent.managerOverrideStorage", "util.dom.event"], function(e, t, n, r, a, i, o, g, u) {
      function v(e) {
        return function(t) {
          var n = t.type,
            i = u.getIdealName(t.type);
          r.get(e, E).fire(n, new a(t, n)), n == i || g.get(i) || r.get(e, E).fire(i, new a(t, i))
        }
      }

      function s(e) {
        var t = e.type,
          n = u.getIdealName(e.type);
        r.get(this, f).fire(t, new a(e, t)), t == n || g.get(n) || r.get(this, f).fire(n, new a(e, n))
      }

      function m(e) {
        var t = e.type,
          n = u.getIdealName(e.type);
        r.get(this, E).fire(t, new a(e, t)), t == n || g.get(n) || r.get(this, E).fire(n, new a(e, n))
      }

      function d(e, t, n) {
        this.htmlElement = e, this.domEventManager = t, this.capture = n
      }
      var h = ym.env.browser.oldIE,
        f = "eventManagerCapturingPhase",
        E = "eventManagerBubblingPhase",
        l = "ieHandler";
      e({
        add: function(e, t, n, r, a) {
          if (ym.env.debug && (!e || !t)) throw new Error("domEvent.Manager: Не был передан обязательный аргумент!.");
          var o = this._getEventManager(e, a);
          return o || (o = new i({
            controllers: [this],
            htmlElement: e,
            capture: !!a
          }), this._setEventManager(e, o, a)), o.add(t, n, r), this
        },
        remove: function(e, t, n, r, a) {
          if (ym.env.debug && (!e || !t)) throw new Error("domEvent.Manager: Не был передан обязательный аргумент!.");
          var i = this._getEventManager(e, a);
          return i && i.remove(t, n, r), this
        },
        fire: function(e, t, n) {
          var r = this._getEventManager(e, !0),
            a = this._getEventManager(e, !1);
          return r && r.fire(t, n), a && a.fire(t, n), this
        },
        onStartListening: function(e, t) {
          var n = g.get(t);
          if (n) n.start(e);
          else {
            t = u.getActualName(t);
            var a = e.params,
              i = a.htmlElement,
              o = !!a.capture;
            h ? i.attachEvent("on" + t, r.get(i, l)) : i.addEventListener(t, o ? s : m, o)
          }
        },
        onStopListening: function(e, t) {
          var n = g.get(t),
            a = e.params,
            i = a.htmlElement,
            o = !!a.capture;
          n ? n.stop(e) : (t = u.getActualName(t), h ? i.detachEvent("on" + t, r.get(i, l)) : i.removeEventListener(t, o ? s : m, o)), e.typesCount || this._unsetEventManager(i, o)
        },
        group: function(e, t) {
          return new o(new d(e, this, t))
        },
        _getEventManager: function(e, t) {
          return r.get(e, t && !h ? f : E)
        },
        _setEventManager: function(e, t, n) {
          r.add(e, n && !h ? f : E, t), h && r.add(e, l, v(e))
        },
        _unsetEventManager: function(e, t) {
          r.remove(e, t && !h ? f : E), h && r.remove(e, l)
        }
      }), t(d, {
        add: function(e, t, n) {
          return this.domEventManager.add(this.htmlElement, e, t, n, this.capture)
        },
        remove: function(e, t, n) {
          return this.domEventManager.remove(this.htmlElement, e, t, n, this.capture)
        }
      })
    });
  }],
  [',d', function(ym) {
    ym.modules.define("domEvent.managerComponent.mouseLeaveEnterDispatcher", ["DomEvent", "system.browser"], function(e, t, n) {
      var r = !0;
      e({
        setEnabled: function(e) {
          r = e
        },
        fire: function(e, o, m, a) {
          if (r) {
            var f, i = e.params.htmlElement;
            for (f = n.oldIE ? "mouseenter" == o ? m.fromElement : m.toElement : m.relatedTarget; f && f != i;) try {
              f = f.parentNode
            } catch (s) {
              return !1
            }
            if (f != i) return a || (a = t), e.fire(o, new a(m, o)), !0
          }
          return !1
        }
      })
    });
  }],
  [',h', function(ym) {
    ym.modules.define("domEvent.managerOverrides.touches", ["util.data", "domEvent.managerOverrideStorage", "domEvent.TouchMapper"], function(t, e, o, u) {
      for (var a = function(t) {
          o.add(t, {
            start: function(e) {
              c(e, t)
            },
            stop: function(e) {
              r(e, t)
            }
          })
        }, n = ["mouseenter", "mouseleave", "mousemove", "mousedown", "mouseup", "wheel", "click", "dblclick", "contextmenu", "multitouchstart", "multitouchmove", "multitouchend"], c = function(t, o) {
          var a = t.params,
            n = a.capture ? "touchDataWithCapture" : "touchData",
            c = a.htmlElement,
            r = e.get(c, n);
          r || (r = {
            types: {},
            count: 0,
            touchMapper: new u(t)
          }, e.add(c, n, r)), r.types[o] || (r.count || r.touchMapper.start(), r.types[o] = !0, r.count++)
        }, r = function(t, o) {
          var u = t.params,
            a = u.capture ? "touchDataWithCapture" : "touchData",
            n = u.htmlElement,
            c = e.get(n, a);
          c && c.types[o] && (delete c.types[o], --c.count || (c.touchMapper.stop(), e.remove(n, a)))
        }, m = 0, p = n.length; m < p; m++) a(n[m]);
      t({})
    });
  }],
  [',f', function(ym) {
    ym.modules.define("domEvent.managerOverrideStorage", ["util.Storage"], function(e, n) {
      e(new n)
    });
  }],
  ['3W', function(ym) {
    ym.modules.define("domEvent.MultiPointer", ["util.defineClass", "domEvent.Base", "domEvent.multiPointer.overrideStorage", "component.event.Cacher"], function(e, t, c, n, i) {
      function h(e, t, c) {
        h.superclass.constructor.call(this, e, t), this._cache = {
          type: t || "multi" + e.type,
          touches: c
        }, this._cacher = null
      }
      t(h, c, {
        get: function(e) {
          return this._cacher || (this._cacher = new i(this, this._cache, n)), this._cacher.get(e)
        },
        clone: function(e) {
          return new h(e, this._cache.type, this._cache.touches)
        }
      }), e(h)
    });
  }],
  [',k', function(ym) {
    ym.modules.define("domEvent.multiPointer.overrideStorage", ["util.Storage"], function(e, o) {
      e(new o)
    });
  }],
  ['30', function(ym) {
    ym.modules.define("domEvent.MultiTouch", ["util.defineClass", "domEvent.Base", "domEvent.multiTouch.overrideStorage", "component.event.Cacher"], function(e, t, c, h, n) {
      function i(e, t, c) {
        i.superclass.constructor.call(this, e, t), this._cache = {
          type: t || "multi" + e.type,
          touches: c
        }, this._cacher = null
      }
      t(i, c, {
        get: function(e) {
          return this._cacher || (this._cacher = new n(this, this._cache, h)), this._cacher.get(e)
        },
        clone: function(e) {
          return new i(e, this._cache.type, this._cache.touches)
        }
      }), e(i)
    });
  }],
  ['$b', function(ym) {
    ym.modules.define("domEvent.multiTouch.override", ["domEvent.multiTouch.overrideStorage", "util.instantCache", "util.id", "util.array"], function(t, e, n, r, a) {
      function i(t) {
        return function(e) {
          var n = e.get("touches"),
            r = 0,
            i = 0;
          return n && n.lenght && (a.each(n, function(e) {
            r += e[t]
          }), i += n.length, r /= i), r
        }
      }
      for (var o = ["pageX", "pageY", "screenX", "screenY", "clientX", "clientY"], u = 0, d = o.length; u < d; u++) e.add(o[u], i(o[u]));
      e.add("position", function(t) {
        return [t.get("pageX"), t.get("pageY")]
      }), e.add("propagatedData", function(t) {
        var e = r.get(t.originalEvent),
          a = n.get(e);
        return a || n.add(e, a = {}), a
      }), e.add("target", function(t) {
        return t.get("touches")[0].target
      }), t({})
    });
  }],
  [',l', function(ym) {
    ym.modules.define("domEvent.multiTouch.overrideStorage", ["util.Storage"], function(e, o) {
      e(new o)
    });
  }],
  [',a', function(ym) {
    ym.modules.define("domEvent.override.common", ["domEvent.overrideStorage", "util.eventId", "util.instantCache"], function(e, t, n, a) {
      function r(e, t) {
        var n = e.originalEvent,
          a = 0,
          r = 0;
        "wheel" == n.type && (r = -n.deltaY, a = n.deltaX), "mousewheel" == n.type && ("undefined" != typeof n.wheelDeltaY ? (r = n.wheelDeltaY, a = n.wheelDeltaX) : r = n.wheelDelta), t.set("delta", r), t.set("deltaY", r), t.set("deltaX", a)
      }

      function o(e, t) {
        return i(e, t), e.get("pageX")
      }

      function d(e, t) {
        return i(e, t), e.get("pageY")
      }

      function l(e, t) {
        return [e.get("pageX"), e.get("pageY")]
      }

      function i(e, t) {
        var n = e.originalEvent,
          a = n.pageX,
          r = n.pageY;
        "undefined" == typeof a && (a = n.clientX, r = n.clientY, v && (a += (v.scrollLeft || 0) - (v.clientLeft || 0), r += (v.scrollTop || 0) - (v.clientTop || 0)), m && (a += m.scrollLeft || 0, r += m.scrollTop || 0)), t.set("pageX", a), t.set("pageY", r)
      }

      function g(e, t) {
        var n = c(e, t);
        return n.target
      }

      function u(e, t) {
        var n = c(e, t);
        return n.relatedTarget
      }

      function c(e, t) {
        var n = e.originalEvent,
          a = n.target || n.srcElement,
          r = n.relatedTarget || null;
        if (a && 3 == a.nodeType && (a = a.parentNode), !n.relatedTarget && n.fromElement && (r = n.fromElement == a ? n.toElement : n.fromElement), "Gecko" == f.engine && n.relatedTarget) try {
          -n.relatedTarget.nodeType
        } catch (o) {
          r = null
        }
        return t.set("target", a), t.set("relatedTarget", r), {
          target: a,
          relatedTarget: r
        }
      }
      var f = ym.env.browser,
        p = function(e, t) {
          return r(e, t), e.get("delta")
        },
        s = function(e, t) {
          return r(e, t), e.get("deltaX")
        };
      t.add("delta", p).add("deltaY", p).add("deltaX", s);
      var v = document.documentElement,
        m = document.body;
      t.add("pageX", o).add("pageY", d).add("position", l), t.add("propagatedData", function(e, t) {
        var r = e.originalEvent,
          o = n.get(r),
          d = a.get(o);
        return d || a.add(o, d = {}), d
      }), t.add("activeMouseButton", function(e) {
        var t = e.originalEvent,
          n = -1;
        if (void 0 != t.buttons) {
          var a = t.buttons;
          n = 0, 4 & a ? n = 3 : 2 & a ? n = 2 : 1 & a && (n = 1), "Trident" == f.engine && 9 == f.documentMode && "mousemove" == t.type.toLocaleLowerCase() && (n = -1)
        } else n = t.hasOwnProperty("which") ? t.which : -1;
        return n
      }), t.add("target", g).add("relatedTarget", u), e(!0)
    });
  }],
  [',c', function(ym) {
    ym.modules.define("domEvent.overrideStorage", ["util.Storage"], function(e, o) {
      e(new o)
    });
  }],
  ['32', function(ym) {
    ym.modules.define("domEvent.Pointer", ["util.defineClass", "domEvent.Base", "domEvent.pointer.overrideStorage", "component.event.Cacher"], function(e, t, c, n, h) {
      function i(e, t, c) {
        i.superclass.constructor.call(this, e, t), this._cache = {
          type: t || e.type,
          mode: c,
          touches: [e]
        }, this._cacher = null
      }
      t(i, c, {
        get: function(e) {
          return this._cacher || (this._cacher = new h(this, this._cache, n)), this._cacher.get(e)
        },
        clone: function(e) {
          return new i(e, this._cache.type, this._cache.mode)
        }
      }), e(i)
    });
  }],
  [',m', function(ym) {
    ym.modules.define("domEvent.pointer.overrideStorage", ["util.Storage"], function(e, o) {
      e(new o)
    });
  }],
  ['38', function(ym) {
    ym.modules.define("domEvent.Touch", ["util.defineClass", "domEvent.Base", "domEvent.touch.overrideStorage", "component.event.Cacher"], function(e, t, c, n, h) {
      function o(e, t, c) {
        o.superclass.constructor.call(this, e, t), this._cache = {
          type: t || e.type,
          button: 0,
          touches: c
        }, this._cacher = null
      }
      t(o, c, {
        get: function(e) {
          return this._cacher || (this._cacher = new h(this, this._cache, n)), this._cacher.get(e)
        },
        clone: function(e) {
          return new o(e, this._cache.type, this._cache.touches)
        }
      }), e(o)
    });
  }],
  ['$f', function(ym) {
    ym.modules.define("domEvent.touch.override", ["domEvent.touch.overrideStorage", "util.instantCache", "util.id"], function(e, t, n, r) {
      function a(e) {
        return function(t) {
          var n = t.get("touches");
          return n[0][e]
        }
      }
      for (var o = ["pageX", "pageY", "screenX", "screenY", "clientX", "clientY"], i = 0, d = o.length; i < d; i++) t.add(o[i], a(o[i]));
      t.add("position", function(e) {
        return [e.get("pageX"), e.get("pageY")]
      }), t.add("propagatedData", function(e) {
        var t = r.get(e.originalEvent),
          a = n.get(t);
        return a || n.add(t, a = {}), a
      }), t.add("target", function(e) {
        return e.get("touches")[0].target
      }), e({})
    });
  }],
  [',n', function(ym) {
    ym.modules.define("domEvent.touch.overrideStorage", ["util.Storage"], function(e, o) {
      e(new o)
    });
  }],
  ['3$', function(ym) {
    ym.modules.define("domEvent.TouchMapper", ["util.extend", "util.bind", "DomEvent", "util.math.areEqual", "domEvent.managerComponent.mouseLeaveEnterDispatcher", "domEvent.Touch", "domEvent.MultiTouch", "map.metaOptions", "util.dom.event", "system.browser"], function(e, t, i, n, s, o, u, c, h, r, a) {
      var l = 20,
        v = "iOS" != a.osFamily,
        m = 20,
        d = 1200,
        E = ["mouseenter", "mouseleave", "mousemove", "mousedown", "mouseup", "wheel", "click", "dblclick", "contextmenu"],
        _ = {
          activeMappers: 0,
          activeTouchSession: !1,
          touchSessionEndTime: 0,
          initTouchId: 0,
          sessionStartPosition: null,
          sessionEndPosition: null
        },
        T = function(e) {
          var t = e.touches;
          if (1 == t.length || !_.initTouchId) {
            var i = t[0];
            _.initTouchId = i.identifier, _.sessionStartPosition = [i.clientX, i.clientY]
          }
          _.activeTouchSession = !0
        },
        f = function(e) {
          for (var t = e.touches.length, i = e.changedTouches, n = 0, s = i.length; n < s; n++) {
            var o = i[n];
            if (o.identifier == _.initTouchId) {
              _.sessionEndPosition = [o.clientX, o.clientY], _.initTouchId = 0;
              break
            }
          }
          0 == t && (_.touchSessionEndTime = +new Date, _.activeTouchSession = !1)
        },
        p = function(e, n) {
          this.events = e, this._useCapture = this.events.params.capture, this.params = t({}, {
            dblClickTimeout: h.get("dblClickTimeout", 500),
            contextMenuTimeout: h.get("touchContextMenuTimeout", 400)
          }, n), this._state = {}, this._listeners = null, this._elementTouchStartHandler = i(this._onTouchStart, this), this._elementTouchMoveHandler = i(this._onTouchMove, this), this._elementTouchEndHandler = i(this._onTouchEnd, this), this._mouseEventsHandler = i(this._onMouseEvent, this)
        };
      p.prototype = {
        start: function() {
          this._state = {
            initMouseEventSent: !1,
            multiTouch: !1,
            preventClick: !1,
            mouseOver: !1,
            previousEventType: "",
            clickData: {}
          }, a.isIE && (this._state.eventsWithoutHover = 0);
          var e = this.events.params.htmlElement;
          if (e.addEventListener("touchstart", this._elementTouchStartHandler, this._useCapture), e.addEventListener("touchmove", this._elementTouchMoveHandler, this._useCapture), e.addEventListener("touchend", this._elementTouchEndHandler, this._useCapture), e.addEventListener("touchcancel", this._elementTouchEndHandler, this._useCapture), v) {
            for (var t = 0, i = E.length; t < i; t++) e.addEventListener(r.getActualName(E[t]), this._mouseEventsHandler, this._useCapture);
            0 == _.activeMappers++ && (document.addEventListener("touchstart", T, !0), document.addEventListener("touchend", f, !0), document.addEventListener("touchcancel", f, !0))
          }
        },
        stop: function() {
          var e = this.events.params.htmlElement;
          if (e.removeEventListener("touchstart", this._elementTouchStartHandler, this._useCapture), e.removeEventListener("touchmove", this._elementTouchMoveHandler, this._useCapture), e.removeEventListener("touchend", this._elementTouchEndHandler, this._useCapture), e.removeEventListener("touchcancel", this._elementTouchEndHandler, this._useCapture), v) {
            0 == --_.activeMappers && (document.removeEventListener("touchstart", T, !0), document.removeEventListener("touchend", f, !0), document.removeEventListener("touchcancel", f, !0), _.touchSessionEndTime = 0, _.sessionStartPosition = _.sessionEndPosition = null);
            for (var t = 0, i = E.length; t < i; t++) e.removeEventListener(r.getActualName(E[t]), this._mouseEventsHandler, this._useCapture)
          }
        },
        _onTouchStart: function(e) {
          this._state.previousEventType = "touch";
          var t = this._state,
            i = e.touches,
            n = i.length;
          t.initMouseEventSent || (t.initMouseEventSent = !0, this._fireMouseInitEvents(e), t.initTimestamp = e.timeStamp, t.touches = e.touches), n > 1 && (t.initMouseEventSent && !t.preventClick && (t.preventClick = !0), this._fireEndStartMultiTouchEvents(t.multiTouch ? e : null, e))
        },
        _onTouchMove: function(e) {
          this._state.previousEventType = "touch";
          var t = e.touches,
            i = this._state;
          if (1 == t.length && _.sessionStartPosition) {
            var n = t[0],
              o = [n.clientX, n.clientY];
            if (s(_.sessionStartPosition, o, 3)) return
          }
          i.touches = e.touches, i.initMouseEventSent || this._onTouchStart(e), i.preventClick || (i.preventClick = !0), 1 == e.touches.length ? this._fireTouchEvent(e, "mousemove") : (i.multiTouch || this._fireEndStartMultiTouchEvents(null, e), this._fireMultiTouchEvent(e, "multitouchmove"))
        },
        _onTouchEnd: function(e) {
          this._state.previousEventType = "touch";
          var t = e.touches.length,
            i = this._state,
            n = i.multiTouch || !i.initMouseEventSent && e.changedTouches.length > 0;
          n && this._fireEndStartMultiTouchEvents(e, t > 1 ? e : null), 0 == t && (i.initTimestamp || (i.initTimestamp = e.timeStamp), i.touches || (i.touches = e.changedTouches), this._fireMouseEndEvents(e))
        },
        _fireEndStartMultiTouchEvents: function(e, t) {
          e && this._fireMultiTouchEvent(e, "multitouchend");
          var i = null != t;
          i && this._fireMultiTouchEvent(t, "multitouchstart"), this._state.multiTouch = i
        },
        _fireMouseInitEvents: function(e) {
          this._state.mouseOver || (this._state.mouseOver = !0, this._fireTouchEvent(e, "mouseenter")), this._fireTouchEvent(e, "mousemove"), this._fireTouchEvent(e, "mousedown")
        },
        _fireMouseEndEvents: function(e) {
          var t = e.timeStamp,
            i = this._state,
            n = i.touches;
          if (this._fireTouchEvent(e, "mouseup", n), "touchend" != e.type && (i.preventClick = !0), !i.preventClick)
            if (t - i.initTimestamp > this.params.contextMenuTimeout) this._fireTouchEvent(e, "contextmenu", n), i.clickData.time = null;
            else {
              var s = n[0];
              this._processClickEvent({
                clickPos: [s.clientX, s.clientY],
                time: e.timeStamp,
                diff: l
              }, function(t) {
                this._fireTouchEvent(e, t, n)
              })
            }
          this._fireTouchEvent(e, "mousemove", n), this._fireTouchEvent(e, "mouseleave", n), i.initMouseEventSent = i.preventClick = i.mouseOver = !1
        },
        _fireTouchEvent: function(e, t, i) {
          i || (i = e.touches), this.events.fire(t, new u(e, t, i))
        },
        _fireMultiTouchEvent: function(e, t, i) {
          i || (i = e.touches), this.events.fire(t, new c(e, t, i))
        },
        _onMouseEvent: function(e) {
          var t = this._state.previousEventType,
            i = this._state,
            u = r.getIdealName(e.type);
          if ("dblclick" != u) {
            var c = "mouseenter" == u,
              h = "mouseleave" == u,
              l = new n(e, u);
            if (h || !_.activeTouchSession && this._allowMouseEvent(e))
              if (this._state.previousEventType = "mouse", c || h) i.mouseOver = c, o.fire(this.events, u, l.originalEvent), a.isIE && (i.eventsWithoutHover = 0);
              else {
                if (a.isIE && !i.mouseOver && "mousemove" == u && 0 == i.eventsWithoutHover++) return;
                "touch" == t && (i.mouseOver || (i.mouseOver = !0, o.fire(this.events, "mouseenter", e)));
                var v = i.clickData;
                if ("click" == u) {
                  var m = [e.clientX, e.clientY],
                    d = v.lastMouseDownPos;
                  if (d && s(d, m, 0)) return void this._processClickEvent({
                    clickPos: [e.clientX, e.clientY],
                    time: e.timeStamp,
                    diff: 1
                  }, function(t) {
                    this.events.fire(t, new n(e, t))
                  })
                } else "mousedown" == u && (v.lastMouseDownPos = [e.clientX, e.clientY]);
                this.events.fire(u, l)
              }
          }
        },
        _allowMouseEvent: function(e) {
          if (_.touchSessionEndTime > 0) {
            var t = [e.clientX, e.clientY];
            if (+new Date - _.touchSessionEndTime > d) _.touchSessionEndTime = 0, _.sessionStartPosition = _.sessionEndPosition = null;
            else if (_.sessionStartPosition && s(t, _.sessionStartPosition, m) || _.sessionEndPosition && s(t, _.sessionEndPosition, m)) return !1
          }
          return !0
        },
        _processClickEvent: function(e, t) {
          var i = this._state,
            n = e.time,
            o = e.diff,
            u = e.clickPos;
          i.clickData.time && n - i.clickData.time < this.params.dblClickTimeout ? (t.call(this, "click"), i.clickData.pos && s(i.clickData.pos, u, o) && t.call(this, "dblclick"), i.clickData.time = null) : (t.call(this, "click"), i.clickData.time = n), i.clickData.pos = u
        }
      }, e(p)
    });
  }],
  ['2i', function(ym) {
    ym.modules.define('dotIconWithCaption.layout.html', ["islets-icon-caption", "islets-dot-icon-with-caption"], function(provide) {
      provide([0, "<ymaps class=\"ymaps-2-1-42-islets_dot-icon-with-caption\"><ymaps class=\"ymaps-2-1-42-islets_dot-icon-with-caption__caption-block\"><ymaps class=\"ymaps-2-1-42-islets_icon-caption\">", 2001, ["properties.iconCaption", []], 0, "</ymaps></ymaps>", 2002, ["islands#dotIcon", [
        ["name", "\"baseIcon\""]
      ]], 0, "</ymaps>"]);
    });
  }],
  ['0d', function(ym) {
    ym.modules.define("error", ["util.defineClass", "util.extend"], function(r, e, t) {
      function o(r, e) {
        function t(e) {
          Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = (new Error).stack, this.name = r, this.message = e
        }
        return e && (t.errorClass = e), n[r] = t, t
      }
      var n = {
          create: function(r, e) {
            return n[r] ? new n[r](e) : void n.log("ProcessError", r + ": is undefined error type")
          },
          throwException: function(r, e) {
            if (ym.env.debug) throw "object" == typeof r ? r : n.create(r, e)
          },
          throwExceptionIf: function(r, e, t) {
            r && n.throwException(e, t)
          },
          warn: function(r, e) {
            if (ym.env.debug && "object" == typeof console && console.warn) {
              var t = "object" == typeof r ? r : n.create(r, e),
                o = new Error(t.name + ": " + t.message);
              o.stack = t.stack, console.warn(o)
            }
          },
          warnIf: function(r, e, t) {
            r && n.warn(e, t)
          }
        },
        a = o("_YMError");
      e(a, Error);
      var c = o("ClientError");
      e(c, a);
      var i = o("InputError", "ClientError");
      e(i, c);
      var s = o("StateError", "ClientError");
      e(s, c);
      var E = o("ProcessError", "ClientError");
      e(E, c);
      var l = o("StorageItemAccessError", "ClientError");
      e(l, c);
      var v = o("FeatureRemovedError", "ClientError");
      e(v, c);
      var u = o("ExternalError");
      e(u, a);
      var f = o("RequestError", "ExternalError");
      e(f, u);
      var p = o("DataProcessingError", "ExternalError");
      e(p, u);
      var w = o("AccessError", "ExternalError");
      e(w, u);
      var d = o("NotSupportedError", "ExternalError");
      e(d, u);
      var g = o("Reject");
      e(g, a);
      var j = o("OperationUnallowedReject", "Reject");
      e(j, g);
      var R = o("OperationCanceledReject", "Reject");
      e(R, g);
      var m = o("EmptyResultReject", "Reject");
      e(m, g);
      var h = o("OperationUnawailableReject", "Reject");
      e(h, g);
      var x = o("Warning");
      e(x, a);
      var C = o("DeprecationWarning", "Warning");
      e(C, x);
      var y = o("OveruseWarning", "Warning");
      e(y, x), r(n)
    });
  }],
  ['3i', function(ym) {
    ym.modules.define("Event", ["util.defineClass"], function(t, e) {
      function n(t, e) {
        this.originalEvent = t || {}, this._sourceEvent = e || null, e ? (this._propagationStopped = e.isPropagationStopped(), this._immediatePropagationStopped = e.isImmediatePropagationStopped(), this._defaultPrevented = e.isDefaultPrevented(), this._mapEventAllowed = e.isMapEventAllowed()) : (this._propagationStopped = !1, this._immediatePropagationStopped = !1, this._defaultPrevented = !1, this._mapEventAllowed = !1)
      }
      e(n, {
        getSourceEvent: function() {
          return this._sourceEvent
        },
        get: function(t) {
          return "undefined" == typeof this.originalEvent[t] && this._sourceEvent ? this._sourceEvent.get(t) : this.originalEvent[t]
        },
        callMethod: function(t) {
          return "undefined" == typeof this.originalEvent[t] && this._sourceEvent ? this._sourceEvent.callMethod.apply(this._sourceEvent, arguments) : this.originalEvent[t].apply(this.originalEvent, Array.prototype.slice.call(arguments, 1))
        },
        stopImmediatePropagation: function() {
          this._sourceEvent && (this._sourceEvent.stopImmediatePropagation(), this._sourceEvent.stopPropagation()), this._immediatePropagationStopped = !0, this._propagationStopped = !0
        },
        isImmediatePropagationStopped: function() {
          return this._immediatePropagationStopped
        },
        stopPropagation: function() {
          this._sourceEvent && this._sourceEvent.stopPropagation(), this._propagationStopped = !0
        },
        isPropagationStopped: function() {
          return this._propagationStopped
        },
        preventDefault: function() {
          this._sourceEvent && this._sourceEvent.preventDefault(), this._defaultPrevented = !0
        },
        isDefaultPrevented: function() {
          return this._defaultPrevented
        },
        allowMapEvent: function() {
          this._sourceEvent && this._sourceEvent.allowMapEvent(), this._mapEventAllowed = !0
        },
        disallowMapEvent: function() {
          this._sourceEvent && this._sourceEvent.disallowMapEvent(), this._mapEventAllowed = !1
        },
        isMapEventAllowed: function() {
          return this._mapEventAllowed
        },
        clone: function(t) {
          return new n(t, this.getSourceEvent())
        }
      }), t(n)
    });
  }],
  ['3.', function(ym) {
    ym.modules.define("event.globalize", ["util.defineClass", "util.Associate", "event.Manager"], function(n, e, t, a) {
      function i() {
        this.globalEventManager = null
      }
      var l = new t(function() {
        return new i
      });
      e(i, {
        onBeforeEventFiring: function(n, e, t) {
          this.globalEventManager && this.globalEventManager.fire(e, t)
        }
      }), n(function(n) {
        var e = l.get(n);
        return n.getMetaEventManager = function() {
          return e.globalEventManager || (e.globalEventManager = new a)
        }, e
      })
    });
  }],
  ['3(', function(ym) {
    ym.modules.define("event.Group", ["util.defineClass"], function(e, s) {
      function t(e) {
        this.events = e, this._listeners = []
      }
      s(t, {
        add: function(e, s, t, i) {
          if ("string" == typeof e) this._listeners.push(e, s, t, i);
          else
            for (var n = 0, r = e.length; n < r; n++) this._listeners.push(e[n], s, t, i);
          return this.events.add(e, s, t, i), this
        },
        remove: function(e, s, t, i) {
          if ("string" == typeof e) this._removeListener(e, s, t, i);
          else
            for (var n = 0, r = e.length; n < r; n++) this._removeListener(e[n], s, t, i);
          return this
        },
        removeAll: function() {
          for (var e = 0, s = this._listeners.length; e < s; e += 4) this.events.remove(this._listeners[e], this._listeners[e + 1], this._listeners[e + 2], this._listeners[e + 3]);
          return this._listeners = [], this
        },
        getLength: function() {
          return this._listeners.length / 4
        },
        _removeListener: function(e, s, t, i) {
          for (var n = 0, r = this._listeners.length; n < r; n += 4)
            if (this._listeners[n] == e && this._listeners[n + 1] == s && this._listeners[n + 2] == t && this._listeners[n + 3] == i) {
              this._listeners.splice(n, 4), this.events.remove(e, s, t, i);
              break
            }
        }
      }), e(t)
    });
  }],
  ['3:', function(ym) {
    ym.modules.define("event.Manager", ["util.defineClass", "event.manager.Base", "Event", "util.extend"], function(t, e, n, i, r) {
      function s(t) {
        s.superclass.constructor.call(this, t)
      }
      e(s, n, {
        controllerMethods: ["onAfterEventFiring", "onBeforeEventFiring", "onStartListening", "onStopListening"],
        setParent: function(t) {
          return this.params.parent = t, this
        },
        getParent: function() {
          return this.params.parent
        },
        fire: function(t, e) {
          if (e && "function" == typeof e.get || (e = this.createEventObject(t, e, this.params.context)), !e.isPropagationStopped()) {
            var n;
            if (this.controllersHash.onBeforeEventFiring && (n = this.callControllers("onBeforeEventFiring", this, t, e)), n !== !1) {
              e.isImmediatePropagationStopped() || s.superclass.fire.call(this, t, e), this.params.parent && !e.isPropagationStopped() && this.params.parent.fire(t, e);
              var i = this.params.context;
              if (e.get("target") == i && !e.isDefaultPrevented()) {
                var r, o = t + "defaultaction";
                this.controllersHash.onBeforeEventFiring && (r = this.getDefaultActionEvent(e, o, i), n = this.callControllers("onBeforeEventFiring", this, o, r)), n !== !1 && this.types[o] && (r || (r = this.getDefaultActionEvent(e, o, i)), s.superclass.fire.call(this, o, r)), this.controllersHash.onAfterEventFiring && (r || (r = this.getDefaultActionEvent(e, o, i)), this.callControllers("onAfterEventFiring", this, o, r))
              }
              this.controllersHash.onAfterEventFiring && this.callControllers("onAfterEventFiring", this, t, e)
            }
          }
          return this
        },
        createEventObject: function(t, e, n) {
          var s = {
            type: t,
            target: n
          };
          return new i(e ? r(s, e) : s)
        },
        getDefaultActionEvent: function(t, e, n) {
          return new i({
            type: e,
            target: n,
            originalEvent: t
          })
        }
      }), t(s)
    });
  }],
  ['$g', function(ym) {
    ym.modules.define("event.manager.Base", ["util.defineClass", "util.array", "event.Group"], function(e, t, r, i) {
      function s(e) {
        if (this.types = {}, this.typesCount = 0, this.params = e || {}, this.controllersHash = {}, this.params.controllers)
          for (var t = this.params.controllers, r = 0, i = t.length; r < i; r++) this._setupController(t[r]);
        else this.params.controllers = [];
        this._onFire = {}, this._deletedOnFire = {}
      }
      t(s, {
        add: function(e, t, r, i) {
          if (i = +i || 0, "string" == typeof e) this._addListener(e, t, r, i);
          else
            for (var s = 0, n = e.length; s < n; s++) this._addListener(e[s], t, r, i);
          return this
        },
        remove: function(e, t, r, i) {
          if (i = +i || 0, "string" == typeof e) this._removeListener(e, t, r, i);
          else
            for (var s = 0, n = e.length; s < n; s++) this._removeListener(e[s], t, r, i);
          return this
        },
        fire: function(e, t) {
          var r = this.types[e];
          if (r && !t.isPropagationStopped()) {
            this._onFire.hasOwnProperty(e) ? this._onFire[e]++ : this._onFire[e] = 1;
            var i = "undefined" != typeof r.priorityKeys;
            if (i)
              for (var s = r.priorityKeys.length - 1; s >= 0; s--) this._callListeners(r[r.priorityKeys[s]], t);
            else this._callListeners(r, t);
            var n = this._deletedOnFire[e];
            if (n) {
              if (r = this.types[e], i) {
                for (var s = 0, o = n.priorityKeys.length; s < o; s++) {
                  var l = n.priorityKeys[s],
                    h = r[l];
                  this._removeDeletedOnFire(h, n[l]), h.length || this._clearPriority(e, l)
                }
                r.priorityKeys.length || this._clearType(e)
              } else this._removeDeletedOnFire(r, n), r.length || this._clearType(e);
              delete this._deletedOnFire[e]
            }--this._onFire[e] || delete this._onFire[e]
          }
          return this
        },
        _removeDeletedOnFire: function(e, t) {
          for (var r, i = 0, s = t.length - 1; s >= 0; s -= 2) t[s] && (i += 2, r = s, s > 0) || i && (e.splice(r, i), i = 0)
        },
        _addListener: function(e, t, r, i) {
          var s = !1,
            n = this.types[e],
            o = n;
          if (n) {
            if (ym.env.debug && e.length > 13 && e.lastIndexOf("defaultaction") == e.length - 13) throw new Error("event.manager.Base._addListener: Обработчик события по умолчанию " + e + " уже был добавлен ранее.");
            if ("undefined" != typeof n.priorityKeys) n[i] || this._addPriority(n, i), o = n[i];
            else if (i) {
              var l = this._deletedOnFire[e];
              l && (this._deletedOnFire[e] = {
                priorityKeys: [0],
                0: l
              }), n = this.types[e] = {
                priorityKeys: [0],
                0: n
              }, this._addPriority(n, i), o = n[i]
            }
          } else i ? (n = this.types[e] = {
            priorityKeys: [i]
          }, o = n[i] = []) : o = this.types[e] = [], s = !0, this.typesCount++;
          o.push(t, r || null), s && this.controllersHash.onStartListening && this.callControllers("onStartListening", this, e)
        },
        _addPriority: function(e, t) {
          e[t] = [];
          for (var r = e.priorityKeys, i = 0, s = r.length; i < s && !(r[i] > t); i++);
          r.splice(i, 0, t)
        },
        _removeListener: function(e, t, r, i) {
          var s = this.types[e];
          if (s) {
            var n = "undefined" != typeof s.priorityKeys,
              o = s;
            n && s[i] && (o = s[i]);
            for (var l = -1, h = 0, a = o.length; h < a; h += 2)
              if (o[h] == t && o[h + 1] == r) {
                l = h;
                break
              }
            if (l != -1)
              if (this._onFire.hasOwnProperty(e)) {
                o[l] = null;
                var p = this._deletedOnFire[e];
                p ? n && !p[i] && (p.priorityKeys.push(i), p = p[i] = []) : n ? (p = this._deletedOnFire[e] = {
                  priorityKeys: [i]
                }, p = p[i] = []) : p = this._deletedOnFire[e] = [], p[l] = !0
              } else 2 == a ? n ? (this._clearPriority(e, i), s.priorityKeys.length || this._clearType(e)) : this._clearType(e) : o.splice(l, 2)
          }
        },
        _callListeners: function(e, t) {
          for (var r = 0, i = e.length; r < i && !t.isImmediatePropagationStopped();) {
            var s = e[r];
            s && s.call(e[r + 1], t), r += 2
          }
        },
        _clearPriority: function(e, t) {
          for (var r = this.types[e], i = 0, s = r.priorityKeys.length; i < s; i++)
            if (r.priorityKeys[i] == t) {
              r.priorityKeys.splice(i, 1);
              break
            }
          delete this.types[e][t]
        },
        _clearType: function(e) {
          delete this.types[e], this.typesCount--, this.controllersHash.onStopListening && this.callControllers("onStopListening", this, e)
        },
        controllerMethods: ["onStartListening", "onStopListening"],
        callControllers: function(e, t, r, i) {
          for (var s, n = this.controllersHash[e], o = 0, l = n.length; o < l && (s = n[o][e](t, r, i), s !== !1); o++);
          return s
        },
        group: function() {
          return new i(this)
        },
        addController: function(e) {
          this.params.controllers.push(e), this._setupController(e)
        },
        _setupController: function(e) {
          for (var t = this.controllerMethods, r = 0, i = t.length; r < i; r++) {
            var s = t[r];
            e[s] && (this.controllersHash[s] ? this.controllersHash[s].push(e) : this.controllersHash[s] = [e])
          }
        },
        removeController: function(e) {
          var t = r.indexOf(this.params.controllers, e);
          if (t != -1) {
            1 == this.params.controllers.length ? this.params.controllers.pop() : this.params.controllers.splice(t, 1);
            for (var i = this.controllerMethods, s = 0, n = i.length; s < n; s++) {
              var o = i[s];
              if (e[o]) {
                var l = this.controllersHash[o];
                1 == l.length ? l[0] == e && l.pop() : (t = r.indexOf(l, e), t != -1 && l.splice(t, 1)), l.length || (this.controllersHash[o] = null)
              }
            }
          } else if (ym.env.debug) throw new Error("event.Manager.removeController: контроллер не найден")
        },
        once: function(e, t, r, i) {
          function s(n) {
            this.remove(e, s, this, i), r ? t.call(r, n) : t(n)
          }
          return this.add(e, s, this, i), this
        }
      }), e(s)
    });
  }],
  ['3q', function(ym) {
    ym.modules.define("event.Mapper", ["util.defineClass"], function(e, t) {
      function n(e, t) {
        this._targetEventManager = e, this._mappingTable = t
      }
      t(n, {
        getTargetEventManager: function() {
          return this._targetEventManager
        },
        setMappingTable: function(e) {
          this._mappingTable = e
        },
        getMappingTable: function() {
          return this._mappingTable
        },
        fire: function(e, t) {
          "undefined" == typeof this._mappingTable[e] && (e = "*");
          var n, a = this._mappingTable[e];
          return "function" == typeof a ? n = this._mappingTable[e](t) : a && (n = t), n && this._targetEventManager.fire(n.get("type"), n), this
        }
      }), e(n)
    });
  }],
  ['0D', function(ym) {
    ym.modules.define("formatter", ["localization.units.current", "localization.lib"], function(t, n, a) {
      var e = Math.log(10),
        i = {
          distance: function(t, n) {
            var e = a.UnitsTransform(ym.env.lang, "distance", t);
            return i.unit(i.toSignificantDigits(e.value, n || 2), "distance", e.name)
          },
          duration: function(t, n) {
            for (var e = a.UnitsTransform(ym.env.lang, "duration", t, n || 2), r = [], o = 0, l = e.length; o < l; o++) r.push(i.unit(e[o].value, "duration", e[o].name));
            return r.join(" ")
          },
          unit: function(t, a, e) {
            return i.numeral(t, n[a][e])
          },
          numeral: function(t, n) {
            var a, e = parseFloat(t);
            if ("string" == typeof n) a = n;
            else if (e > 10 && e < 20) a = n[2] || n[1];
            else switch (("" + e % 10).charAt(0)) {
              case "1":
                a = n[0];
                break;
              case "2":
              case "3":
              case "4":
                a = n[1];
                break;
              default:
                a = n[2] || n[1]
            }
            return a.replace("%d", t)
          },
          toSignificantDigits: function(t, n) {
            if (0 == t) return t;
            var a = Math.floor(Math.log(Math.abs(t)) / e),
              i = t / Math.pow(10, a),
              r = Math.abs(i * Math.pow(10, n - 1));
            Math.round(r).toString().length > Math.floor(r).toString().length && (a++, i = t / Math.pow(10, a), r = Math.abs(i * Math.pow(10, n - 1)));
            var o, l = Math.round(r).toString(),
              u = a + 1,
              s = (i < 0 ? "-" : "") + (u <= 0 ? "0." : "");
            if (u <= 0) {
              for (o = u; o < 0; o++) s += "0";
              s += l
            } else if (u >= n)
              for (s += l, o = n; o < u; o++) s += "0";
            else s += l.slice(0, u), l.length > u && (s += "." + l.slice(u));
            return s
          }
        };
      t(i)
    });
  }],
  ['0S', function(ym) {
    ym.modules.define("geocode", ["map.metaOptions", "yandex.geocodeProvider.storage", "vow", "yandex.counter", "yandex.geocodeProvider.metaOptions", "yandex.counter"], function(e, o, r, n, d) {
      function t(e, c) {
        c = c || {};
        var i = c.provider || o.get("geocodeProvider");
        if ("string" == typeof i) {
          var u = i;
          if (d.countByKey("modulesUsage", "geocode." + u.replace(/[^A-Za-z]/g, "_")), i = r.get(u), !i) {
            var a = n.defer();
            return r.require([u]).spread(function(o) {
              a.resolve(o.geocode(e, c))
            }, function() {
              a.reject(t.ProviderWasntFound())
            }), a.promise()
          }
        } else d.countByKey("modulesUsage", "geocode.custom");
        return i.geocode(e, c)
      }
      t.ProviderWasntFound = function() {
        return new Error("Provider wasn't found")
      }, e(t)
    });
  }],
  ['05', function(ym) {
    ym.modules.define("geolocation", function(e) {
      return ["vow", "util.extend", "util.defineClass", "util.bounds", "geocode", "Placemark", "GeoObjectCollection", "coordSystem.geo", "yandex.counter", "geolocationPreset." + (e.env.browser.oldIE ? "ie." : "standard.") + ("ru" == e.env.lang.slice(0, 2) ? "ru" : "en")]
    }, function(e, o, t, n, r, i, c, a, s, u) {
      function l(e, t) {
        var n = o.defer(),
          r = e.accuracy,
          a = e.position,
          s = {
            origin: P,
            geolocationAccuracy: r
          };
        return t.autoReverseGeocode ? (r >= f.locality && (s.kind = "locality"), i(a, s).then(function(e) {
          var o = e.geoObjects.get(0);
          o && g(o, a, r) ? (e.geoObjects.remove(o), n.resolve(v(o, a, r, t))) : n.reject("Not found")
        }, function(e) {
          n.reject(e)
        })) : n.resolve(v(new c(a), a, r, t)), n.promise()
      }

      function d(e) {
        var t = o.defer();
        return navigator.geolocation ? navigator.geolocation.getCurrentPosition(function(e) {
          t.resolve({
            position: "longlat" == ym.env.coordinatesOrder ? [e.coords.longitude, e.coords.latitude] : [e.coords.latitude, e.coords.longitude],
            accuracy: e.coords.accuracy
          })
        }, function(e) {
          t.reject(e)
        }, {
          enableHighAccuracy: !0,
          maximumAge: 6e4
        }) : t.reject("Geolocation API isn't supported"), t.promise().timeout(e)
      }

      function g(e, o, t) {
        return r.areIntersecting(e.properties.get("boundedBy") || p(e.geometry.getCoordinates(), t), p(o, t))
      }

      function p(e, o) {
        return [
          [s.solveDirectProblem(e, [-1, 0], o).endPoint[0], s.solveDirectProblem(e, [0, -1], o).endPoint[1]],
          [s.solveDirectProblem(e, [1, 0], o).endPoint[0], s.solveDirectProblem(e, [0, 1], o).endPoint[1]]
        ]
      }

      function v(e, o, t, n) {
        var r;
        return n.mapStateAutoApply && (r = t ? p(o, t) : e.geometry.getBounds()), e.geometry.setCoordinates(o), {
          geoObjects: new m(e, o, t, r, n)
        }
      }
      var m = n(function(e, o, t, n, r) {
          m.superclass.constructor.call(this, {}, {
            preset: "islands#geolocationIcon"
          }), this.position = o, this.accuracy = t, this.add(e), n && this.events.once("mapchange", function() {
            this.getMap().setBounds(n, {
              checkZoomRange: !0,
              useMapMargin: r.useMapMargin,
              duration: 400
            })
          }, this)
        }, a),
        y = ym.env.geolocation,
        f = {
          precise: 10,
          locality: 2e3,
          region: 1e4
        },
        h = "longlat" == ym.env.coordinatesOrder ? [y.longitude, y.latitude] : [y.latitude, y.longitude],
        b = {
          position: h,
          accuracy: y.isHighAccuracy ? f.precise : y.span.longitude || y.span.latitude ? Math.max(s.getDistance(h, "longlat" == ym.env.coordinatesOrder ? [h[0] + y.span.longitude, h[1]] : [h[0], h[1] + y.span.longitude]), s.getDistance(h, "longlat" == ym.env.coordinatesOrder ? [h[0], h[1] + y.span.latitude] : [h[0] + y.span.latitude, h[1]])) : f.region
        },
        P = "jsapi21Geolocation";
      e({
        get: function(e) {
          if (e = t({
              provider: "auto",
              mapStateAutoApply: !1,
              useMapMargin: !0,
              autoReverseGeocode: !0,
              timeout: 3e4
            }, e), u.countByKey("modulesUsage", "geolocation.get." + e.provider), "yandex" == e.provider || "auto" == e.provider && b.accuracy <= 10) return l(b, e);
          var n = o.defer();
          return "browser" == e.provider ? d(e.timeout).then(function(o) {
            n.resolve(l(o, e))
          }, function(e) {
            n.reject(e)
          }) : d(e.timeout).then(function(o) {
            n.resolve(l(o.accuracy > b.accuracy ? b : o, e))
          }, function() {
            n.resolve(l(b, e))
          }), n.promise()
        }
      })
    });
  }],
  ['$1', function(ym) {
    var images = ym.modules.importImages({
      geolocationIcon: {
        src: "../../YaRu.svg",
        optimization: {
          dataUrl: !0
        }
      }
    });
    ym.modules.define("geolocationPreset.standard.ru", ["option.presetStorage", "layout.Image"], function(o, e, a) {
      e.add("islands#geolocationIcon", {
        iconLayout: a,
        iconImageHref: images.get("geolocationIcon"),
        iconImageSize: [22, 22],
        iconImageOffset: [-11, -11],
        cursor: "inherit"
      }), o(!0)
    });
  }],
  ['$2', function(ym) {
    ym.modules.define("geometry.base.Circle", ["event.Manager", "util.extend", "component.EventFreezer", "geometry.component.commonMethods.circle"], function(t, e, n, i, r) {
      var s = r,
        o = function(t, n) {
          this._coordinates = o.castCoordinates(t), this._radius = o.castRadius(n), this._freezer = new i(this._changeCallback, this), this.events = new e({
            context: this
          })
        };
      o.castCoordinates = function(t) {
        if (ym.env.debug && t && (!t.length || 2 != t.length || "number" != typeof t[0])) throw new Error("CircleGeometry.castCoordinates: Неверный формат координат круга.");
        return t || null
      }, o.castRadius = function(t) {
        return t || 0
      }, n(o.prototype, {
        getType: function() {
          return "Circle"
        },
        getBounds: function() {
          return this._bounds || (this._bounds = this._calculateBounds())
        },
        setCoordinates: function(t) {
          var e = this._coordinates;
          return this._coordinates = t, this._bounds = null, this._freezer.fire("Coordinates", e, this._coordinates), this
        },
        getCoordinates: function() {
          return this._coordinates
        },
        getCenter: function() {
          return this._coordinates
        },
        setRadius: function(t) {
          var e = this._radius;
          return this._radius = t, this._bounds = null, this._freezer.fire("Radius", e, this._radius), this
        },
        getRadius: function() {
          return this._radius
        },
        freeze: function() {
          return this._freezer.freeze(), this
        },
        unfreeze: function() {
          return this._freezer.unfreeze(), this
        },
        isFrozen: function() {
          return this._freezer.isFrozen()
        },
        contains: function(t) {
          return s.contains(this._coordinates, this._radius, t)
        },
        getClosest: function(t) {
          return s.getClosest(this._coordinates, this._radius, t)
        },
        _calculateBounds: function() {
          return s.calculateBounds(this._coordinates, this._radius)
        },
        _changeCallback: function(t) {
          this.events.fire("change", n({
            type: "change",
            target: this
          }, t))
        }
      }), t(o)
    });
  }],
  ['$5', function(ym) {
    ym.modules.define("geometry.base.LinearRing", ["event.Manager", "util.extend", "util.coordinates.encode", "util.pixelBounds", "geometry.component.pointInPolygon", "geometry.component.findClosestPathPosition", "component.EventFreezer", "geometry.component.closedPathDecode", "geometry.component.CoordPath", "geometry.component.ChildPath", "geometry.component.FillRule", "util.math.areEqual", "geometry.base.Point"], function(e, t, o, n, i, s, r, h, l, c, d, a, u, g) {
      function C(e, t) {
        var o = this._getNonClosedCoords();
        o[t] = e.getCoordinates(), this._setNonClosedCoords(o)
      }

      function f(e, t) {
        this._freezer.fire("Coordinates", e, t)
      }

      function _(e) {
        return i.fromPoints(e)
      }

      function p(e, t) {
        this._freezer.fire("FillRule", e, t)
      }
      var P = function(e, o) {
        this._coordPath = new c(P.keepClosed(e || [], !0), {
          callback: f,
          context: this
        }, {
          callback: _,
          context: this
        }), this._childPath = new d([], g, ["change"], {
          callback: C,
          context: this
        }), this._fillRuleComponent = new a(o, {
          callback: p,
          context: this
        }), this._freezer = new h(this._changeCallback, this), this.events = new t({
          context: this
        })
      };
      P.keepClosed = function(e, t) {
        var o = e.length;
        return (1 == o || o > 1 && !u(e[0], e[o - 1])) && (t && (e = e.slice()), e.push(e[0])), e
      }, P.fromEncodedCoordinates = function(e) {
        return new P(l(e))
      }, P.toEncodedCoordinates = function(e) {
        if (ym.env.debug && "LinearRing" != e.getType()) throw new Error("geometry.base.LinearRing.toEncodedCoordinates: неверный тип геометрии: " + e.getType());
        return n(e.getCoordinates())
      }, o(P.prototype, {
        getType: function() {
          return "LinearRing"
        },
        getBounds: function() {
          return this._coordPath.getBounds()
        },
        set: function(e, t) {
          this._childPath.setChild(e, null);
          var o = this._getNonClosedCoords();
          return o[e] = t, this._setNonClosedCoords(o), this
        },
        get: function(e) {
          return this._coordPath.get(e)
        },
        getChildGeometry: function(e) {
          return e == this._coordPath.getLength() - 1 && (e = 0), this._childPath.getChild(e) || this._childPath.createChild(e, this._coordPath.get(e))
        },
        remove: function(e) {
          this._childPath.splice(e, 1);
          var t = this._getNonClosedCoords(),
            o = t.splice(e, 1)[0];
          return this._setNonClosedCoords(t), o
        },
        insert: function(e, t) {
          this._childPath.splice(e, 0, null);
          var o = this._getNonClosedCoords();
          return o.splice(e, 0, t), this._setNonClosedCoords(o), this
        },
        splice: function(e, t) {
          arguments.length > 2 ? this._childPath.splice.apply(this._childPath, [e, t].concat(new Array(arguments.length - 2))) : this._childPath.splice(e, t);
          var o = this._getNonClosedCoords(),
            n = arguments.length > 2 ? o.splice.apply(o, arguments) : o.splice(e, t);
          return this._setNonClosedCoords(o), n
        },
        setCoordinates: function(e) {
          return this._childPath.setChildren([]), this._coordPath.setCoordinates(P.keepClosed(e, !0)), this
        },
        getCoordinates: function() {
          return this._coordPath.getCoordinates()
        },
        getLength: function() {
          return this._coordPath.getLength()
        },
        setFillRule: function(e) {
          return this._fillRuleComponent.setFillRule(e), this
        },
        getFillRule: function() {
          this._fillRuleComponent.getFillRule()
        },
        freeze: function() {
          return this._freezer.freeze(), this
        },
        unfreeze: function() {
          return this._freezer.unfreeze(), this
        },
        isFrozen: function() {
          return this._freezer.isFrozen()
        },
        contains: function(e) {
          return s(e, [this._coordPath.getCoordinates()], this._fillRuleComponent.getFillRule())
        },
        getClosest: function(e) {
          return r(this._coordPath.getCoordinates(), e)
        },
        _getNonClosedCoords: function() {
          return this._coordPath.getCoordinates().slice(0, this._coordPath.getLength() - 1)
        },
        _setNonClosedCoords: function(e) {
          this._coordPath.setCoordinates(P.keepClosed(e))
        },
        _changeCallback: function(e) {
          this.events.fire("change", o({
            type: "change",
            target: this
          }, e))
        }
      }), e(P)
    });
  }],
  ['$3', function(ym) {
    ym.modules.define("geometry.base.LineString", ["util.defineClass", "event.Manager", "geometry.component.findClosestPathPosition", "component.EventFreezer", "geometry.component.CoordPath", "geometry.component.ChildPath", "geometry.base.Point", "util.extend", "util.coordinates.encode", "util.coordinates.decode", "util.pixelBounds"], function(t, e, n, i, o, r, h, s, c, a, d, u) {
      function l(t, e) {
        this._coordPath.set(e, t.getCoordinates())
      }

      function g(t, e) {
        this._freezer.fire("Coordinates", t, e)
      }

      function f(t) {
        return u.fromPoints(t)
      }
      var _ = function(t) {
        this._coordPath = new r(t || [], {
          callback: g,
          context: this
        }, {
          callback: f,
          context: this
        }), this._childPath = new h([], s, ["change"], {
          callback: l,
          context: this
        }), this._freezer = new o(this._changeCallback, this), this.events = new n({
          context: this
        })
      };
      _.fromEncodedCoordinates = function(t) {
        return new _(d(t))
      }, _.toEncodedCoordinates = function(t) {
        if (ym.env.debug && "LineString" != t.getType()) throw new Error("geometry.base.LineString.toEncodedCoordinates: неверный тип геометрии: " + t.getType());
        return a(t.getCoordinates())
      }, e(_, {
        getType: function() {
          return "LineString"
        },
        getBounds: function() {
          return this._coordPath.getBounds()
        },
        set: function(t, e) {
          return this._childPath.setChild(t, null), this._coordPath.set(t, e), this
        },
        get: function(t) {
          return this._coordPath.get(t)
        },
        getChildGeometry: function(t) {
          return this._childPath.getChild(t) || this._childPath.createChild(t, this._coordPath.get(t))
        },
        remove: function(t) {
          return this._childPath.splice(t, 1), this._coordPath.splice(t, 1)[0]
        },
        insert: function(t, e) {
          return this._childPath.splice(t, 0, null), this._coordPath.splice(t, 0, e), this
        },
        splice: function(t, e) {
          return arguments.length > 2 ? this._childPath.splice.apply(this._childPath, [t, e].concat(new Array(arguments.length - 2))) : this._childPath.splice(t, e), arguments.length > 2 ? this._coordPath.splice.apply(this._coordPath, arguments) : this._coordPath.splice(t, e)
        },
        setCoordinates: function(t) {
          return this._childPath.setChildren([]), this._coordPath.setCoordinates(t), this
        },
        getCoordinates: function() {
          return this._coordPath.getCoordinates()
        },
        getLength: function() {
          return this._coordPath.getLength()
        },
        freeze: function() {
          return this._freezer.freeze(), this
        },
        unfreeze: function() {
          return this._freezer.unfreeze(), this
        },
        isFrozen: function() {
          return this._freezer.isFrozen()
        },
        getClosest: function(t) {
          return i(this._coordPath.getCoordinates(), t)
        },
        _changeCallback: function(t) {
          this.events.fire("change", c({
            type: "change",
            target: this
          }, t))
        }
      }), t(_)
    });
  }],
  ['$6', function(ym) {
    ym.modules.define("geometry.base.Point", ["util.extend", "event.Manager"], function(t, n, e) {
      var o = function(t) {
        this._coordinates = t || null, this.events = new e({
          context: this
        })
      };
      n(o.prototype, {
        getType: function() {
          return "Point"
        },
        setCoordinates: function(t) {
          this._bounds = null;
          var n = this._coordinates;
          this._coordinates = t, this.events.fire("change", {
            oldCoordinates: n,
            newCoordinates: this._coordinates
          })
        },
        getCoordinates: function() {
          return this._coordinates
        },
        getBounds: function() {
          return this._bounds || (this._bounds = this._coordinates ? [this._coordinates.slice(), this._coordinates.slice()] : null)
        }
      }), t(o)
    });
  }],
  ['$8', function(ym) {
    ym.modules.define("geometry.base.Polygon", ["event.Manager", "util.extend", "util.coordinates.encode", "component.EventFreezer", "geometry.component.closedPathDecode", "geometry.component.CoordPath", "geometry.component.ChildPath", "geometry.component.FillRule", "geometry.component.commonMethods.polygon", "geometry.base.LinearRing"], function(e, t, n, o, i, r, h, s, c, l, a) {
      function u(e, t) {
        this._coordPath.set(t, e.getCoordinates())
      }

      function d(e, t) {
        this._freezer.fire("Coordinates", e, t)
      }

      function g(e) {
        return p.calculateBounds(e)
      }

      function f(e, t) {
        this._freezer.fire("FillRule", e, t)
      }
      var p = l,
        _ = function(e, n) {
          this._coordPath = new h(_.keepClosed(e || []), {
            callback: d,
            context: this
          }, {
            callback: g,
            context: this
          }), this._childPath = new s([], a, ["change"], {
            callback: u,
            context: this
          }), this._fillRuleComponent = new c(n, {
            callback: f,
            context: this
          }), this._freezer = new i(this._changeCallback, this), this.events = new t({
            context: this
          })
        };
      _.keepClosed = function(e) {
        for (var t = 0, n = e.length, o = e; t < n; t++) {
          var i = e[t],
            r = a.keepClosed(i, !0);
          i !== r && (o == e && (o = e.slice()), o[t] = r)
        }
        return o
      }, _.fromEncodedCoordinates = function(e) {
        for (var t = e.split(";"), n = [], o = 0, i = t.length; o < i; o++) n.push(r(t[o]));
        return new _(n)
      }, _.toEncodedCoordinates = function(e) {
        if (ym.env.debug && "Polygon" != e.getType()) throw new Error("geometry.base.Polygon.toEncodedCoordinates: неверный тип геометрии: " + e.getType());
        for (var t = [], n = 0, i = e.getLength(); n < i; n++) t.push(o(e.get(n)));
        return t.join(";")
      }, n(_.prototype, {
        getType: function() {
          return "Polygon"
        },
        getBounds: function() {
          return this._coordPath.getBounds()
        },
        set: function(e, t) {
          return this._childPath.setChild(e, null), this._coordPath.set(e, a.keepClosed(t)), this
        },
        get: function(e) {
          return this._coordPath.get(e)
        },
        getChildGeometry: function(e) {
          return this._childPath.getChild(e) || this._childPath.createChild(e, this._coordPath.get(e))
        },
        remove: function(e) {
          return this._childPath.splice(e, 1), this._coordPath.splice(e, 1)[0]
        },
        insert: function(e, t) {
          return this._childPath.splice(e, 0, null), this._coordPath.splice(e, 0, a.keepClosed(t)), this
        },
        splice: function(e, t) {
          return arguments.length > 2 ? this._childPath.splice.apply(this._childPath, [e, t].concat(new Array(arguments.length - 2))) : this._childPath.splice(e, t), arguments.length > 2 ? this._coordPath.splice.apply(this._coordPath, [e, t].concat(_.keepClosed(Array.prototype.slice.call(arguments, 2)))) : this._coordPath.splice(e, t)
        },
        setCoordinates: function(e) {
          return e = _.keepClosed(e), this._childPath.setChildren([]), this._coordPath.setCoordinates(e), this
        },
        getCoordinates: function() {
          return this._coordPath.getCoordinates()
        },
        getLength: function() {
          return this._coordPath.getLength()
        },
        setFillRule: function(e) {
          return this._fillRuleComponent.setFillRule(e), this
        },
        getFillRule: function() {
          return this._fillRuleComponent.getFillRule()
        },
        freeze: function() {
          return this._freezer.freeze(), this
        },
        unfreeze: function() {
          return this._freezer.unfreeze(), this
        },
        isFrozen: function() {
          return this._freezer.isFrozen()
        },
        contains: function(e) {
          return p.contains(this._coordPath.getCoordinates(), e, this._fillRuleComponent.getFillRule())
        },
        getClosest: function(e) {
          return p.getClosest(this._coordPath.getCoordinates(), e)
        },
        _changeCallback: function(e) {
          this.events.fire("change", n({
            type: "change",
            target: this
          }, e))
        }
      }), e(_)
    });
  }],
  ['$9', function(ym) {
    ym.modules.define("geometry.base.Rectangle", ["event.Manager", "util.extend", "geometry.component.commonMethods.rectangle"], function(t, e, n, o) {
      var s = o,
        i = function(t) {
          this._coordinates = i.keepСonsistent(t), this.events = new e({
            context: this
          })
        };
      i.keepСonsistent = function(t) {
        var e = null;
        return t && t.length && (e = t, 2 != t.length && (e = e.slice(0, 2), 1 == t.length && (e[1] = e[0].slice()))), e
      }, n(i.prototype, {
        getType: function() {
          return "Rectangle"
        },
        getBounds: function() {
          return this._bounds || (this._bounds = s.calculateBounds(this._coordinates))
        },
        setCoordinates: function(t) {
          var e = this._coordinates;
          return this._coordinates = i.keepСonsistent(t), this._bounds = null, this._fireChangeEvent(e, this._coordinates), this
        },
        getCoordinates: function() {
          return this._coordinates
        },
        getClosest: function(t) {
          return s.getClosest(this._coordinates, t)
        },
        contains: function(t) {
          return s.contains(this._coordinates, t)
        },
        _fireChangeEvent: function(t, e) {
          this.events.fire("change", {
            oldCoordinates: t,
            newCoordinates: e
          })
        }
      }), t(i)
    });
  }],
  ['$Z', function(ym) {
    ym.modules.define("geometry.Circle", ["util.defineClass", "option.Manager", "geometry.base.Circle", "geometry.pixel.Circle", "geometry.component.renderFlowManager", "geometry.component.pixelGeometryGeodesic.circle", "geometry.component.renderFlow.stageScale", "geometry.component.renderFlow.stageShift", "geometry.defaultOptions", "geometry.component.boundsFromPixels", "geometry.component.pixelGetClosest", "util.getPixelRadius", "geometry.component.pixelContains", "util.matrix.2d", "Event"], function(e, t, o, n, i, r, s, a, l, c, g, p, m, h, u, d) {
      function y() {
        this.events.fire("optionschange")
      }

      function f(e) {
        this._bounds = null, this.events.fire("pixelgeometrychange", new d({
          type: "pixelgeometrychange",
          target: this,
          pixelGeometry: e
        }))
      }

      function v(e, t) {
        if (ym.env.debug && !t.projection) throw new Error("geometry.Circle._renderingStageBasePixels: значение опции projection не определено");
        return e ? t.geodesic ? w(e, this.getRadius(), t) : new i(t.projection.toGlobalPixels(e, 0), m(e, this.getRadius(), t.projection, 0)) : new i
      }
      var w = s,
        x = function(e, t, n) {
          x.superclass.constructor.call(this, e, t), this.options = new o(n), this.options.events.add("change", y, this)
        };
      t(x, n, {
        getBounds: function() {
          return this._bounds || (this._bounds = g.get(this))
        },
        getPixelGeometry: function(e) {
          if (ym.env.debug && !this._map) throw new Error("geometry.main.Circle.getPixelGeometry: Не задана карта.");
          return this._map ? r.getPixelGeometry(this, e) : null
        },
        setMap: function(e) {
          var t = this._map;
          t && this._clearRenderFlow(), this._map = e, e && this._setupRenderFlow(), this.events.fire("mapchange", new d({
            type: "mapchange",
            target: this,
            newMap: this._map,
            oldMap: t
          }))
        },
        getMap: function() {
          return this._map
        },
        contains: function(e) {
          return h(this, e)
        },
        getClosest: function(e) {
          var t = p(this, e),
            o = this.options.get("projection");
          if (ym.env.debug && "object" != typeof o) throw new Error("geometry.Circle.getClosest: В опциях геометрии не определена проекция.");
          return t && (t.position = o.fromGlobalPixels(t.position, this._map.getZoom()), t.distance = o.getCoordSystem().getDistance(e, t.position)), t
        },
        applyProjectedTransformation: function(e) {
          var t = this.options.get("projection"),
            o = this.getMap().action.getCurrentState().zoom,
            n = t.toGlobalPixels(this.getCoordinates(), o),
            i = [];
          u.applyToPoint(i, n, e), this.setCoordinates(t.fromGlobalPixels(i, o))
        },
        _setupRenderFlow: function() {
          var e = C;
          e[0].stage = this.getCoordinates, r.add(this, e, c, f)
        },
        _clearRenderFlow: function() {
          r.remove(this, C)
        }
      });
      var C = [{
        stage: null,
        event: {
          target: "self",
          event: "change"
        }
      }, {
        stage: v,
        options: ["projection", "geodesic"]
      }, {
        stage: a.apply,
        event: {
          target: "map",
          event: "actionend",
          callback: a.onActionEnd
        }
      }, {
        stage: l.apply,
        options: ["projection", "pixelRendering"],
        event: {
          target: "map",
          event: "actionend",
          callback: l.onActionEnd
        }
      }];
      e(x)
    });
  }],
  ['$-', function(ym) {
    ym.modules.define("geometry.component.anchor", [], function(t) {
      var o = {
        getAnchor: function(t, o, r) {
          var e, n = Math.floor(o / r),
            h = (e = o % r) >= 0 ? e : r + e,
            a = (e = t % r) >= 0 ? e : r + e,
            c = this.getShortestPathWorld(a, h, r);
          return a + r * (n + c)
        },
        getShortestPathWorld: function(t, o, r) {
          var e = r / 2;
          return t >= e == o >= e ? 0 : t < e ? o - t <= e ? 0 : 1 : o < e ? t - o <= e ? 0 : -1 : 0
        }
      };
      t(o)
    });
  }],
  ['$_', function(ym) {
    ym.modules.define("geometry.component.boundsFromPixels", ["util.bounds"], function(e, o) {
      function n(e) {
        var n = e.getPixelGeometry({
          simplification: !1,
          pixelRendering: "static"
        });
        if (n) {
          var t = n.getBounds();
          return t ? o.fromGlobalPixelBounds(t, e.getMap().getZoom(), e.options.get("projection")) : null
        }
        throw new Error("geometry.component.getBoundsFromPixels: Расчет границ не возможен без добавления на карту.")
      }
      e({
        get: n
      })
    });
  }],
  ['$!', function(ym) {
    ym.modules.define("geometry.component.ChildPath", ["util.bind", "util.array"], function(i, t, e) {
      function l(i, t, l) {
        if (e.indexOf(this._changeEvents, t) != -1) {
          var n = l.get("target"),
            h = e.indexOf(this._children, n);
          this._changeCallback.callback.call(this._changeCallback.context, n, h)
        }
      }
      var n = function(i, e, n, h) {
        this._children = i, this._setupChildren(i), this._childClass = e, this._changeEvents = n, this._changeCallback = h, this._childEventController = {
          onAfterEventFiring: t(l, this)
        }
      };
      n.prototype = {
        setChild: function(i, t) {
          this._children[i] && this._clearChild(this._children[i]), this._children[i] = t, t && this._setupChild(t)
        },
        getChild: function(i) {
          return this._children[i]
        },
        createChild: function(i, t) {
          var e = null;
          return t && (e = new this._childClass(t), this._setupChild(e)), this._children[i] = e
        },
        splice: function(i, t) {
          var e;
          return arguments.length > 2 ? (this._setupChildren(Array.prototype.slice.call(arguments, 2)), e = this._children.splice.apply(this._children, arguments)) : e = this._children.splice(i, t), this._clearChildren(e), e
        },
        setChildren: function(i) {
          this._clearChildren(this._children), this._children = i, this._setupChildren(i)
        },
        _setupChild: function(i) {
          i.events.addController(this._childEventController)
        },
        _clearChild: function(i) {
          i.events.removeController(this._childEventController)
        },
        _setupChildren: function(i) {
          for (var t = 0, e = i.length; t < e; t++) i[t] && this._setupChild(i[t])
        },
        _clearChildren: function(i) {
          for (var t = 0, e = i.length; t < e; t++) i[t] && this._clearChild(i[t])
        }
      }, i(n)
    });
  }],
  ['$*', function(ym) {
    ym.modules.define("geometry.component.closedPathDecode", ["util.coordinates.decode", "util.math.areEqual"], function(e, o, t) {
      var n = 1e6,
        c = 1 / n + 1e-12;
      e(function(e) {
        var n = o(e),
          a = n.length - 1;
        return a < 0 ? [] : (t(n[0], n[a], c) && (n[a] = n[0].slice()), n)
      })
    });
  }],
  [',D', function(ym) {
    ym.modules.define("geometry.component.commonMethods.circle", [], function(t) {
      t({
        contains: function(t, n, o) {
          return !(!t || !n) && Math.sqrt(Math.pow(o[0] - t[0], 2) + Math.pow(o[1] - t[1], 2)) < n
        },
        getClosest: function(t, n, o) {
          if (!t || !n) return null;
          var e = [o[0] - t[0], o[1] - t[1]],
            i = Math.sqrt(e[0] * e[0] + e[1] * e[1]);
          return 0 == i ? {
            position: [t[0], t[1] + n],
            distance: n
          } : {
            position: [t[0] + e[0] * n / i, t[1] + e[1] * n / i],
            distance: Math.abs(i - n)
          }
        },
        calculateBounds: function(t, n) {
          return t ? [
            [t[0] - n, t[1] - n],
            [t[0] + n, t[1] + n]
          ] : null
        }
      })
    });
  }],
  [',E', function(ym) {
    ym.modules.define("geometry.component.commonMethods.polygon", ["geometry.component.pointInPolygon", "geometry.component.findClosestPathPosition", "util.pixelBounds"], function(n, o, t, e) {
      n({
        contains: function(n, t, e) {
          return o(t, n, e)
        },
        getClosest: function(n, o) {
          for (var e = null, r = 0, i = n.length; r < i; r++) {
            var l = t(n[r], o);
            l && (!e || l.distance < e.distance) && (e = l, e.pathIndex = r)
          }
          return e
        },
        calculateBounds: function(n) {
          for (var o = null, t = 0, r = n.length; t < r; t++) {
            var i = e.fromPoints(n[t]);
            i && (o = o ? e.fromBounds([o, i]) : i)
          }
          return o
        }
      })
    });
  }],
  [',F', function(ym) {
    ym.modules.define("geometry.component.commonMethods.rectangle", ["util.pixelBounds", "geometry.component.findClosestPathPosition"], function(n, t, o) {
      n({
        contains: function(n, o) {
          return t.containsPoint(this.calculateBounds(n), o)
        },
        getClosest: function(n, t) {
          var e = this.calculateBounds(n),
            i = [e[0],
              [e[1][0], e[0][1]], e[1],
              [e[0][0], e[1][1]], e[0]
            ],
            s = o(i, t);
          return {
            position: s.position,
            distance: s.distance
          }
        },
        calculateBounds: function(n) {
          return t.fromPoints(n || [])
        }
      })
    });
  }],
  ['$,', function(ym) {
    ym.modules.define("geometry.component.CoordPath", [], function(t) {
      var n = function(t, n, o) {
        this._coordinates = t, this._changeCallback = n, this._boundsCallback = o
      };
      n.prototype = {
        getBounds: function() {
          return this._bounds || (this._bounds = this._boundsCallback.callback.call(this._boundsCallback.context, this._coordinates))
        },
        set: function(t, n) {
          var o = this._coordinates;
          this._coordinates = this._coordinates.slice(), this._coordinates[t] = n, this._bounds = null, this._changeCallback.callback.call(this._changeCallback.context, o, this._coordinates)
        },
        get: function(t) {
          return this._coordinates[t]
        },
        splice: function(t, n) {
          var o = this._coordinates;
          this._coordinates = this._coordinates.slice();
          var s = arguments.length > 2 ? this._coordinates.splice.apply(this._coordinates, arguments) : this._coordinates.splice(t, n);
          return this._bounds = null, this._changeCallback.callback.call(this._changeCallback.context, o, this._coordinates), s
        },
        setCoordinates: function(t) {
          var n = this._coordinates;
          this._coordinates = t, this._bounds = null, this._changeCallback.callback.call(this._changeCallback.context, n, this._coordinates)
        },
        getCoordinates: function() {
          return this._coordinates
        },
        getLength: function() {
          return this._coordinates.length
        }
      }, t(n)
    });
  }],
  ['$:', function(ym) {
    ym.modules.define("geometry.component.FillRule", [], function(l) {
      var e = ["evenOdd", "nonZero"],
        i = function(l, i) {
          if (this._fillRule = l || e[0], ym.env.debug) {
            for (var t, n = 0, o = e.length; n < o; n++)
              if (this._fillRule == e[n]) {
                t = !0;
                break
              }
            if (!t) throw new Error("geometry.component.FillRule: неверное значение параметра fillRule " + this._fillRule)
          }
          this._changeCallback = i
        };
      i.prototype = {
        setFillRule: function(l) {
          if (ym.env.debug) {
            for (var i, t = 0, n = e.length; t < n; t++)
              if (l == e[t]) {
                i = !0;
                break
              }
            if (!i) throw new Error("geometry.component.FillRule.setFillRule: неверное значение параметра fillRule " + l)
          }
          var o = this._fillRule;
          this._fillRule = l, this._changeCallback.callback.call(this._changeCallback.context, o, this._fillRule)
        },
        getFillRule: function() {
          return this._fillRule
        }
      }, l(i)
    });
  }],
  ['$)', function(ym) {
    ym.modules.define("geometry.component.findClosestPathPosition", ["util.vector"], function(t, n) {
      var e = n.length2;
      t(function(t, n) {
        if (!t.length) return null;
        for (var o, i, r = t[0], c = [n[0] - r[0], n[1] - r[1]], s = e(c), d = {
            position: r,
            vector: c,
            closestPointIndex: 0,
            distance: s
          }, v = 1, x = t.length; v < x; v++)
          if (i = t[v], r[0] != i[0] || r[1] != i[1]) {
            var P, a = [i[0] - r[0], i[1] - r[1]],
              l = [n[0] - r[0], n[1] - r[1]],
              I = (a[0] * l[0] + a[1] * l[1]) / (a[0] * a[0] + a[1] * a[1]);
            I < 0 ? P = {
              position: r,
              vector: [r[0] - n[0], r[1] - n[1]],
              closestPointIndex: v - 1
            } : I > 1 ? P = {
              position: i,
              vector: [i[0] - n[0], i[1] - n[1]],
              closestPointIndex: v
            } : (o = [a[0] * I - l[0], a[1] * I - l[1]], P = {
              vector: o,
              prevPointIndex: v - 1,
              nextPointIndex: v
            }), P.distance = P.vector[0] * P.vector[0] + P.vector[1] * P.vector[1], P.distance < s && (s = P.distance, d = P), r = i
          }
        if (d.nextPointIndex) {
          o = d.vector, r = t[d.prevPointIndex], i = t[d.nextPointIndex];
          var f = [n[0] + o[0], n[1] + o[1]],
            p = [f[0] - r[0], f[1] - r[1]],
            u = [f[0] - i[0], f[1] - i[1]];
          d.position = f, d.closestPointIndex = e(p) < e(u) ? d.prevPointIndex : d.nextPointIndex
        }
        return d.distance = Math.sqrt(d.distance), d
      })
    });
  }],
  ['$@', function(ym) {
    ym.modules.define("geometry.component.pixelContains", [], function(o) {
      o(function(o, e) {
        var t = o.getMap();
        if ("undefined" == typeof t) throw new Error("geometry.component.pixelContains: Для рассчета вхождения точки геометрия должна быть добавлена на карту.");
        for (var n = o.getPixelGeometry({
            simplification: !1,
            pixelRendering: "static",
            geodesic: o.options.get("geodesic")
          }), i = 256 * Math.pow(2, t.getZoom()), r = n.getBounds(), a = [
            [Math.floor(r[0][0] / i), Math.floor(r[0][1] / i)],
            [Math.floor(r[1][0] / i), Math.floor(r[1][1] / i)]
          ], f = o.options.get("projection"), l = f.isCycled(), s = l[0] ? 1 : 0, g = l[1] ? 1 : 0, p = f.toGlobalPixels(e, t.getZoom()), c = a[0][0]; c <= a[1][0]; c++)
          for (var m = a[0][1]; m <= a[1][1]; m++)
            if (n.contains([p[0] + s * c * i, p[1] + g * m * i])) return !0;
        return !1
      })
    });
  }],
  [',G', function(ym) {
    ym.modules.define("geometry.component.pixelGeometryGeodesic.circle", ["geometry.component.pixelGeometryGeodesic.storage", "geometry.pixel.Polygon", "geometry.component.ShortestPath"], function(e, o, t, r) {
      function n(e, o, n) {
        var c, i, l = [],
          m = n.projection.getCoordSystem(),
          s = 2 * Math.PI,
          a = Math.PI / 40;
        if (ym.env.debug && "function" != typeof m.solveDirectProblem) throw new Error("geometry.component.pixelGeometryGeodesic.circle: Отсутствует обязательный метод solveDirectProblem у координатной системы.");
        for (var y = 0; y <= s; y += a) i = "latlong" == ym.env.coordinatesOrder ? [Math.cos(y), Math.sin(y)] : [Math.sin(y), Math.cos(y)], c = m.solveDirectProblem(e, i, o), l.push(n.projection.toGlobalPixels(c.endPoint, 0));
        return l = (new r).calculate(l, n.projection.isCycled()), new t([l], "nonZero")
      }
      o.add("Circle", n), e(n)
    });
  }],
  [',H', function(ym) {
    ym.modules.define("geometry.component.pixelGeometryGeodesic.lineString", ["geometry.component.pixelGeometryGeodesic.storage", "geometry.component.ShortestPath", "util.math.cycleRestrict"], function(e, t, n, o) {
      function i(e, t) {
        var o = t.getCoordSystem(),
          i = e.getCoordinates(),
          a = e.getMetaData().originalIndexes || [],
          l = new n;
        if (!i.length) return e;
        if (ym.env.debug && "function" != typeof o.solveDirectProblem) throw new Error("geometry.component.pixelGeometryGeodesic.lineString: Отсутствует обязательный метод solveDirectProblem у координатной системы.");
        for (var c, s, d, h, p = t.fromGlobalPixels(i[0], 0), u = {
            pixelPath: [i[0]],
            indexes: [a[0] || 0]
          }, m = t.isCycled(), f = 1, g = i.length; f < g; f++) {
          c = t.fromGlobalPixels(i[f], 0), s = m[0] && Math.abs(i[f][0] - i[f - 1][0]) > 128 || m[1] && Math.abs(i[f][1] - i[f - 1][1]) > 128, d = r(o, p, c, s), h = [];
          for (var P = 1, x = d.length, y = x - 1; P < x; P++) h.push(t.toGlobalPixels(d[P], 0)), u.indexes.push(P < y ? -1 : a[f] || f);
          s || (h.unshift(i[f - 1]), h = l.calculate(h, m, {
            unbounded: !0
          }), h.shift()), u.pixelPath = u.pixelPath.concat(h), p = c
        }
        return e.clone(u.pixelPath, {
          originalIndexes: u.indexes
        })
      }

      function r(e, t, n, o) {
        for (var i = e.solveInverseProblem(t, n, o), r = [t], l = 0, c = 3; l < c; l++) r = r.concat(a(i.pathFunction, l / c, (l + 1) / c, 0 == l ? {
          point: i.startPoint,
          direction: i.startDirection
        } : null, l == c - 1 ? {
          point: i.endPoint,
          direction: i.endDirection
        } : null));
        return r
      }

      function a(e, t, n, i, r) {
        i = i || e(t), r = r || e(n);
        var l, c, s, d = Math.PI / 60,
          h = Math.PI / 4,
          p = [],
          u = Math.abs(o(Math.atan2(i.direction[0], i.direction[1]) - Math.atan2(r.direction[0], r.direction[1]), -Math.PI, Math.PI)),
          m = 0;
        if (Math.abs(u - Math.PI) < 1e-10) {
          var f, g;
          "latlong" == ym.env.coordinatesOrder ? (f = [90 * i.direction[0], i.point[1]], g = [90 * i.direction[0], r.point[1]]) : (f = [i.point[0], 90 * i.direction[1]], g = [r.point[0], 90 * i.direction[1]]), p.push(f, g, r.point)
        } else if (u > d)
          if (c = Math.ceil(u / d), c < h / d) {
            l = (n - t) / c;
            for (var P = 1; P <= c; P++) p.push(e(t + l * P).point)
          } else l = (n - t) / 2, m = t + l, s = e(m), p = p.concat(a(e, t, m, i, s)), p = p.concat(a(e, m, n, s, r));
        else p.push(r.point);
        return p
      }
      t.add("LineString", i), e(i)
    });
  }],
  [',K', function(ym) {
    ym.modules.define("geometry.component.pixelGeometryGeodesic.polygon", ["geometry.component.pixelGeometryGeodesic.lineString", "geometry.component.pixelGeometryGeodesic.storage", "geometry.pixel.LineString"], function(e, n, o, i) {
      function t(e, n) {
        for (var o, i = e.getCoordinates(), t = e.getMetaData().originalIndexes || [], l = {
            pixelPaths: [],
            indexes: []
          }, s = 0, g = i.length; s < g; s++) o = r(new a(i[s], {
          originalIndexes: t[s] || []
        }), n), l.pixelPaths.push(o.getCoordinates()), l.indexes.push(o.getMetaData().originalIndexes);
        return e.clone(l.pixelPaths, null, {
          originalIndexes: l.indexes
        })
      }
      var r = n,
        a = i;
      o.add("Polygon", t), e(t)
    });
  }],
  [',L', function(ym) {
    ym.modules.define("geometry.component.pixelGeometryGeodesic.rectangle", ["geometry.component.pixelGeometryGeodesic.lineString", "geometry.component.pixelGeometryGeodesic.storage", "geometry.pixel.LineString", "geometry.pixel.Polygon"], function(e, o, n, t, i) {
      function r(e, n) {
        var r = e.getBounds(),
          g = new t([r[0],
            [r[1][0], r[0][1]], r[1],
            [r[0][0], r[1][1]], r[0]
          ]),
          m = o(g, n);
        return new i([m.getCoordinates()])
      }
      n.add("Rectangle", r), e(r)
    });
  }],
  [',M', function(ym) {
    ym.modules.define("geometry.component.pixelGeometryGeodesic.storage", ["util.Storage"], function(e, o) {
      e(new o)
    });
  }],
  ['$q', function(ym) {
    ym.modules.define("geometry.component.PixelGeometryShift", ["util.pixelBounds", "geometry.component.anchor"], function(t, o, i) {
      function e(t, o, e, n, r, s) {
        var a = i.getAnchor(t, o, s),
          l = a - t,
          u = r - (n + l),
          h = Math.ceil(e / s) || 1,
          c = Math.round(u / (h * s)),
          f = Math.round(l / s);
        return c && (f += c * h), f
      }

      function n(t, o) {
        for (var i, e = 1 / 0, n = 0; n < 4; ++n) {
          var r = [o[0] - t[n][0], o[1] - t[n][1]],
            s = r[0] * r[0] + r[1] * r[1];
          s < e && (e = s, i = n)
        }
        return i
      }
      var r = function() {};
      r.prototype = {
        calculateShift: function(t, i, r) {
          var s = t.getBounds(),
            a = i.isCycled(),
            l = [0, 0];
          if (s && (a[0] || a[1])) {
            var u = o.getCenter(s),
              h = o.getSize(s),
              c = r.getGlobalPixelCenter(),
              f = c,
              g = u,
              m = Math.pow(2, 8 + r.getZoom());
            if (this.lastPosition && (h[0] > 0 || h[1] > 0)) {
              var P = [
                  [s[0][0] + this.lastPosition[0] * m, s[0][1] + this.lastPosition[1] * m],
                  [s[1][0] + this.lastPosition[0] * m, s[1][1] + this.lastPosition[1] * m]
                ],
                d = [
                  [P[0][0], P[0][1]],
                  [P[1][0], P[0][1]],
                  [P[1][0], P[1][1]],
                  [P[0][0], P[1][1]]
                ],
                v = [
                  [s[0][0], s[0][1]],
                  [s[1][0], s[0][1]],
                  [s[1][0], s[1][1]],
                  [s[0][0], s[1][1]]
                ],
                p = n(d, c);
              f = d[p], g = v[p]
            }
            l = [a[0] ? e(g[0], f[0], h[0], u[0], c[0], m) : 0, a[1] ? e(g[1], f[1], h[1], u[1], c[1], m) : 0]
          }
          return this.lastPosition = l, l
        }
      }, t(r)
    });
  }],
  [',N', function(ym) {
    ym.modules.define("geometry.component.pixelGeometrySimplification.lineString", ["graphics.generator.simplify2", "geometry.component.pixelGeometrySimplification.storage"], function(e, i, n) {
      var t = {
        prepare: function(e) {
          var n = e.getCoordinates(),
            t = e.getMetaData().originalIndexes || [];
          return e.clone(null, {
            simplificatorCache: i(n, t)
          })
        },
        apply: function(e, i, n) {
          var t = e.getMetaData(),
            o = t.simplificatorCache,
            a = i.simplification || 1,
            r = 1 / Math.pow(2, n + (a === !0 ? 1 : a)),
            l = o(r);
          return e.clone(l.points, null, {
            originalIndexes: l.indexes
          })
        }
      };
      n.add("LineString", t), e(t)
    });
  }],
  [',O', function(ym) {
    ym.modules.define("geometry.component.pixelGeometrySimplification.polygon", ["graphics.generator.simplify2", "geometry.component.pixelGeometrySimplification.storage"], function(e, i, n) {
      var o = {
        prepare: function(e, n) {
          for (var o = e.getCoordinates(), t = [], a = e.getMetaData().originalIndexes || [], l = n.simplificationFixedPoints || [], r = 0, p = o.length; r < p; r++) t[r] = i(o[r], a[r], l[r]);
          return e.clone(null, null, {
            simplificatorCache: t
          })
        },
        apply: function(e, i, n) {
          for (var o = e.getMetaData(), t = o.simplificatorCache || [], a = i.simplification || 1, l = 1 / Math.pow(2, n + (a === !0 ? 1 : a)), r = [], p = [], c = 0, m = t.length; c < m; c++) {
            var g = t[c](l);
            r[c] = g.points, p[c] = g.indexes
          }
          return e.clone(r, null, {
            originalIndexes: p
          })
        }
      };
      n.add("Polygon", o), e(o)
    });
  }],
  [',P', function(ym) {
    ym.modules.define("geometry.component.pixelGeometrySimplification.storage", ["util.Storage"], function(e, o) {
      e(new o)
    });
  }],
  ['$i', function(ym) {
    ym.modules.define("geometry.component.pixelGetClosest", [], function(e) {
      e(function(e, o) {
        var t = e.getMap();
        if ("undefined" == typeof t) throw new Error("geometry.component.pixelGetClosest: Для нахождения ближайшей точки геометрия должна быть добавлена на карту.");
        for (var i = e.getPixelGeometry({
            simplification: !1,
            pixelRendering: "static",
            geodesic: e.options.get("geodesic")
          }), n = 256 * Math.pow(2, t.getZoom()), l = e.options.get("projection"), s = l.isCycled(), r = l.toGlobalPixels(o, t.getZoom()), c = [
            [s[0] ? -1 : 0, s[1] ? -1 : 0],
            [s[0] ? 1 : 0, s[1] ? 1 : 0]
          ], g = null, p = null, a = c[0][0]; a <= c[1][0]; a++)
          for (var d = c[0][1]; d <= c[1][1]; d++) p = i.getClosest([r[0] + a * n, r[1] + d * n]), (!g || p.distance < g.distance) && (g = p);
        return g
      })
    });
  }],
  ['$z', function(ym) {
    ym.modules.define("geometry.component.pointInPolygon", [], function(n) {
      function r(n, r) {
        for (var e, o, f, i, u = r[r.length - 1], a = 0, h = r.length; a < h; a++)
          if (f = i, e = o || [n[0] - u[0], n[1] - u[1]], o = [n[0] - r[a][0], n[1] - r[a][1]], (e[0] != o[0] || e[1] != o[1]) && (i = t(e, o), i != f && "undefined" != typeof f)) return !1;
        return !0
      }

      function t(n, r) {
        return n[0] * r[1] - n[1] * r[0] > 0
      }

      function e(n, r, t) {
        for (var e = 0, o = 0, f = r.length; o < f; o++)
          if (r[o][0] == n[0] && r[o][1] == n[1]) return 1;
        var i = r[f - 1];
        for (o = 0; o < f; o++) {
          var u = r[o];
          if (i[1] == u[1] && i[1] == n[1] && n[0] > Math.min(i[0], u[0]) && n[0] < Math.max(i[0], u[0])) return 1;
          if (n[1] > Math.min(i[1], u[1]) && n[1] <= Math.max(i[1], u[1]) && n[0] <= Math.max(i[0], u[0]) && i[1] != u[1]) {
            var a = (n[1] - i[1]) * (u[0] - i[0]) / (u[1] - i[1]) + i[0];
            if (a == n[0]) return 1;
            (i[0] == u[0] || n[0] <= a) && (e += t ? u[1] - i[1] < 0 ? -1 : 1 : e ? -1 : 1)
          }
          i = u
        }
        return e
      }
      n(function(n, t, o, f) {
        for (var i = !1, u = f ? r : e, a = "nonZero" == o, h = 0, m = t.length; h < m && !(u(n, t[h], a) && (i = !i, i && a)); h++);
        return i
      })
    });
  }],
  ['@2', function(ym) {
    ym.modules.define("geometry.component.renderFlow.stageGeodesic", ["geometry.component.pixelGeometryGeodesic.storage"], function(e, o) {
      e(function(e, t) {
        if (!t.geodesic) return e;
        if (!this._geodesic && (this._geodesic = o.get(e.getType()), ym.env.debug && !this._geodesic)) throw new Error("geometry.component.renderFlow.stageGeodesic: Не найден перобразователь для геометрии " + e.getType());
        return this._geodesic(e, t.projection)
      })
    });
  }],
  ['@3', function(ym) {
    ym.modules.define("geometry.component.renderFlow.stageScale", [], function(t) {
      t({
        onActionEnd: function(t) {
          return t.get("target").getZoom() != this._lastZoom
        },
        apply: function(t, o, e) {
          var n = this.getMap().getZoom(),
            a = t;
          return n > 0 && (a = t.scale(Math.pow(2, n))), e || (this._lastZoom = n), a
        }
      })
    });
  }],
  ['@4', function(ym) {
    ym.modules.define("geometry.component.renderFlow.stageShift", ["geometry.component.PixelGeometryShift"], function(t, i) {
      function e(t, e) {
        return this._shiftCalculator = this._shiftCalculator || new i, this._shiftCalculator.calculateShift(t, e, this.getMap())
      }
      t({
        onActionEnd: function(t, i, n) {
          if ("static" == n.pixelRendering) return !1;
          var h = this._tmpShift = e.call(this, i, n.projection);
          return h[0] != this._lastShift[0] || h[1] != this._lastShift[1]
        },
        apply: function(t, i, n) {
          var h = [0, 0],
            o = t;
          if ("static" != i.pixelRendering && (h = this._tmpShift, h && !n || (h = e.call(this, t, i.projection)), this._tmpShift = null, h[0] || h[1])) {
            var s = Math.pow(2, 8 + this.getMap().getZoom());
            o = t.shift([h[0] * s, h[1] * s])
          }
          return n || (this._lastShift = h), o
        }
      })
    });
  }],
  ['@5', function(ym) {
    ym.modules.define("geometry.component.renderFlow.stageSimplification", ["geometry.component.pixelGeometrySimplification.storage"], function(e, i) {
      function t(e, t) {
        if (!t.simplification) return r;
        if (!e._simplificator && (e._simplificator = i.get(e.getType()), ym.env.debug && !e._simplificator)) throw new Error("geometry.component.renderFlow.stageSimplification: Не найден симплификатор для геометрии " + e.getType());
        return e._simplificator
      }
      e({
        prepare: function(e, i) {
          return t(e, i).prepare(e, i)
        },
        apply: function(e, i) {
          return t(e, i).apply(e, i, this.getMap().getZoom())
        }
      });
      var r = {
        prepare: function(e) {
          return e
        },
        apply: function(e) {
          return e
        }
      }
    });
  }],
  ['$Q', function(ym) {
    ym.modules.define("geometry.component.renderFlowManager", ["util.id", "option.Manager"], function(e, t, n) {
      var o = {},
        r = {},
        a = {
          add: function(e, n, o, g) {
            var i = {
              geometry: e,
              pixelGeometryChangeCallback: g,
              ignoreCacheFrom: 0,
              optionsByStage: {},
              observingOptions: {},
              stages: [],
              cache: [],
              removed: !1
            };
            r[t.get(e)] = i, e.events.add("optionschange", a._onOptionsChange);
            for (var s = 0, p = n.length; s < p; s++) {
              var c = n[s],
                l = c.options,
                v = c.event;
              if (i.stages.push(c.stage), l) {
                for (var m = 0, u = l.length; m < u; m++) {
                  var f = l[m];
                  a._parseOption(i, f, o[f], s)
                }
                i.optionsByStage[s] = l
              }
              v && a._setupEvent(i, v, s)
            }
            a._run(i)
          },
          remove: function(e, n) {
            var o = r[t.get(e)];
            o.removed = !0, r[t.get(e)] = null, e.events.remove("optionschange", a._onOptionsChange);
            for (var g = 0, i = n.length; g < i; g++) {
              var s = n[g].event;
              s && a._clearEvent(o, s)
            }
          },
          getPixelGeometry: function(e, o) {
            var g = r[t.get(e)],
              i = g ? g.pixelGeometry : null;
            return "object" == typeof o && (g.tmpOptions = new n(o, g.geometry.options), a._useChangedOptions(e, g.tmpOptions) && (i = a._run(g)), g.tmpOptions.setParent(null), g.tmpOptions = null), i
          },
          _onOptionsChange: function(e) {
            var n = e.get("target");
            a._useChangedOptions(n) && a._runAndFire(r[t.get(n)])
          },
          _useChangedOptions: function(e, n) {
            n = n || e.options;
            var o = r[t.get(e)],
              g = o.observingOptions,
              i = !1;
            for (var s in g)
              if (g.hasOwnProperty(s)) {
                var p = g[s],
                  c = n.get(s, p.defaultValue);
                p.cached != c && (o.tmpOptions || (p.cached = c), a._setIgnoreCacheFrom(o, p.affectsStage), i = !0)
              }
            return i
          },
          _parseOption: function(e, t, n, o) {
            e.observingOptions[t] ? e.observingOptions[t].affectsStage > o && (e.observingOptions[t].affectsStage = o) : e.observingOptions[t] = {
              cached: e.geometry.options.get(t, n),
              defaultValue: n,
              affectsStage: o
            }
          },
          _run: function(e) {
            for (var t = e.ignoreCacheFrom, n = e.stages, o = e.geometry, r = e.cache, g = [], i = 0, s = n.length; i < s; i++) g[i] = r[i] && i < t ? r[i] : n[i].call(o, g[i - 1], a._getAffectingOptions(e, i), e.tmpOptions);
            return e.tmpOptions || (e.cache = g, e.pixelGeometry = g[s - 1]), e.ignoreCacheFrom = s, g[i - 1]
          },
          _setupEvent: function(e, n, r) {
            var g = "map" == n.target ? e.geometry.getMap() : e.geometry,
              i = n.event,
              s = {
                callback: n.callback,
                geometry: e.geometry,
                phase: r
              },
              p = t.get(g) + i;
            o[p] ? o[p].push(s) : (o[p] = [s], g.events.add(i, a._eventHandler))
          },
          _clearEvent: function(e, n) {
            var r = "map" == n.target ? e.geometry.getMap() : e.geometry,
              g = t.get(r) + n.event,
              i = o[g],
              s = i.length;
            if (i) {
              for (var p = -1, c = 0; c < s; c++) {
                var l = i[c];
                if (l.geometry == e.geometry) {
                  p = c;
                  break
                }
              }
              p > -1 && (1 == s ? (i.pop(), r.events.remove(n.event, a._eventHandler), delete o[g]) : i.splice(p, 1))
            }
          },
          _eventHandler: function(e) {
            var n, g, i = e.get("target"),
              s = t.get(i) + e.get("type"),
              p = o[s],
              c = [];
            if (p)
              for (n = 0, g = p.length; n < g; n++) {
                var l = p[n],
                  v = l.geometry,
                  m = r[t.get(v)],
                  u = l.phase;
                m.updating || l.callback && !l.callback.call(v, e, m.cache[u - 1], a._getAffectingOptions(m, u)) || (a._setIgnoreCacheFrom(m, u), m.updating || (m.updating = 1, c.push(m)))
              }
            for (n = 0, g = c.length; n < g; ++n) c[n].removed || (c[n].updating = 0, a._runAndFire(c[n]))
          },
          _setIgnoreCacheFrom: function(e, t) {
            e.ignoreCacheFrom > t && (e.ignoreCacheFrom = t)
          },
          _runAndFire: function(e) {
            a._run(e), e.pixelGeometryChangeCallback.call(e.geometry, e.pixelGeometry)
          },
          _getAffectingOptions: function(e, t) {
            var n = {},
              o = e.optionsByStage[t];
            if (o)
              for (var r = 0, a = o.length; r < a; r++) {
                var g = o[r];
                n[g] = e.tmpOptions ? e.tmpOptions.get(g, e.observingOptions[g].defaultValue) : e.observingOptions[g].cached
              }
            return n
          }
        };
      e(a)
    });
  }],
  ['$I', function(ym) {
    ym.modules.define("geometry.component.ShortestPath", ["geometry.component.anchor", "util.math.cycleRestrict"], function(t, e, o) {
      var n = function() {
        this.basePoint = null, this.baseWorld = null
      };
      n.prototype = {
        reset: function() {
          this.basePoint = null, this.baseWorld = null
        },
        calculate: function(t, n, s) {
          s = s || {};
          for (var l, r, i = [], a = [0, 0], h = this.baseWorld, u = this.basePoint, c = s.worldSize || 256, d = 0, b = t.length; d < b; ++d) r = s.unbounded ? t[d] : [n[0] ? o(t[d][0], 0, c) : t[d][0], n[1] ? o(t[d][1], 0, c) : t[d][1]], l = [r[0], r[1]], u && (a = [n[0] ? h[0] + e.getShortestPathWorld(l[0], u[0], c) : 0, n[1] ? h[1] + e.getShortestPathWorld(l[1], u[1], c) : 0], a[0] && (l[0] += a[0] * c), a[1] && (l[1] += a[1] * c)), i[d] = l, u = r, h = a;
          return this.basePoint = u, this.baseWorld = h, i
        }
      }, t(n)
    });
  }],
  ['-b', function(ym) {
    ym.modules.define("geometry.defaultOptions", ["projection.wgs84Mercator"], function(e, o) {
      e({
        projection: o,
        coordRendering: "shortestPath",
        geodesic: !1,
        simplification: !0,
        pixelRendering: "jumpy"
      })
    });
  }],
  ['-c', function(ym) {
    ym.modules.define("geometry.LineString", ["util.defineClass", "util.coordinates.encode", "util.coordinates.decode", "option.Manager", "geometry.base.LineString", "geometry.pixel.LineString", "geometry.component.renderFlowManager", "geometry.component.renderFlow.stageGeodesic", "geometry.component.renderFlow.stageScale", "geometry.component.renderFlow.stageSimplification", "geometry.component.renderFlow.stageShift", "geometry.component.pixelGeometryGeodesic.lineString", "geometry.component.pixelGeometrySimplification.lineString", "geometry.component.ShortestPath", "geometry.component.boundsFromPixels", "geometry.component.pixelGetClosest", "geometry.defaultOptions", "util.matrix.2d", "Event"], function(e, t, n, o, i, r, s, a, g, c, p, l, d, m, h, u, y, f, w, v) {
      function S() {
        this.events.fire("optionschange")
      }

      function x(e) {
        this._bounds = null, this.events.fire("pixelgeometrychange", new v({
          pixelGeometry: e,
          type: "pixelgeometrychange",
          target: this
        }))
      }

      function b(e, t) {
        if (ym.env.debug && !t.projection) throw new Error("geometry.LineString._renderingStageBasePixels: значение опции projection не определено");
        var n;
        if ("straightPath" == t.coordRendering) n = _(e, t.projection);
        else if ("shortestPath" == t.coordRendering) n = C(e, t.projection);
        else if (ym.env.debug) throw new Error("geometry.LineString._renderingStageBasePixels: неизвестное значение опции coordRendering");
        return new s(n)
      }

      function C(e, t) {
        return (new h).calculate(_(e, t), t.isCycled())
      }

      function _(e, t) {
        for (var n = [], o = 0, i = e.length; o < i; ++o) n[o] = t.toGlobalPixels(e[o], 0);
        return n
      }
      var P = function(e, t) {
        P.superclass.constructor.call(this, e), this.options = new i(t), this.options.events.add("change", S, this)
      };
      P.fromEncodedCoordinates = function(e, t) {
        return new P(o(e), t)
      }, P.toEncodedCoordinates = function(e) {
        if (ym.env.debug && "LineString" != e.getType()) throw new Error("geometry.LineString.toEncodedCoordinates: неверный тип геометрии: " + e.getType());
        return n(e.getCoordinates())
      }, t(P, r, {
        getBounds: function() {
          return this._bounds || (this._bounds = u.get(this))
        },
        getPixelGeometry: function(e) {
          if (ym.env.debug && !this._map) throw new Error("geometry.main.LineString.getPixelGeometry: Не задана карта.");
          return this._map ? a.getPixelGeometry(this, e) : null
        },
        setMap: function(e) {
          var t = this._map;
          t && this._clearRenderFlow(), this._map = e, e && this._setupRenderFlow(), this.events.fire("mapchange", new v({
            newMap: this._map,
            oldMap: t,
            target: this,
            type: "mapchange"
          }))
        },
        getMap: function() {
          return this._map
        },
        getClosest: function(e) {
          var t = y(this, e),
            n = this.options.get("projection");
          if (ym.env.debug && "object" != typeof n) throw new Error("geometry.LineString.getClosest: В опциях геометрии не определена проекция.");
          return t && (t.position = n.fromGlobalPixels(t.position, this._map.getZoom()), t.distance = n.getCoordSystem().getDistance(e, t.position)), t
        },
        getDistance: function(e, t) {
          if (e = e || 0, t = t || this.getLength() - 1, ym.env.debug) {
            if (!this.getMap()) throw new Error("geometry.LineString: геометрия должна быть добавлена на карту.");
            if (e < 0 || t > this.getLength() - 1) throw new Error("geometry.LineString: выход за пределы массива точек")
          }
          for (var n = this.getMap().options.get("projection").getCoordSystem(), o = this.getCoordinates(), i = 0, r = e; r < t; r++) i += n.getDistance(o[r], o[r + 1]);
          return i
        },
        applyProjectedTransformation: function(e) {
          var t = this.options.get("projection"),
            n = this.getMap().action.getCurrentState().zoom,
            o = Math.pow(2, n),
            i = this.options.get("coordRendering"),
            r = this.getCoordinates(),
            s = [],
            a = [];
          s = "shortestPath" == i ? C(r, t) : _(r, t), "function" == typeof e && (e = e({
            type: "LineString",
            pixels: s
          }));
          for (var g = 0, c = s.length; g < c; g++) {
            var p = [s[g][0] * o, s[g][1] * o];
            e && w.applyToPoint(p, p, e), a[g] = t.fromGlobalPixels(p, n)
          }
          this.setCoordinates(a)
        },
        _setupRenderFlow: function() {
          E[0].stage = this.getCoordinates, a.add(this, E, f, x)
        },
        _clearRenderFlow: function() {
          a.remove(this, E)
        }
      });
      var E = [{
        stage: null,
        event: {
          target: "self",
          event: "change"
        }
      }, {
        stage: b,
        options: ["projection", "coordRendering"]
      }, {
        stage: g,
        options: ["projection", "geodesic"]
      }, {
        stage: p.prepare,
        options: ["simplification"]
      }, {
        stage: p.apply,
        options: ["simplification"],
        event: {
          target: "map",
          event: "actionend",
          callback: c.onActionEnd
        }
      }, {
        stage: c.apply,
        event: {
          target: "map",
          event: "actionend",
          callback: c.onActionEnd
        }
      }, {
        stage: l.apply,
        options: ["projection", "pixelRendering"],
        event: {
          target: "map",
          event: "actionend",
          callback: l.onActionEnd
        }
      }];
      e(P)
    });
  }],
  ['-m', function(ym) {
    ym.modules.define("geometry.pixel.Circle", ["util.extend", "geometry.component.commonMethods.circle"], function(t, i, n) {
      var s = function(t, i, n) {
        this._coordinates = t || null, this._radius = i || null, this._metaData = n || {}, this._bounds = null
      };
      s.prototype = {
        getType: function() {
          return "Circle"
        },
        getCoordinates: function() {
          return this._coordinates
        },
        getCenter: function() {
          return this._coordinates
        },
        getMetaData: function() {
          return this._metaData
        },
        getRadius: function() {
          return this._radius
        },
        getBounds: function() {
          return this._bounds || (this._bounds = this._calculateBounds())
        },
        clone: function(t, n, e) {
          return new s(t || this._coordinates, n || this._radius, e ? i({}, this._metaData, e) : this._metaData)
        },
        scale: function(t) {
          return this.clone(this._coordinates ? [this._coordinates[0] * t, this._coordinates[1] * t] : null, this._radius ? this._radius * t : null)
        },
        shift: function(t) {
          return this.clone(this._coordinates ? [this._coordinates[0] + t[0], this._coordinates[1] + t[1]] : null)
        },
        contains: function(t) {
          return n.contains(this._coordinates, this._radius, t)
        },
        getClosest: function(t) {
          return n.getClosest(this._coordinates, this._radius, t)
        },
        equals: function(t) {
          if (this.getType() != t.getType() || this._radius != t.getRadius()) return !1;
          var i = t.getCoordinates();
          return this._coordinates && i ? this._coordinates[0] == i[0] && this._coordinates[1] == i[1] : this._coordinates == i
        },
        _calculateBounds: function() {
          return n.calculateBounds(this._coordinates, this._radius)
        }
      }, t(s)
    });
  }],
  ['-n', function(ym) {
    ym.modules.define("geometry.pixel.LineString", ["util.extend", "util.pixelBounds", "geometry.component.findClosestPathPosition", "util.math.areEqualPaths"], function(t, n, e, i, o) {
      var s = function(t, n) {
        this._coordinates = t, this._metaData = n || {}, this._bounds = null
      };
      s.prototype = {
        getType: function() {
          return "LineString"
        },
        getCoordinates: function() {
          return this._coordinates
        },
        getMetaData: function() {
          return this._metaData
        },
        getLength: function() {
          return this._coordinates.length
        },
        getBounds: function() {
          return this._coordinates ? this._bounds || (this._bounds = e.fromPoints(this._coordinates)) : null
        },
        getClosest: function(t) {
          return i(this._coordinates, t)
        },
        clone: function(t, e) {
          return new s(t || this._coordinates, e ? n({}, this._metaData, e) : this._metaData)
        },
        scale: function(t) {
          for (var n = [], e = 0, i = this._coordinates.length; e < i; e++) {
            var o = this._coordinates[e];
            n[e] = [o[0] * t, o[1] * t]
          }
          return this.clone(n)
        },
        shift: function(t) {
          for (var n = [], e = 0, i = this._coordinates.length; e < i; e++) {
            var o = this._coordinates[e];
            n[e] = [o[0] + t[0], o[1] + t[1]]
          }
          return this.clone(n)
        },
        equals: function(t) {
          return this.getType() == t.getType() && o(this._coordinates, t.getCoordinates(), 0)
        }
      }, t(s)
    });
  }],
  ['-p', function(ym) {
    ym.modules.define("geometry.pixel.MultiPolygon", ["util.extend", "geometry.pixel.Polygon", "util.pixelBounds", "util.math.areEqualPaths"], function(t, o, n, e, s) {
      var i = function(t, o, n) {
        this._coordinates = t, this._fillRule = o, this._convex = n && n.convex, this._metaData = n || {}, this._polygons = null, this._bounds = null
      };
      i.prototype = {
        getType: function() {
          return "MultiPolygon"
        },
        getCoordinates: function() {
          return this._coordinates
        },
        getMetaData: function() {
          return this._metaData
        },
        getFillRule: function() {
          return this._fillRule
        },
        getBounds: function() {
          if (!this._bounds) {
            this._polygons || this._createPolygons();
            for (var t = [], o = 0, n = this._polygons.length; o < n; o++) {
              var s = this._polygons[o].getBounds();
              s && t.push(s)
            }
            t.length && (this._bounds = e.fromBounds(t))
          }
          return this._bounds
        },
        contains: function(t) {
          this._polygons || this._createPolygons();
          for (var o = 0, n = this._polygons.length; o < n; o++)
            if (this._polygons[o].contains(t)) return !0;
          return !1
        },
        getClosest: function(t) {
          this._polygons || this._createPolygons();
          for (var o = null, n = 0, e = this._coordinates.length; n < e; n++) {
            var s = this._polygons[n].getClosest(t);
            s && (!o || s.distance < o.distance) && (o = s, o.polygonIndex = n)
          }
          return o
        },
        clone: function(t, n, e) {
          return new i(t || this._coordinates, n || this._fillRule, e ? o({}, this._metaData, e) : this._metaData)
        },
        scale: function(t) {
          for (var o = [], n = 0, e = this._coordinates.length; n < e; n++) {
            o[n] = [];
            for (var s, i = 0, l = this._coordinates[n].length; i < l; i++) {
              o[n][i] = s = [];
              for (var r = 0, h = this._coordinates[n][i].length, a = this._coordinates[n][i]; r < h; r++) s[r] = [a[r][0] * t, a[r][1] * t]
            }
          }
          return this.clone(o)
        },
        shift: function(t) {
          for (var o = [], n = 0, e = this._coordinates.length; n < e; n++) {
            o[n] = [];
            for (var s, i = 0, l = this._coordinates[n].length; i < l; i++) {
              o[n][i] = s = [];
              for (var r = 0, h = this._coordinates[n][i].length, a = this._coordinates[n][i]; r < h; r++) s[r] = [a[r][0] + t[0], a[r][1] + t[1]]
            }
          }
          return this.clone(o)
        },
        equals: function(t) {
          return this.getType() == t.getType() && this._fillRule == t.getFillRule() && s(this._coordinates, t.getCoordinates(), 2)
        },
        _createPolygons: function() {
          this._polygons = [];
          for (var t = 0, o = this._coordinates.length; t < o; t++) this._polygons.push(new n(this._coordinates[t], this._fillRule, {
            convex: this._convex
          }))
        }
      }, t(i)
    });
  }],
  ['-r', function(ym) {
    ym.modules.define("geometry.pixel.Point", ["util.extend"], function(t, i) {
      var n = function(t, i) {
        this._position = t || null, this._metaData = i || {}, this._bounds = null
      };
      n.prototype = {
        getType: function() {
          return "Point"
        },
        getCoordinates: function() {
          return this._position
        },
        getMetaData: function() {
          return this._metaData
        },
        getBounds: function() {
          return this._position ? this._bounds || (this._bounds = [this._position.slice(), this._position.slice()]) : null
        },
        clone: function(t, o) {
          return new n(t || this._position, o ? i({}, this._metaData, o) : this._metaData)
        },
        scale: function(t) {
          return this.clone(this._position ? [this._position[0] * t, this._position[1] * t] : null)
        },
        shift: function(t) {
          return this.clone(this._position ? [this._position[0] + t[0], this._position[1] + t[1]] : null)
        },
        equals: function(t) {
          if (this.getType() != t.getType()) return !1;
          var i = t.getCoordinates();
          return this._coordinates && i ? this._coordinates[0] == i[0] && this._coordinates[1] == i[1] : this._coordinates == i
        }
      }, t(n)
    });
  }],
  ['-s', function(ym) {
    ym.modules.define("geometry.pixel.Polygon", ["util.extend", "geometry.component.commonMethods.polygon", "util.math.areEqualPaths"], function(t, e, n, o) {
      var i = function(t, e, n) {
        this._coordinates = t, this._fillRule = e, this._convex = n && n.convex, this._metaData = n || {}, this._bounds = null
      };
      i.prototype = {
        getType: function() {
          return "Polygon"
        },
        getCoordinates: function() {
          return this._coordinates
        },
        getMetaData: function() {
          return this._metaData
        },
        getFillRule: function() {
          return this._fillRule
        },
        getLength: function() {
          return this._coordinates.length
        },
        getBounds: function() {
          return this._bounds || (this._bounds = n.calculateBounds(this._coordinates))
        },
        contains: function(t) {
          return n.contains(this._coordinates, t, this._fillRule)
        },
        getClosest: function(t) {
          return n.getClosest(this._coordinates, t)
        },
        clone: function(t, n, o) {
          return new i(t || this._coordinates, n || this._fillRule, o ? e({}, this._metaData, o) : this._metaData)
        },
        scale: function(t) {
          for (var e, n = [], o = 0, i = this._coordinates.length; o < i; o++) {
            n[o] = e = [];
            for (var s = 0, r = this._coordinates[o].length, a = this._coordinates[o]; s < r; s++) e[s] = [a[s][0] * t, a[s][1] * t]
          }
          return this.clone(n)
        },
        shift: function(t) {
          for (var e, n = [], o = 0, i = this._coordinates.length; o < i; o++) {
            n[o] = e = [];
            for (var s = 0, r = this._coordinates[o].length, a = this._coordinates[o]; s < r; s++) e[s] = [a[s][0] + t[0], a[s][1] + t[1]]
          }
          return this.clone(n)
        },
        equals: function(t) {
          return this.getType() == t.getType() && this._fillRule == t.getFillRule() && o(this._coordinates, t.getCoordinates(), 1)
        }
      }, t(i)
    });
  }],
  ['-u', function(ym) {
    ym.modules.define("geometry.pixel.Rectangle", ["util.extend", "geometry.component.commonMethods.rectangle"], function(t, n, e) {
      var o = e,
        i = function(t, n) {
          this._coordinates = t || null, this._metaData = n || {}, this._bounds = null
        };
      i.prototype = {
        getType: function() {
          return "Rectangle"
        },
        getCoordinates: function() {
          return this._coordinates
        },
        getMetaData: function() {
          return this._metaData
        },
        getBounds: function() {
          return this._bounds || (this._bounds = o.calculateBounds(this._coordinates))
        },
        clone: function(t, e) {
          return new i(t || this._coordinates, e ? n({}, this._metaData, e) : this._metaData)
        },
        scale: function(t) {
          return this.clone(this._coordinates ? [
            [this._coordinates[0][0] * t, this._coordinates[0][1] * t],
            [this._coordinates[1][0] * t, this._coordinates[1][1] * t]
          ] : null)
        },
        shift: function(t) {
          return this.clone(this._coordinates ? [
            [this._coordinates[0][0] + t[0], this._coordinates[0][1] + t[1]],
            [this._coordinates[1][0] + t[0], this._coordinates[1][1] + t[1]]
          ] : null)
        },
        getClosest: function(t) {
          return o.getClosest(this._coordinates, t)
        },
        contains: function(t) {
          return o.contains(this._coordinates, t)
        },
        equals: function(t) {
          if (this.getType() != t.getType()) return !1;
          var n = this._coordinates,
            e = t.getCoordinates();
          return n && e ? n[0][0] == e[0][0] && n[0][1] == e[0][1] && n[1][0] == e[1][0] && n[1][1] == e[1][1] : n == e
        }
      }, t(i)
    });
  }],
  ['-e', function(ym) {
    ym.modules.define("geometry.Point", ["util.defineClass", "option.Manager", "geometry.base.Point", "geometry.pixel.Point", "geometry.component.renderFlowManager", "geometry.component.renderFlow.stageScale", "geometry.component.renderFlow.stageShift", "Event", "util.matrix.2d", "geometry.defaultOptions"], function(e, t, n, o, i, r, a, s, p, l, g) {
      function c() {
        this.events.fire("optionschange", new p({
          type: "optionschange",
          target: this
        }))
      }

      function m(e) {
        this.events.fire("pixelgeometrychange", new p({
          pixelGeometry: e,
          type: "pixelgeometrychange",
          target: this
        }))
      }

      function h(e, t) {
        if (ym.env.debug && !t.projection) throw new Error("geometry.Point._renderingStageBasePixels: значение опции projection не определено");
        return new i(e ? t.projection.toGlobalPixels(e, 0) : null)
      }
      var d = function(e, t) {
        d.superclass.constructor.call(this, e), this.options = new n(t), this.options.events.add("change", c, this)
      };
      t(d, o, {
        getPixelGeometry: function(e) {
          if (ym.env.debug && !this._map) throw new Error("geometry.main.Point.getPixelGeometry: Не задана карта.");
          return this._map ? r.getPixelGeometry(this, e) : null
        },
        setMap: function(e) {
          var t = this._map;
          t && this._clearRenderFlow(), this._map = e, e && this._setupRenderFlow(), this.events.fire("mapchange", new p({
            newMap: this._map,
            oldMap: t,
            target: this,
            type: "mapchange"
          }))
        },
        getMap: function() {
          return this._map
        },
        applyProjectedTransformation: function(e) {
          var t = this.options.get("projection"),
            n = this.getMap().action.getCurrentState().zoom,
            o = t.toGlobalPixels(this.getCoordinates(), n);
          "function" == typeof e && (e = e({
            type: "Point",
            pixels: o
          })), e && l.applyToPoint(o, o, e), this.setCoordinates(t.fromGlobalPixels(o, n))
        },
        _setupRenderFlow: function() {
          var e = u;
          e[0].stage = this.getCoordinates, r.add(this, e, g, m)
        },
        _clearRenderFlow: function() {
          r.remove(this, u)
        }
      });
      var u = [{
        stage: null,
        event: {
          target: "self",
          event: "change"
        }
      }, {
        stage: h,
        options: ["projection"]
      }, {
        stage: a.apply,
        event: {
          target: "map",
          event: "actionend",
          callback: a.onActionEnd
        }
      }, {
        stage: s.apply,
        options: ["projection", "pixelRendering"],
        event: {
          target: "map",
          event: "actionend",
          callback: s.onActionEnd
        }
      }];
      e(d)
    });
  }],
  ['-f', function(ym) {
    ym.modules.define("geometry.Polygon", ["util.defineClass", "util.coordinates.encode", "geometry.component.closedPathDecode", "option.Manager", "geometry.base.Polygon", "geometry.pixel.Polygon", "geometry.component.renderFlowManager", "geometry.component.renderFlow.stageGeodesic", "geometry.component.pixelGeometryGeodesic.polygon", "geometry.component.renderFlow.stageShift", "geometry.component.renderFlow.stageSimplification", "geometry.component.pixelGeometrySimplification.polygon", "geometry.component.renderFlow.stageScale", "geometry.component.ShortestPath", "geometry.defaultOptions", "geometry.component.boundsFromPixels", "geometry.component.pixelGetClosest", "geometry.component.pixelContains", "util.matrix.2d", "Event"], function(e, t, o, n, i, r, s, a, g, l, p, c, m, d, h, y, u, f, v, w, P) {
      function x() {
        this.events.fire("optionschange")
      }

      function b(e) {
        this._bounds = null, this.events.fire("pixelgeometrychange", new P({
          pixelGeometry: e,
          type: "pixelgeometrychange",
          target: this
        }))
      }

      function _(e, t) {
        if (ym.env.debug && !t.projection) throw new Error("geometry.Polygon._renderingStageBasePixels: значение опции projection не определено");
        var o;
        if ("straightPath" == t.coordRendering) o = j(e, t.projection);
        else if ("shortestPath" == t.coordRendering) o = C(e, t.projection);
        else if (ym.env.debug) throw new Error("geometry.Polygon._renderingStageBasePixels: неизвестное значение опции coordRendering");
        return new s(o, this.getFillRule())
      }

      function C(e, t) {
        for (var o = j(e, t), n = new h, i = 0, r = e.length; i < r; i++) o[i] = n.calculate(o[i], t.isCycled());
        return o
      }

      function j(e, t) {
        for (var o, n = [], i = 0, r = e.length; i < r; i++) {
          n[i] = o = [];
          for (var s = 0, a = e[i].length, g = e[i]; s < a; s++) o[s] = t.toGlobalPixels(g[s], 0)
        }
        return n
      }
      var F = function(e, t, o) {
        F.superclass.constructor.call(this, e, t), this.options = new i(o), this.options.events.add("change", x, this)
      };
      F.fromEncodedCoordinates = function(e, t) {
        for (var o = e.split(";"), i = [], r = 0, s = o.length; r < s; r++) i.push(n(o[r]));
        return new F(i, t)
      }, F.toEncodedCoordinates = function(e) {
        if (ym.env.debug && "Polygon" != e.getType()) throw new Error("Неверный тип геометрии. Ожидался: Polygon, получен: " + e.getType());
        for (var t = [], n = 0, i = e.getLength(); n < i; n++) t.push(o(e.get(n)));
        return t.join(";")
      }, t(F, r, {
        getBounds: function() {
          return this._bounds || (this._bounds = u.get(this))
        },
        getPixelGeometry: function(e) {
          if (ym.env.debug && !this._map) throw new Error("geometry.main.Polygon.getPixelGeometry: Не задана карта.");
          return this._map ? a.getPixelGeometry(this, e) : null
        },
        setMap: function(e) {
          var t = this._map;
          t && this._clearRenderFlow(), this._map = e, e && this._setupRenderFlow(), this.events.fire("mapchange", new P({
            newMap: this._map,
            oldMap: t,
            target: this,
            type: "mapchange"
          }))
        },
        getMap: function() {
          return this._map
        },
        contains: function(e) {
          return v(this, e)
        },
        getClosest: function(e) {
          var t = f(this, e),
            o = this.options.get("projection");
          if (ym.env.debug && "object" != typeof o) throw new Error("geometry.Polygon.getClosest: В опциях геометрии не определена проекция.");
          return t && (t.position = o.fromGlobalPixels(t.position, this._map.getZoom()), t.distance = o.getCoordSystem().getDistance(e, t.position)), t
        },
        applyProjectedTransformation: function(e) {
          var t = this.options.get("projection"),
            o = this.getMap().action.getCurrentState().zoom,
            n = Math.pow(2, o),
            i = this.options.get("coordRendering"),
            r = this.getCoordinates(),
            s = [],
            a = [];
          s = "shortestPath" == i ? C(r, t) : j(r, t);
          for (var g = 0, l = s.length; g < l; g++)
            for (var p = s[g], c = 0, m = p.length; c < m; c++) p[c] = [p[c][0] * n, p[c][1] * n];
          "function" == typeof e && (e = e({
            type: "Polygon",
            pixels: s
          }));
          for (var g = 0, l = s.length; g < l; g++) {
            for (var p = s[g], d = [], c = 0, m = p.length - 1; c < m; c++) {
              var h = p[c];
              e && w.applyToPoint(h, h, e), d[c] = t.fromGlobalPixels(h, o)
            }
            a[g] = d
          }
          this.setCoordinates(a)
        },
        _setupRenderFlow: function() {
          a.add(this, G, y, b)
        },
        _clearRenderFlow: function() {
          a.remove(this, G)
        }
      });
      var G = [{
        stage: F.prototype.getCoordinates,
        event: {
          target: "self",
          event: "change"
        }
      }, {
        stage: _,
        options: ["projection", "coordRendering"]
      }, {
        stage: g,
        options: ["projection", "geodesic"]
      }, {
        stage: c.prepare,
        options: ["simplification", "simplificationFixedPoints"]
      }, {
        stage: c.apply,
        options: ["simplification"],
        event: {
          target: "map",
          event: "actionend",
          callback: d.onActionEnd
        }
      }, {
        stage: d.apply,
        event: {
          target: "map",
          event: "actionend",
          callback: d.onActionEnd
        }
      }, {
        stage: p.apply,
        options: ["projection", "pixelRendering"],
        event: {
          target: "map",
          event: "actionend",
          callback: p.onActionEnd
        }
      }];
      e(F)
    });
  }],
  ['-h', function(ym) {
    ym.modules.define("geometry.Rectangle", ["util.defineClass", "option.Manager", "geometry.base.Rectangle", "geometry.pixel.Rectangle", "geometry.component.renderFlowManager", "geometry.component.renderFlow.stageGeodesic", "geometry.component.pixelGeometryGeodesic.rectangle", "geometry.component.renderFlow.stageScale", "geometry.component.renderFlow.stageShift", "geometry.component.ShortestPath", "geometry.component.anchor", "geometry.defaultOptions", "geometry.component.boundsFromPixels", "geometry.component.pixelGetClosest", "geometry.component.pixelContains", "util.matrix.2d", "Event"], function(e, t, o, n, r, i, s, a, c, g, l, p, m, h, d, u, y, f) {
      function v() {
        this.events.fire("optionschange")
      }

      function w(e) {
        this._bounds = null, this.events.fire("pixelgeometrychange", new f({
          pixelGeometry: e,
          type: "pixelgeometrychange",
          target: this
        }))
      }

      function x(e, t) {
        if (ym.env.debug && !t.projection) throw new Error("geometry.Rectangle._renderingStageBasePixels: значение опции projection не определено");
        if (!e) return new r;
        var o;
        if ("straightPath" == t.coordRendering) o = P(e, t.projection, 0);
        else if ("shortestPath" == t.coordRendering) o = R(e, t.projection, 0);
        else if ("boundsPath" == t.coordRendering) o = b(e, t.projection, 0);
        else if (ym.env.debug) throw new Error("geometry.Rectangle.getPixelGeometry: неизвестное значение опции coordRendering");
        return new r(o)
      }

      function R(e, t, o) {
        return (new l).calculate(P(e, t, o), t.isCycled())
      }

      function P(e, t, o) {
        for (var n = [], r = 0, i = e.length; r < i; ++r) n[r] = t.toGlobalPixels(e[r], o);
        return n
      }

      function b(e, t, o) {
        var n, r = P(e, t, o),
          i = 256 * Math.pow(2, o);
        return r[1][0] < r[0][0] && (n = p.getAnchor(r[1][0], r[0][0], i), r[1][0] = n < r[0][0] ? n += i : n), r[1][1] > r[0][1] && (n = p.getAnchor(r[1][1], r[0][1], i), r[1][1] = n > r[0][1] ? n -= i : n), r
      }
      var _ = function(e, t) {
        _.superclass.constructor.call(this, e), this.options = new o(t), this.options.events.add("change", v, this)
      };
      t(_, n, {
        getBounds: function() {
          return this._bounds || (this._bounds = h.get(this))
        },
        getPixelGeometry: function(e) {
          if (ym.env.debug && !this._map) throw new Error("geometry.main.Rectangle.getPixelGeometry: Не задана карта.");
          return this._map ? i.getPixelGeometry(this, e) : null
        },
        setMap: function(e) {
          var t = this._map;
          t && this._clearRenderFlow(), this._map = e, e && this._setupRenderFlow(), this.events.fire("mapchange", new f({
            newMap: this._map,
            oldMap: t,
            type: "mapchange",
            target: this
          }))
        },
        getMap: function() {
          return this._map
        },
        contains: function(e) {
          return u(this, e)
        },
        getClosest: function(e) {
          var t = d(this, e),
            o = this.options.get("projection");
          if (ym.env.debug && "object" != typeof o) throw new Error("geometry.Rectangle.getClosest: В опциях геометрии не определена проекция.");
          return t && (t.position = o.fromGlobalPixels(t.position, this._map.getZoom()), t.distance = o.getCoordSystem().getDistance(e, t.position)), t
        },
        applyProjectedTransformation: function(e) {
          var t = this.options.get("projection"),
            o = this.getMap().action.getCurrentState().zoom,
            n = Math.pow(2, o),
            r = this.options.get("coordRendering"),
            i = this.getCoordinates(),
            s = [];
          s = "shortestPath" == r ? R(i, t, 0) : P(i, t, 0), s[0][0] *= n, s[0][1] *= n, s[1][0] *= n, s[1][1] *= n, "function" == typeof e && (e = e({
            type: "Rectangle",
            pixels: s
          })), e && (y.applyToPoint(s[0], s[0], e), y.applyToPoint(s[1], s[1], e)), this.setCoordinates([t.fromGlobalPixels(s[0], o), t.fromGlobalPixels(s[1], o)])
        },
        _setupRenderFlow: function() {
          var e = G;
          e[0].stage = this.getCoordinates, i.add(this, e, m, w)
        },
        _clearRenderFlow: function() {
          i.remove(this, G)
        }
      });
      var G = [{
        stage: null,
        event: {
          target: "self",
          event: "change"
        }
      }, {
        stage: x,
        options: ["projection", "coordRendering"]
      }, {
        stage: s,
        options: ["projection", "geodesic"]
      }, {
        stage: c.apply,
        event: {
          target: "map",
          event: "actionend",
          callback: c.onActionEnd
        }
      }, {
        stage: g.apply,
        options: ["projection", "pixelRendering"],
        event: {
          target: "map",
          event: "actionend",
          callback: g.onActionEnd
        }
      }];
      e(_)
    });
  }],
  [',R', function(ym) {
    ym.modules.define("geometryEditor.Base", ["util.defineClass", "event.Manager", "data.Manager", "option.Manager", "geometryEditor.options.mapper", "Monitor", "util.objectKeys", "util.cancelableCallback", "vow", "geometryEditor.Frame", "theme.islands.geometryEditor.meta"], function(e, t, i, s, r, n, a, d, o, h, l) {
      function f(e, t) {
        this.geometry = e, this.options = new r(t, null, "editor", n), this.state = new s(this.initialState), this.events = new i({
          context: this
        }), this._viewDeferred = null, this._modelDeferred = null, this._editingDeferred = null, this._drawingDeferred = null, this._stateEventData = {}, this._stateEventMonitor = new a(this.state), this._stateEventMonitor.add(d(this.initialState), D, this), this.state.events.add("change", v, this), this.options.events.add("change", m, this), this._stateActionMonitor = new a(this.state), this._stateActionMonitor.add("drawing", u, this).add("editing", g, this).add("framing", w, this)
      }

      function g(e, t) {
        if (e) {
          if (ym.env.debug && !this.geometry.getMap()) throw new Error("geometryEditor.Base: геометрия не имеет ссылки на карту.");
          this.state.get("framing") && this.state.set("framing", !1), this._modelDeferred = h.defer(), this._viewDeferred = h.defer(), this._loadModulesCallback = o.create(_, this), this.getModelClass().done(this._loadModulesCallback)
        } else this.state.get("drawing", !1) && this.state.set("drawing", !1), null != this._model && (this._model.destroy(), this._model = null), null != this._view && (this._view.destroy(), this._view = null), this._loadModulesCallback ? (this._loadModulesCallback.cancel(), this._loadModulesCallback = null, this._modelDeferred.reject(f.EditorCanceledError()), this._viewDeferred.reject(f.EditorCanceledError()), this._editingDeferred && this._editingDeferred.reject(f.EditorCanceledError())) : this.events.fire("editingstop"), this._viewDeferred = null, this._modelDeferred = null, this._editingDeferred = null
      }

      function _(e) {
        this._model = new e(this.geometry, this), this._modelDeferred.resolve(this._model), this._loadModulesCallback = o.create(c, this), h.all({
          viewClass: this.getViewClass(this._model),
          controllerClass: this.getControllerClass()
        }).done(this._loadModulesCallback)
      }

      function c(e) {
        this._loadModulesCallback = null, this._view = new e.viewClass(this._model, this), this._view.setController(new e.controllerClass), this._viewDeferred.resolve(this._view), this._editingDeferred || (this._editingDeferred = h.defer()), this._editingDeferred.resolve(), this._drawingDeferred || (this._drawingDeferred = h.defer()), this._drawingDeferred.resolve(), this.events.fire("editingstart"), this.state.get("drawing", !1) && this.events.fire("drawingstart")
      }

      function u(e, t) {
        e ? (this.state.get("framing") && this.state.set("framing", !1), this.state.get("editing") || this.state.set("editing", !0), null == this._loadModulesCallback && this.events.fire("drawingstart")) : null == this._loadModulesCallback ? this.events.fire("drawingstop") : (this._drawingDeferred && this._drawingDeferred.reject(f.EditorCanceledError()), this._drawingDeferred = null)
      }

      function w(e) {
        e ? (this.state.get("editing") && this.state.set("editing", !1), this._frameEditor = new l(this.geometry, this), this.events.fire("framingstart")) : this._frameEditor && (this._frameEditor.stop(), this.events.fire("framingstop"))
      }

      function m() {
        this.events.fire("optionschange")
      }

      function v() {
        var e = this._stateEventData;
        this._stateEventData = {}, this.events.fire("statechange", e)
      }

      function D(e, t) {
        for (var i in e)
          if (e.hasOwnProperty(i)) {
            var s = E(i, "old"),
              r = E(i, "new");
            "undefined" == typeof this._stateEventData[s] && (this._stateEventData[s] = t[i]), this._stateEventData[r] = e[i]
          }
      }

      function E(e, t) {
        return t + e.slice(0, 1).toUpperCase() + e.slice(1)
      }
      f.EditorCanceledError = function() {
        return new Error("Canceled")
      }, f.EditorWasNotStartedError = function() {
        return new Error("Editor wasn't started")
      }, t(f, {
        initialState: {
          drawing: !1,
          editing: !1,
          framing: !1
        },
        getModel: function() {
          return this._modelDeferred ? this._modelDeferred.promise() : h.reject(f.EditorWasNotStartedError())
        },
        getModelSync: function() {
          return this._model
        },
        getView: function() {
          return this._viewDeferred ? this._viewDeferred.promise() : h.reject(f.EditorWasNotStartedError())
        },
        getViewSync: function() {
          return this._view
        },
        startEditing: function() {
          return this.state.set("editing", !0), this._editingDeferred || (this._editingDeferred = h.defer()), this._editingDeferred.promise()
        },
        stopEditing: function() {
          this.state.set("editing", !1)
        },
        startDrawing: function() {
          return this.state.set("drawing", !0), this._drawingDeferred || (this._drawingDeferred = h.defer()), this._drawingDeferred.promise()
        },
        stopDrawing: function() {
          this.state.set("drawing", !1)
        },
        startFraming: function() {
          this.state.set("framing", !0)
        },
        stopFraming: function() {
          return this.state.set("framing", !1), h.resolve()
        },
        destroy: function() {
          this.state.set("editing", !1), this.state.set("framing", !1), this._stateActionMonitor.destroy(), this.options.events.remove("change", m, this), this.state.events.remove("change", v, this), this._stateEventMonitor.destroy()
        }
      }), e(f)
    });
  }],
  ['-K', function(ym) {
    ym.modules.define("geometryEditor.component.SubEntityManager", ["util.defineClass", "util.extend"], function(t, l, a) {
      function e(t, l, e) {
        this._callbacks = l, e = "string" == typeof e ? {
          keyFieldName: e
        } : e, this._params = a({}, i, e), this._subEntities = this._buildSubEntities(t, null)
      }
      var i = {
        keyFieldName: "",
        reuse: !1
      };
      l(e, {
        update: function(t) {
          var l = this._buildSubEntities(t, this._subEntities),
            a = this._callbacks.change;
          l != this._subEntities && (this._subEntities = l, a && a.callback.call(a.context))
        },
        getSubEntities: function() {
          return this._subEntities
        },
        destroy: function() {
          for (var t = this._callbacks.destroy, l = 0, a = this._subEntities.length; l < a; l++) {
            var e = this._subEntities[l];
            t && t.callback.call(t.context, e)
          }
        },
        _buildSubEntities: function(t, l) {
          var a = l ? this._updateSubEntities(t, l) : this._createSubEntities(t),
            e = this._callbacks.process;
          return e && e.callback.call(e.context, a, t), a
        },
        _createSubEntities: function(t) {
          for (var l = [], a = this._callbacks.create, e = 0, i = t.length; e < i; e++) {
            var s = a.callback.call(a.context, t[e], e, t);
            s && l.push(s)
          }
          return l
        },
        _updateSubEntities: function(t, l) {
          var a, e, i, s, c, n = l,
            u = this._callbacks.create,
            r = this._callbacks.found,
            b = this._callbacks.reuse,
            h = this._callbacks.compare,
            o = this._callbacks.destroy,
            _ = 0,
            f = [],
            k = [],
            d = !1,
            p = l.length;
          for (i = 0, c = t.length; i < c; i++) {
            var E = t[i];
            for (a = null, s = n == l ? _ : 0; s < p; s++)
              if (e = l[s]) {
                var g = h ? h.callback.call(h.context, e, E, i, t) : e[this._params.keyFieldName] == E;
                if (g) {
                  _ = s + 1, a = e, r && r.callback.call(r.context, a, E, i, t);
                  break
                }
              }
            n == l && (!a || a && s != i) && (n = i ? l.splice(0, i) : [], s -= i), n != l && (a ? l[s] = null : this._params.reuse ? (f.push(E), k.push(i)) : (a = u.callback.call(u.context, E, i, t), a || (d = !0)), n.push(a))
          }
          if (n == l && p != c && (n = l.splice(0, i)), n != l) {
            if (this._params.reuse)
              for (i = 0, c = f.length; i < c; i++) {
                var m = f[i],
                  v = k[i];
                for (a = null, s = 0; s < p; s++)
                  if (e = l[s]) {
                    a = e, l[s] = null, b && b.callback.call(b.context, a, m, v, t);
                    break
                  }
                a || (a = u.callback.call(u.context, m, v, t)), n[v] = a
              }
            if (o)
              for (i = 0, c = l.length; i < c; i++) e = l[i], e && o.callback.call(o.context, e);
            if (d) {
              var x = [];
              for (i = 0, c = n.length; i < c; i++) n[i] && x.push(n[i]);
              n = x
            }
          }
          return n
        }
      }), t(e)
    });
  }],
  ['-E', function(ym) {
    ym.modules.define("geometryEditor.Frame", ["util.defineClass", "option.Manager", "option.Mapper", "util.matrix.2d", "geometry.Polygon", "geometry.Point", "GeoObject", "GeoObjectCollection", "geometry.component.findClosestPathPosition", "system.nextTick", "util.vector", "util.pixelBounds", "event.Manager", "Monitor", "geometry.component.ShortestPath", "util.math.cycleRestrict", "geometryEditor.options.frameMapping"], function(t, e, o, i, s, r, n, a, h, l, p, _, m, d, f, u, g) {
      function c(t, e) {
        this.options = new o({}, e.options, "frame"), this.events = new d, this.events.setParent(e.events), this._map = t.getMap(), this._editor = e, this._tailUpdate = 0, this._init(t), this._spawnGeometry(), this._setupObject(), this._updating = 0, this._shortestPath = new u, t.events.add("change", this._onGeometryChange, this)
      }

      function P(t) {
        function e() {
          return t.state.get("drag") ? "editorFrame#DragPreset" : t.state.get("hover") ? "editorFrame#HoverPreset" : ""
        }
        var o = new f(t.state);
        o.add("hover", function(o) {
          t.options.set("preset", o ? "editorFrame#HoverPreset" : e())
        }), t.events.add("mousedown", function() {
          t.options.set("preset", "editorFrame#DragPreset")
        }).add("mouseup", function() {
          t.options.set("preset", e())
        }), o.add("drag", function(o) {
          t.options.set("preset", o ? "editorFrame#DragPreset" : e())
        })
      }

      function G(t, e, o) {
        var i = s.identity();
        t.getMap().action.getCurrentState().zoom;
        t.applyProjectedTransformation(function(t) {
          var e = m.fromPoints(t.pixels[0]),
            r = [(e[0][0] + e[1][0]) / 2, (e[0][1] + e[1][1]) / 2];
          return s.translate(i, i, [r[0], r[1]]), s.rotate(i, i, o), s.translate(i, i, [-r[0], -r[1]]), i
        })
      }

      function b(t) {
        return new t.constructor(JSON.parse(JSON.stringify(t.getCoordinates())))
      }

      function v(t, e) {
        var o = t[0],
          i = t[1],
          s = _.sub(o, i),
          r = _.sub(o, e),
          n = _.length(s),
          a = _.length(r);
        if (n < 1e-10 || a < 1) return !1;
        var h = _.scale(s, 1 / n),
          l = _.scale(r, 1 / a),
          p = _.cross(h, l);
        return [h[1] * a * p, -h[0] * a * p]
      }

      function y(t, e) {
        for (var o = [], i = Math.pow(2, -e), s = Math.pow(2, e), r = 0, n = t.length; r < n; ++r) o.push([t[r][0] * i, t[r][1] * i]);
        t = (new u).calculate(o, [!0, !0], {
          unbounded: !0
        }), o = [];
        for (var r = 0, n = t.length; r < n; ++r) o.push([t[r][0] * s, t[r][1] * s]);
        return o
      }

      function x(t, e, o, i) {
        var s = y([o._projectionToGlobalPixels(t[0], i), o._projectionToGlobalPixels(t[1], i), o._projectionToGlobalPixels(t[2], i), o._projectionToGlobalPixels(t[3], i)], i),
          r = (4 + e - 1) % 4,
          n = (e + 1) % 4,
          a = (e + 2) % 4,
          h = _.sub(s[e], s[r]),
          l = [h[1], -h[0]],
          p = v([s[e], s[r]], s[a]),
          m = v([s[e], _.sub(s[e], l)], s[a]);
        if (!p || !m) return t;
        var d = _.sub(s[a], p),
          f = _.sub(s[a], m);
        return s[r] = d, s[n] = f, t = [o._projectionFromGlobalPixels(s[0], i), o._projectionFromGlobalPixels(s[1], i), o._projectionFromGlobalPixels(s[2], i), o._projectionFromGlobalPixels(s[3], i)], t[4] = t[0], t
      }

      function j(t) {
        var e = _.sub(t[1], t[0]),
          o = _.sub(t[1], t[2]),
          i = _.length(e),
          s = _.length(o);
        return i > 1e-4 && s > 1e-4
      }

      function M(t) {
        for (var e = 0, o = 0, i = t.length - 1; o < i; ++o) e += (t[o][0] - t[o + 1][0]) * (t[o][1] + t[o + 1][1]) * .5;
        return e > 0 ? 1 : -1
      }
      var w = 30,
        C = ym.env.coordinatesOrder;
      e(c, {
        _init: function(t) {
          this._lastMatrix = s.identity(), this._bounds = t.getBounds(), this._geometry = t, this._clone = b(t)
        },
        stop: function() {
          this.collection.removeAll(), this.collection.setParent(null), this.collection.options.setParent(null), this._frameGeometry.setMap(null);
          for (var t = 0; t < 9; t++) this._points[t].setMap(null), this._points[t].options.setParent(null);
          this._points = 0
        },
        _spawnGeometry: function() {
          var t = this._bounds;
          this._frameGeometry = new r([
            [
              [t[0][0], t[0][1]],
              [t[1][0], t[0][1]],
              [t[1][0], t[1][1]],
              [t[0][0], t[1][1]],
              [t[0][0], t[0][1]]
            ],
            [
              [0, 0],
              [0, 0],
              [0, 0]
            ]
          ], "nonZero"), this._points = [new n([0, 0]), new n([0, 0]), new n([0, 0]), new n([0, 0]), new n([0, 0]), new n([0, 0]), new n([0, 0]), new n([0, 0]), new n([0, 0])], this._frameGeometry.events.add("pixelgeometrychange", this.updatePoints, this), this._frameGeometry.setMap(this._map), this._frameGeometry.options.setParent(this._map.options), this._frameGeometry.options.set("coordRendering", "shortestPath");
          for (var e = 0; e < 9; e++) this._points[e].setMap(this._map), this._points[e].options.setParent(this._frameGeometry.options);
          this.updatePoints()
        },
        _setupObject: function() {
          var t, e, o = this.collection = new h;
          o.options.setMapper(T), o.options.setParent(this.options), o.add(e = new a({
            geometry: this._frameGeometry
          })), e.options.setName("contour"), e.events.add("dragstart", this._startUpdating, this), e.events.add("beforedrag", this._beforeDrag, this), e.events.add("dragend", this._stopUpdating, this);
          for (var i = 0; i < 8; i++) o.add(t = new a({
            geometry: this._points[i],
            properties: {
              index: i
            }
          })), t.events.add("dragstart", this._vertexDragStart, this), t.events.add("dragend", this._vertexDragEnd, this), t.events.add("beforedrag", this._vertexDrag, this), t.options.setName(i % 2 ? "vertex" : "edge"), P(t);
          o.add(t = new a({
            geometry: this._points[8],
            properties: {
              index: 8
            }
          }, {
            useAutoPanInDragging: !1
          })), t.options.setName("edge"), P(t), t.events.add("dragstart", this._rotatePointStart, this), t.events.add("dragend", this._rotatePointEnd, this), t.events.add("beforedrag", this._rotatePointDrag, this), o.setParent(this._map.geoObjects)
        },
        _onGeometryChange: function(t) {
          this._updating || this._tailUpdate || !this._points || (this.stop(), this._init(t.get("target")), this._spawnGeometry(), this._setupObject())
        },
        _rotatePointStart: function() {
          this._frameBounds = 0, this._rotating = 1, this._startUpdating(), this._updatePoints()
        },
        _rotatePointEnd: function() {
          this._rotating = 0, this._updatePoints(), this._stopUpdating()
        },
        _rotatePointDrag: function(t) {
          if (t.preventDefault(), !this._tailUpdate) {
            var e = this._frameGeometry.getMap().getZoom(),
              o = t.get("position"),
              i = this._points[8].getCoordinates(),
              s = this._projectionToGlobalPixels(i, e);
            this._frameBounds.position || (this._frameBounds.position = [o[0], o[1]], this._frameBounds.start = [s[0], s[1]]);
            var r = this._frameBounds.start,
              n = this._frameBounds.position,
              a = [o[0] - n[0], o[1] - n[1]],
              h = [r[0] + a[0], r[1] + a[1]],
              l = this._frameBounds.bounds,
              p = [(l[0][0] + l[1][0]) / 2, (l[0][1] + l[1][1]) / 2],
              m = 256 * (1 << e),
              d = [g(p[0], 0, m), g(p[1], 0, m)],
              f = this._frameGeometry.options.get("projection"),
              u = this._shortestPath.calculate([d, s, h], f.isCycled(), {
                worldSize: 256 * (1 << e)
              }),
              c = _.normalize(_.sub(u[0], u[1])),
              P = _.normalize(_.sub(u[0], u[2])),
              b = _.cross(c, P);
            G(this._frameGeometry, l, Math.asin(b)), this._frameGeometry.getPixelGeometry(), this._updatePoints()
          }
        },
        _vertexDragStart: function() {
          this._startUpdating()
        },
        _vertexDragEnd: function() {
          this._frameGeometry.getPixelGeometry(), this._updatePoints(), this._stopUpdating()
        },
        _beforeDrag: function() {
          this._tailUpdate = 0, this._updatePoints()
        },
        _vertexDrag: function(t) {
          if (t.preventDefault(), !this._tailUpdate) {
            var e = this._frameGeometry.getMap().getZoom(),
              o = t.get("target"),
              i = t.get("pixelOffset"),
              s = o.properties.get("index"),
              r = Math.floor(s / 2),
              n = this._frameGeometry.getChildGeometry(0),
              a = n.getCoordinates(),
              h = [i[0] + this._tmpOffset[0], i[1] + this._tmpOffset[1]];
            if (this._tmpOffset[0] += i[0], this._tmpOffset[1] += i[1], h[0] || h[1]) {
              if (s % 2 == 1) {
                var l = a[r],
                  p = a[r + 1],
                  m = this._projectionToGlobalPixels(l, e),
                  d = this._projectionToGlobalPixels(p, e),
                  f = [.5 * (m[0] + d[0]), .5 * (m[1] + d[1])],
                  u = [f[0] + h[0], f[1] + h[1]],
                  g = v([m, d], u);
                if (!g) return;
                if (l = [m[0] + g[0], m[1] + g[1]], p = [d[0] + g[0], d[1] + g[1]], !j([l, p, a[(r + 2) % 4]])) return;
                a[r] = this._projectionFromGlobalPixels(l, e), a[r > 2 ? 0 : r + 1] = this._projectionFromGlobalPixels(p, e)
              } else {
                var c = r > 0 ? r - 1 : 3,
                  P = r > 2 ? 0 : r + 1,
                  l = a[c],
                  G = a[r],
                  p = a[P],
                  m = this._projectionToGlobalPixels(l, e),
                  f = this._projectionToGlobalPixels(G, e),
                  d = this._projectionToGlobalPixels(p, e),
                  u = [f[0] + h[0], f[1] + h[1]],
                  b = v([f, m], u),
                  y = v([f, d], u);
                if (!b || !y) return;
                var M = b,
                  w = y,
                  C = _.length(M),
                  T = _.length(w),
                  F = _.add(b, y);
                if (C < 1 && T < 1) return;
                var l = [m[0] + M[0], m[1] + M[1]],
                  p = [f[0] + F[0], f[1] + F[1]],
                  D = [d[0] + w[0], d[1] + w[1]];
                if (!j([l, p, D])) return;
                if (a[c] = this._projectionFromGlobalPixels(l, e), a[r] = this._projectionFromGlobalPixels(p, e), a[P] = this._projectionFromGlobalPixels(D, e), a = x(a, r, this, e), !a) return
              }
              this._tmpOffset = [0, 0], n.freeze(), a[4] = a[0], n.setCoordinates(a), n.unfreeze(), this._frameGeometry.getPixelGeometry(), this._updatePoints()
            }
          }
        },
        updatePoints: function() {
          if (!this._tailUpdate) {
            var t = this;
            p(function() {
              t._frameGeometry.getMap() && t._updatePoints()
            })
          }
        },
        _updatePoints: function() {
          this._shortestPath.reset();
          var t = this._frameGeometry.getMap();
          this._rotating && this._frameBounds && this._frameBounds.zoom == t.getZoom() || (this._frameBounds = {
            zoom: t.getZoom(),
            bounds: m.fromPoints(this._frameGeometry.getPixelGeometry().getCoordinates()[0])
          });
          var e = this._frameGeometry.getCoordinates()[0],
            o = this._frameGeometry.getMap().getZoom(),
            i = [];
          e = x(e, 0, this, o);
          for (var s = 0; s < 4; s++) {
            var r = e[s],
              n = e[s + 1],
              a = this._projectionToGlobalPixels(r, o),
              h = this._projectionToGlobalPixels(n, o);
            i.push(a), this._points[2 * s].setCoordinates(r), this._points[2 * s + 1].setCoordinates(this._projectionFromGlobalPixels([(a[0] + h[0]) / 2, (a[1] + h[1]) / 2], o))
          }
          i.push(i[0]);
          var l = "longlat" == C ? 4 : 2,
            p = 1,
            r = this._points[l].getCoordinates(),
            _ = this._points[l + 1].getCoordinates(),
            n = this._points[l + 2].getCoordinates(),
            a = this._projectionToGlobalPixels(r, o),
            d = this._projectionToGlobalPixels(_, o),
            h = this._projectionToGlobalPixels(n, o),
            f = [h[0] - a[0], h[1] - a[1]],
            u = Math.sqrt(f[0] * f[0] + f[1] * f[1]),
            g = [f[0] / u, f[1] / u],
            c = [g[1], -g[0]],
            P = p * M(i),
            G = [d[0] + c[0] * w * P, d[1] + c[1] * w * P],
            b = this._projectionFromGlobalPixels(G, o),
            v = this._projectionFromGlobalPixels(d, o);
          this._points[8].setCoordinates(b), this._tailUpdate = 1, this._frameGeometry.getChildGeometry(1).setCoordinates([v, b, v]), this._applyTransformation(this._getTransformation()), this._tailUpdate = 0
        },
        _getTransformation: function() {
          function t(t) {
            return o._projectionToGlobalPixels(t, e)
          }
          this._shortestPath.reset();
          var e = this._frameGeometry.getMap().getZoom(),
            o = this,
            i = s.identity(),
            r = this._bounds,
            n = [t(r[0]), t(r[1])],
            a = [(n[0][0] + n[1][0]) / 2, (n[0][1] + n[1][1]) / 2],
            h = [n[1][0] - n[0][0], n[1][1] - n[0][1]],
            l = _.sub([n[1][0], n[0][1]], n[0]),
            p = this._frameGeometry.options.get("projection"),
            m = this._shortestPath.calculate(this._frameGeometry.getPixelGeometry().getCoordinates()[0], p.isCycled(), {
              worldSize: 256 * (1 << e)
            }),
            d = this._frameBounds.bounds,
            f = [(d[0][0] + d[1][0]) / 2, (d[0][1] + d[1][1]) / 2],
            u = [a[0] - f[0], a[1] - f[1]],
            g = "longlat" == C ? 1 : 0,
            c = "longlat" == C ? -1 : 1,
            P = _.sub(m[g + 1], m[g]),
            G = _.sub(m[g + 2], m[g + 1]),
            b = [_.length(G), -_.length(P)],
            v = [b[0] / h[0], c * b[1] / h[1]];
          Math.abs(h[0]) < 1e-6 || Math.abs(h[1]) < 1e-6 || Math.abs(b[0]) < 1.5 || Math.abs(b[1]) < 1.5;
          var y = 1e-4;
          Math.abs(v[0]) < y && (v[0] = v[0] > 0 ? y : -y), Math.abs(v[1]) < y && (v[1] = v[1] > 0 ? y : -y);
          var x = Math.abs(v[0] / v[1]);
          if (!(x < y || x > 1 / y)) {
            l = _.normalize(l), P = _.normalize(P), G = _.normalize(G);
            var j = _.cross(l, G),
              w = _.cross(l, P) * c,
              T = M(m);
            return j = c * Math.asin(j), w > 0 && (j = Math.PI - j), T < 0 && (j = -j, v[0] *= -1), s.translate(i, i, [a[0], a[1]]), s.translate(i, i, [-u[0], -u[1]]), s.rotate(i, i, j), s.scale(i, i, v), s.translate(i, i, [-a[0], -a[1]]), i
          }
        },
        _startUpdating: function() {
          this._shortestPath.reset(), this._updating = 1, this._tmpOffset = [0, 0], this.events.fire("framingbegin")
        },
        _stopUpdating: function() {
          this.events.fire("framingend"), this._updating = 0
        },
        _applyTransformation: function(t) {
          if (t && this._updating) {
            var e = s.determinant(t),
              o = s.determinant(this._lastMatrix),
              i = 1;
            Math.abs(e - o) > 1e-19 && (i = 1), i && (this._lastMatrix = t, this._geometry.freeze(), this._geometry.setCoordinates(b(this._clone).getCoordinates()), this._geometry.applyProjectedTransformation(t), this._geometry.unfreeze())
          }
        },
        _projectionFromGlobalPixels: function(t, e) {
          var o = this._frameGeometry.options.get("projection"),
            i = 256 * (1 << e),
            s = [g(t[0], 0, i), g(t[1], 0, i)];
          return o.fromGlobalPixels(s, e)
        },
        _projectionToGlobalPixels: function(t, e) {
          var o = this._frameGeometry.options.get("projection"),
            i = this._shortestPath.calculate([o.toGlobalPixels(t, 0)], o.isCycled())[0],
            s = 1 << e;
          return [i[0] * s, i[1] * s]
        }
      });
      var T = new i("prefixed");
      T.setRule({
        key: ["projection"],
        rule: "plain"
      }), t(c)
    });
  }],
  ['-x', function(ym) {
    ym.modules.define("geometryEditor.LineString", ["util.defineClass", "util.extend", "geometryEditor.Base", "geometryEditor.storage", "vow"], function(e, r, o, t, i, l) {
      var n = {
          model: null,
          view: null,
          controller: null
        },
        s = function(e, r) {
          s.superclass.constructor.call(this, e, r)
        };
      r(s, t, {
        initialState: o({}, t.prototype.initialState, {
          drawingFrom: "end"
        }),
        getModelClass: function() {
          if (null != n.model) return l.resolve(n.model);
          var e = l.defer();
          return ym.modules.require(["geometryEditor.model.RootLineString", "geometryEditor.view.Path", "geometryEditor.controller.LineString"], function(r) {
            n.model = r, e.resolve(r)
          }, this), e.promise()
        },
        getViewClass: function(e) {
          if (null != n.view) return l.resolve(n.view);
          var r = l.defer();
          return ym.modules.require(["geometryEditor.view.Path"], function(e) {
            n.view = e, r.resolve(e)
          }, this), r.promise()
        },
        getControllerClass: function() {
          if (null != n.controller) return l.resolve(n.controller);
          var e = l.defer();
          return ym.modules.require(["geometryEditor.controller.LineString"], function(r) {
            n.controller = r, e.resolve(r)
          }, this), e.promise()
        }
      }), e(s), i.add("LineString", s)
    });
  }],
  [',T', function(ym) {
    ym.modules.define("geometryEditor.options.frameMapping", ["geometryEditor.options.mapper", "option.Mapper", "option.presetStorage"], function(e, o, r, i) {
      o.setRule({
        name: "frame",
        key: ["projection"],
        rule: "plain"
      }).setRule({
        name: "frame",
        rule: r.addOptionalPrefixForBalloonHint
      }), i.add("editorFrame#HoverPreset", {
        iconRadius: 8
      }), i.add("editorFrame#DragPreset", {
        iconFillColor: "FFD943"
      }), e(!0)
    });
  }],
  [',V', function(ym) {
    ym.modules.define("geometryEditor.options.mapper", ["option.Mapper"], function(e, o) {
      e(new o)
    });
  }],
  ['-y', function(ym) {
    ym.modules.define("geometryEditor.Point", ["util.defineClass", "geometryEditor.Base", "geometryEditor.storage", "vow"], function(e, o, r, t, l) {
      var i = {
          model: null,
          view: null,
          controller: null
        },
        n = function(e, o) {
          n.superclass.constructor.call(this, e, o)
        };
      o(n, r, {
        getModelClass: function() {
          if (null != i.model) return l.resolve(i.model);
          var e = l.defer();
          return ym.modules.require(["geometryEditor.model.RootVertex", "geometryEditor.view.Point", "geometryEditor.controller.Point"], function(o) {
            i.model = o, e.resolve(o)
          }, this), e.promise()
        },
        getViewClass: function(e) {
          if (null != i.view) return l.resolve(i.view);
          var o = l.defer();
          return ym.modules.require(["geometryEditor.view.Point"], function(e) {
            i.view = e, o.resolve(e)
          }, this), o.promise()
        },
        getControllerClass: function() {
          if (null != i.controller) return l.resolve(i.controller);
          var e = l.defer();
          return ym.modules.require(["geometryEditor.controller.Point"], function(o) {
            i.controller = o, e.resolve(o)
          }, this), e.promise()
        }
      }), e(n), t.add("Point", n)
    });
  }],
  ['-B', function(ym) {
    ym.modules.define("geometryEditor.Polygon", ["util.defineClass", "util.extend", "geometryEditor.Base", "geometryEditor.storage", "vow"], function(e, o, r, t, l, i) {
      var n = {
          model: null,
          view: null,
          controller: null
        },
        u = function(e, o) {
          u.superclass.constructor.call(this, e, o)
        };
      o(u, t, {
        initialState: r({}, t.prototype.initialState, {
          drawingFrom: "end",
          drawingPath: 0
        }),
        getModelClass: function() {
          if (null != n.model) return i.resolve(n.model);
          var e = i.defer();
          return ym.modules.require(["geometryEditor.model.RootPolygon", "geometryEditor.view.MultiPath", "geometryEditor.controller.Polygon"], function(o) {
            n.model = o, e.resolve(o)
          }, this), e.promise()
        },
        getViewClass: function(e) {
          if (null != n.view) return i.resolve(n.view);
          var o = i.defer();
          return ym.modules.require(["geometryEditor.view.MultiPath"], function(e) {
            n.view = e, o.resolve(e)
          }, this), o.promise()
        },
        getControllerClass: function() {
          if (null != n.controller) return i.resolve(n.controller);
          var e = i.defer();
          return ym.modules.require(["geometryEditor.controller.Polygon"], function(o) {
            n.controller = o, e.resolve(o)
          }, this), e.promise()
        }
      }), e(u), l.add("Polygon", u)
    });
  }],
  ['-C', function(ym) {
    ym.modules.define("geometryEditor.storage", ["util.Storage"], function(e, o) {
      e(new o)
    });
  }],
  ['4f', function(ym) {
    ym.modules.define("GeoObject", ["util.defineClass", "geoObject.abstract.GeoObject", "event.globalize", "Event", "geoObject.metaOptions", "theme.islands.geoObject.meta.full"], function(e, t, s, n, a) {
      function c(e, t) {
        c.superclass.constructor.call(this, e, t), this.events.addController(o), this.events.fire("create", new a({
          type: "create",
          target: this
        }))
      }
      var o = n(c);
      t(c, s), e(c)
    });
  }],
  ['$k', function(ym) {
    ym.modules.define("geoObject.abstract.GeoObject", ["util.defineClass", "geoObject.component.castGeometry", "geoObject.component.castProperties", "data.Manager", "option.Manager", "geoObject.optionMapper", "event.Manager", "geoObject.component.ObjectImplementation", "Event"], function(e, t, n, o, a, r, c, i, s, g) {
      function p(e, t) {
        this.geometry = n(e && e.geometry), this.properties = o(e && e.properties), this.state = new a, this.options = new r(t, null, "geoObject", c), this.events = new i({
          context: this
        }), this._geoObjectComponent = this.createGeoObjectComponent()
      }
      t(p, {
        setParent: function(e) {
          return this._geoObjectComponent.setParent(e), this
        },
        getParent: function() {
          return this._geoObjectComponent.getParent()
        },
        getMap: function() {
          return this._geoObjectComponent.getMap()
        },
        getOverlay: function() {
          return this._geoObjectComponent.getOverlay()
        },
        getOverlaySync: function() {
          return this._geoObjectComponent.getOverlaySync()
        },
        getOverlays: function() {
          return this._geoObjectComponent.getOverlays()
        },
        getOverlaysSync: function() {
          return this._geoObjectComponent.getOverlaysSync()
        },
        createGeoObjectComponent: function() {
          return new s(this, this.geometry, this.properties, this.options, this.events, this.state, {
            onParentChange: {
              callback: this.parentChangeCallback,
              context: this
            },
            onMapChange: {
              callback: this.mapChangeCallback,
              context: this
            }
          })
        },
        parentChangeCallback: function(e, t) {
          this.events.fire("parentchange", new g({
            type: "parentchange",
            target: this,
            oldParent: e,
            newParent: t
          }))
        },
        mapChangeCallback: function(e, t) {
          this.events.fire("mapchange", new g({
            type: "mapchange",
            target: this,
            oldMap: e,
            newMap: t
          }))
        }
      }), e(p)
    });
  }],
  ['$l', function(ym) {
    ym.modules.define("geoObject.abstract.Sequence", ["util.defineClass", "geoObject.abstract.GeoObject", "geoObject.component.BoundsAggregator", "component.array.ParentArray", "event.Mapper", "geoObject.EventMappingTable"], function(n, t, e, o, i, s, c) {
      function r(n, t) {
        r.superclass.constructor.call(this, n, t), this._boundsAggregator = null, this._collectionComponent = this.createCollectionComponent(n && n.children || [])
      }
      t(r, e, {
        get: function(n) {
          return this._collectionComponent.get(n)
        },
        getLength: function() {
          return this._collectionComponent.getLength()
        },
        each: function(n, t) {
          return this._collectionComponent.each(n, t), this
        },
        getIterator: function() {
          return this._collectionComponent.getIterator()
        },
        indexOf: function(n) {
          return this._collectionComponent.indexOf(n)
        },
        getPixelBounds: function() {
          return this._boundsAggregator ? this._boundsAggregator.getPixelBounds() : null
        },
        getBounds: function() {
          return this._boundsAggregator ? this._boundsAggregator.getBounds() : null
        },
        createCollectionComponent: function(n) {
          return new i(n, this, {}, new s(this.events, new c(this)))
        },
        toArray: function() {
          return this._collectionComponent.toArray()
        },
        mapChangeCallback: function(n, t) {
          n && (this._boundsAggregator.destroy(), this._boundsAggregator = null), r.superclass.mapChangeCallback.call(this, n, t), t && (this._boundsAggregator = new o(this, {
            onPixelBoundsChange: {
              callback: this._pixelBoundsChangeCallback,
              context: this
            },
            onGeoBoundsChange: {
              callback: this._geoBoundsChangeCallback,
              context: this
            }
          }))
        },
        _pixelBoundsChangeCallback: function() {
          this.events.fire("pixelboundschange")
        },
        _geoBoundsChangeCallback: function() {
          this.events.fire("boundschange")
        }
      }), n(r)
    });
  }],
  ['$m', function(ym) {
    ym.modules.define("geoObject.addon.balloon", ["GeoObject", "popup.addonBuilder", "geoObject.Balloon"], function(e, a, n, t) {
      e(n.build({
        type: "balloon",
        metaEventManager: a.getMetaEventManager(),
        defaultManager: t,
        lazyInit: !0,
        initEvents: ["clickdefaultaction"]
      }))
    });
  }],
  ['$o', function(ym) {
    ym.modules.define("geoObject.addon.editor", ["GeoObject", "Event", "util.Associate", "util.extend", "util.defineProperty", "geometryEditor.storage", "geoObject.optionMapper", "util.EventPropagator", "option.Mapper", "geometryEditor.LineString", "geometryEditor.Point", "geometryEditor.Polygon"], function(e, t, r, n, o, i, a, d, g, s) {
      function u(e) {
        if (!("editor" in e)) {
          var t, r;
          i(e, "editor", function() {
            return r ? r : (t || (t = c(e)), t)
          }, function(e) {
            r = e
          })
        }
      }

      function c(e) {
        var t, n = a.get(e.geometry.getType());
        return n && (t = new n(e.geometry, {}), t.options.setParent(e.options), t.options.set("geoObject", e), e.getOverlay().then(function(e) {
          p(t, e)
        }), t.events.add("statechange", l, e), e.events.add("mapchange", v, e).add("overlaychange", f, e), new g(t.events, ["beforevertexadd", "vertexadd", "beforevertexdraw", "vertexdraw", "beforeedgedragstart", "edgedragstart", "beforeedgedrag", "edgedrag", "edgedragend", "beforevertexdragstart", "vertexdragstart", "beforevertexdrag", "vertexdrag", "vertexdragend"], e.events, function(e) {
          return "editor" + e
        }, {
          callback: function(t, n, o) {
            return new r({
              type: o,
              target: e
            }, t)
          },
          context: this
        })), t
      }

      function l(e) {
        this.events.fire("editorstatechange", {
          originalEvent: e
        })
      }

      function v() {
        this.editor.state.get("editing") && this.editor.stopEditing(), this.editor.state.get("framing") && this.editor.stopFraming()
      }

      function f(e) {
        p(this.editor, e.get("overlay"))
      }

      function p(e, t) {
        e.options.set(t ? {
          pointOverlay: t,
          guideLinesOverlay: t
        } : {
          pointOverlay: null,
          guideLinesOverlay: null
        })
      }
      var y = ym.env.browser.oldIE,
        m = new n(function(e) {
          return this.create(e), e.editor
        });
      o(m, {
        create: function(e) {
          e.geometry && (y ? e.editor = c(e) : u(e))
        }
      }), d.setRule({
        name: "editor",
        rule: s.addOptionalPrefixForBalloonHint
      }).setRule({
        name: "editor",
        key: ["projection"],
        rule: "plain"
      }), t.getMetaEventManager().add("create", function(e) {
        m.create(e.get("target"))
      }), e(m)
    });
  }],
  ['$p', function(ym) {
    ym.modules.define("geoObject.addon.hint", ["GeoObject", "popup.addonBuilder", "geoObject.Hint"], function(e, t, n, a) {
      e(n.build({
        type: "hint",
        metaEventManager: t.getMetaEventManager(),
        defaultManager: a,
        lazyInit: !0,
        initEvents: ["mouseenterdefaultaction"]
      }))
    });
  }],
  ['4c', function(ym) {
    ym.modules.define("geoObject.Balloon", ["util.defineClass", "component.sharedEntity.captor.Balloon", "Balloon", "event.Manager", "map.addon.balloon", "geoObject.balloonPositioner.storage", "geoObject.optionMapper", "option.Manager", "Monitor", "projection.idle", "util.component", "util.preset", "vow", "popup.managerStorage", "popup.component.checkEmptiness", "balloon.component.getBalloonMode", "geoObject.balloonPositioner.circle", "geoObject.balloonPositioner.point", "geoObject.balloonPositioner.polygon", "geoObject.balloonPositioner.lineString", "geoObject.balloonPositioner.rectangle"], function(e, t, o, n, i, s, a, r, c, l, h, g, p, _, u, d, b) {
      function f(e) {
        this._geoObject = e, this.events = new i({
          context: this
        }), this._panelModeMonitor = null, this._setupCaptor(), this._setupListeners()
      }
      var O = {
          visible: !1
        },
        m = {
          autoPan: !1
        };
      t(f, g.createProxyMethods(function() {
        return this._captor
      }, ["close", "isOpen", "getOverlay", "getOverlaySync", "autoPan", "getOwner", "getPosition", "getData", "getOptions"]), {
        destroy: function() {
          this._clearListeners(), this._clearCaptor()
        },
        isEmpty: function(e, t, o) {
          var n = this.specifyData(t);
          return n.options = new c(o || {}, this._geoObject.options, "balloon"), d(this._geoObject.getMap(), "balloon", this._specifyPosition(e, o && o.projection), n)
        },
        open: function(e, t, o) {
          return this._captor.open(this._specifyPosition(e, o && o.projection), this.specifyData(t), o)
        },
        setPosition: function(e) {
          return this._captor.setPosition(this._specifyPosition(e))
        },
        setData: function(e) {
          return this._captor.setData(this.specifyData(e))
        },
        setOptions: function(e) {
          return this._captor.setOptions(this._specifyOptions(e))
        },
        _setupCaptor: function() {
          var e = this._geoObject.getMap(),
            t = e && s.get(e);
          this._captor = new o(this, this._geoObject, "balloon", t), this._captor.events.add("open", this._onOpen, this).add("close", this._onClose, this)
        },
        _clearCaptor: function() {
          this._captor.destroy(), this._captor = null
        },
        _setupListeners: function() {
          this._geoObject.events.add("clickdefaultaction", this._onClickDefault, this).add("mapchange", this._onMapChange, this)
        },
        _clearListeners: function() {
          this._geoObject.events.remove("clickdefaultaction", this._onClickDefault, this).remove("mapchange", this._onMapChange, this)
        },
        _onClickDefault: function(e) {
          var t = this._geoObject,
            o = t.options,
            n = {
              projection: h,
              panelMode: "panel" == b(t.getMap(), t.options.get("balloonPanelMaxMapArea"))
            },
            i = e.get("originalEvent"),
            s = i.get("globalPixels");
          if (o.get("openBalloonOnClick", !0))
            if (this.isOpen() && "Point" == t.geometry.getType()) this.close();
            else if (o.get("openEmptyBalloon", !1)) this.open(s, null, n);
          else {
            var a = this._geoObject.getMap().action.getCurrentState().zoom;
            this.isEmpty(s, null, n).then(function(e) {
              if (!e) {
                var t = this._geoObject.getMap().action.getCurrentState().zoom,
                  o = Math.pow(2, t - a);
                1 != o && (s = [s[0] * o, s[1] * o]), this.open(s, null, n)
              }
            }, this)
          }
        },
        _specifyPosition: function(e, t) {
          var o = this._geoObject,
            n = o.geometry.getPixelGeometry(),
            i = e ? (t || o.options.get("projection")).toGlobalPixels(e, o.getMap().getZoom()) : o.getMap().getGlobalPixelCenter();
          if (ym.env.debug && !n) throw new Error("geoObject.Balloon._specifyPosition: У геообъекта отсутствует пиксельная геометрия.");
          return this._anchorPixels = a.get(n.getType()).calculatePosition(n, i)
        },
        specifyData: function(e) {
          var t = this._geoObject;
          return {
            geometry: t.geometry,
            properties: t.properties,
            state: t.state,
            geoObject: t,
            userData: e
          }
        },
        _onOpen: function() {
          var e = this._geoObject,
            t = this._captor.getPopup().getOverlaySync();
          e.state.set("active", !0), e.events.add("beforedrag", this._onBeforeDrag, this).add("dragstart", this._disableAutoPan, this).add("dragend", this._enableAutoPan, this), e.geometry.events.add("pixelgeometrychange", this._onGeoObjectPixelGeometryChange, this), this._geoObjectMap = e.getMap(), this._geoObjectMap.events.add("boundschange", this._onMapBoundsChange, this), "Point" == e.geometry.getType() && e.options.get("hideIconOnBalloonOpen") && (this._panelModeMonitor = new l(t.options).add("panelMode", this._toggleIcon, this), t.options.get("panelMode") || this._toggleIcon())
        },
        _onClose: function() {
          var e = this._geoObject;
          "Point" == e.geometry.getType() && (this._showIcon(), this._panelModeMonitor && (this._panelModeMonitor.removeAll(), this._panelModeMonitor = null)), this._geoObjectMap && this._geoObjectMap.events.remove("boundschange", this._onMapBoundsChange, this), e.geometry.events.remove("pixelgeometrychange", this._onGeoObjectPixelGeometryChange, this), e.events.remove("dragend", this._enableAutoPan, this).remove("dragstart", this._disableAutoPan, this).remove("beforedrag", this._onBeforeDrag, this), e.state.set("active", !1)
        },
        _disableAutoPan: function() {
          p.addTo(this.getOptions(), m)
        },
        _enableAutoPan: function() {
          p.removeFrom(this.getOptions(), m)
        },
        _hideIcon: function() {
          p.addTo(this._geoObject.options, O)
        },
        _showIcon: function() {
          p.removeFrom(this._geoObject.options, O)
        },
        _onGeoObjectPixelGeometryChange: function(e) {
          if (this.isOpen()) {
            var t = this._geoObject.geometry.getPixelGeometry();
            if (!t.getCoordinates().length) return void this.close();
            this._disableAutoPan(), this._anchorPixels = a.get(t.getType()).calculatePosition(t, this._anchorPixels), this._captor.setPosition(this._anchorPixels), this._enableAutoPan()
          }
        },
        _onBeforeDrag: function(e) {
          var t = e.get("pixelOffset"),
            o = this._anchorPixels;
          this._anchorPixels = [o[0] + t[0], o[1] + t[1]]
        },
        _onMapBoundsChange: function(e) {
          var t = e.get("oldZoom"),
            o = e.get("newZoom");
          if (t != o) {
            var n = Math.pow(2, o - t),
              i = this._anchorPixels;
            this._anchorPixels = [i[0] * n, i[1] * n]
          }
        },
        _toggleIcon: function(e) {
          e ? this._showIcon() : this._hideIcon()
        },
        _onMapChange: function() {
          this._geoObject.getMap() ? this._setupSharingManager() : this.close()
        },
        _setupSharingManager: function() {
          this._captor.setSharingManager(s.get(this._geoObject.getMap()))
        }
      }), u.add("geoObject#balloon", f), r.setRule({
        name: "balloon",
        rule: "prefixed"
      }).setRule({
        name: "balloon",
        key: ["projection"],
        rule: "plain"
      }), e(f)
    });
  }],
  ['$r', function(ym) {
    ym.modules.define("geoObject.balloonPositioner.circle", ["geoObject.balloonPositioner.storage"], function(o, e) {
      var t = {
        calculatePosition: function(o, e) {
          var t = o.getCoordinates(),
            i = o.getRadius(),
            n = [e[0] - t[0], e[1] - t[1]],
            a = Math.sqrt(n[0] * n[0] + n[1] * n[1]);
          return a < i ? e : [t[0] + n[0] * i / a, t[1] + n[1] * i / a]
        }
      };
      e.add("Circle", t), o(t)
    });
  }],
  ['$t', function(ym) {
    ym.modules.define("geoObject.balloonPositioner.lineString", ["geoObject.balloonPositioner.storage", "geometry.component.findClosestPathPosition"], function(o, n, e) {
      var t = {
        calculatePosition: function(o, n) {
          var t = e(o.getCoordinates(), n);
          return t ? t.position : null
        }
      };
      n.add("LineString", t), o(t)
    });
  }],
  ['$u', function(ym) {
    ym.modules.define("geoObject.balloonPositioner.point", ["geoObject.balloonPositioner.storage"], function(o, e) {
      var n = {
        calculatePosition: function(o) {
          return o.getCoordinates()
        }
      };
      e.add("Point", n), o(n)
    });
  }],
  ['$w', function(ym) {
    ym.modules.define("geoObject.balloonPositioner.polygon", ["geoObject.balloonPositioner.storage", "geometry.component.pointInPolygon"], function(o, e, n) {
      var t = {
        calculatePosition: function(o, e) {
          if (n(e, o.getCoordinates(), o.getFillRule())) return e;
          var t = o.getClosest(e);
          return t ? t.position : null
        }
      };
      e.add("Polygon", t), o(t)
    });
  }],
  ['$x', function(ym) {
    ym.modules.define("geoObject.balloonPositioner.rectangle", ["geoObject.balloonPositioner.storage", "geometry.component.findClosestPathPosition", "util.pixelBounds"], function(o, n, e, t) {
      var i = {
        calculatePosition: function(o, n) {
          var i = o.getBounds();
          return t.containsPoint(i, n) ? n : e([i[0],
            [i[0][0], i[1][1]], i[1],
            [i[1][0], i[0][1]], i[0]
          ], n).position
        }
      };
      n.add("Rectangle", i), o(i)
    });
  }],
  ['$y', function(ym) {
    ym.modules.define("geoObject.balloonPositioner.storage", ["util.Storage"], function(e, o) {
      var n = new o;
      e(n)
    });
  }],
  ['$C', function(ym) {
    ym.modules.define("geoObject.component.BoundsAggregator", ["util.defineClass", "util.bind", "util.bounds", "util.pixelBounds", "util.math.areEqual"], function(e, t, o, i, n, s) {
      function l(e, t) {
        this._geoObjectCollection = e, this._callbacks = t;
        for (var o, i = this._geoObjectCollection.getIterator();
          (o = i.getNext()) != i.STOP_ITERATION;) this._processChild(o, "add");
        this._geoObjectCollection.events.add("add", this._onCollectionAdd, this).add("remove", this._onCollectionRemove, this).add("set", this._onCollectionSet, this), this._pixelBounds = d, this._geoBounds = this._calculateGeoBounds(), this._oldGeoBounds = d, this._timeoutId = null
      }

      function c(e, t) {
        return !e && !t || e && t && s(e[0], t[0], 0) && s(e[1], t[1], 0)
      }
      var d = {};
      t(l, {
        getPixelBounds: function() {
          return this._pixelBounds == d && (this._pixelBounds = this._calculatePixelBounds()), this._pixelBounds
        },
        getBounds: function() {
          return this._geoBounds == d && (this._geoBounds = this._calculateGeoBounds()), this._geoBounds
        },
        destroy: function() {
          this._timeoutId && clearTimeout(this._timeoutId), this._geoObjectCollection.events.remove("add", this._onCollectionAdd, this).remove("remove", this._onCollectionRemove, this).remove("set", this._onCollectionSet, this);
          for (var e, t = this._geoObjectCollection.getIterator();
            (e = t.getNext()) != t.STOP_ITERATION;) this._processChild(e, "remove")
        },
        _onCollectionAdd: function(e) {
          e.get("target") == this._geoObjectCollection && (this._processChild(e.get("child"), "add"), this._processBoundsChange())
        },
        _onCollectionRemove: function(e) {
          e.get("target") == this._geoObjectCollection && (this._processChild(e.get("child"), "remove"), this._processBoundsChange())
        },
        _onCollectionSet: function(e) {
          e.get("target") == this._geoObjectCollection && (this._processChild(e.get("prevChild"), "remove"), this._processChild(e.get("child"), "add"), this._processBoundsChange())
        },
        _processChild: function(e, t) {
          e && ("function" == typeof e.getPixelBounds ? e.events[t]("pixelboundschange", this._onPixelBoundsChange, this) : e.geometry && e.geometry.events[t]("pixelgeometrychange", this._onPixelGeometryChange, this))
        },
        _onPixelBoundsChange: function() {
          this._processBoundsChange()
        },
        _onPixelGeometryChange: function() {
          this._processBoundsChange()
        },
        _processBoundsChange: function() {
          this._oldGeoBounds == d && (this._oldGeoBounds = this._geoBounds), this._geoBounds = d, this._pixelBounds = d;
          var e = this._callbacks.onPixelBoundsChange;
          e.callback.call(e.context), this._timeoutId || (this._timeoutId = setTimeout(this._timeoutHandler || (this._timeoutHandler = o(this._onTimeoutExpired, this)), 0))
        },
        _onTimeoutExpired: function() {
          this._timeoutId = null;
          var e = this._oldGeoBounds;
          this._oldGeoBounds = d;
          var t = this.getBounds();
          if (!c(t, e)) {
            var o = this._callbacks.onGeoBoundsChange;
            o.callback.call(o.context, t, e)
          }
        },
        _calculatePixelBounds: function() {
          for (var e, t = this._geoObjectCollection.getIterator(), o = this._geoObjectCollection.geometry ? this._geoObjectCollection.geometry.getPixelGeometry().getBounds() : null;
            (e = t.getNext()) != t.STOP_ITERATION;) {
            var i = null;
            e && ("function" == typeof e.getPixelBounds ? i = e.getPixelBounds() : e.geometry && (i = e.geometry.getPixelGeometry().getBounds())), i && (o = o ? n.fromBounds([o, i]) : i)
          }
          return o
        },
        _calculateGeoBounds: function() {
          var e = this._geoObjectCollection.options.get("projection");
          if (ym.env.debug && !e) throw new Error("geoObject.component.BoundsAggregator: значение опции projection не определено");
          var t = this.getPixelBounds();
          return t ? i.fromGlobalPixelBounds(t, this._geoObjectCollection.getMap().getZoom(), e) : null
        }
      }), e(l)
    });
  }],
  ['$D', function(ym) {
    ym.modules.define("geoObject.component.castGeometry", ["geoObject.geometryFactory"], function(e, t) {
      var o = function(e) {
        return e ? "function" == typeof e.getType ? e : t.createGeometry(e) : null
      };
      e(o)
    });
  }],
  ['$F', function(ym) {
    ym.modules.define("geoObject.component.castProperties", ["data.Manager"], function(e, n) {
      var t = function(e) {
        return e && "function" == typeof e.get ? e : new n(e)
      };
      e(t)
    });
  }],
  ['$G', function(ym) {
    ym.modules.define("geoObject.component.ObjectImplementation", ["Event", "geoObject.View", "vow", "component.child.MapChild"], function(t, e, n, i, s) {
      function a(t, e, n, i, a, o, r) {
        this._context = t, this._geometry = e, this._properties = n, this._options = i, this._events = a, this._state = o, this._callbacks = r, this._mapItem = new s({
          onMapChange: {
            callback: this._mapChangeCallback,
            context: this
          },
          onParentChange: this._callbacks.onParentChange
        }), e && (e.options.setParent(i), e.events.add("change", this._onGeometryChange, this)), n && n.events.add("change", this._onPropertiesChange, this), i.events.add("change", this._onOptionsChange, this)
      }
      a.WasNotAddedToMapError = function() {
        return new Error("GeoObject wasn't added to map")
      }, a.prototype = {
        setParent: function(t) {
          this._mapItem.setParent(t)
        },
        getParent: function() {
          return this._mapItem.getParent()
        },
        getMap: function() {
          return this._mapItem.getMap()
        },
        getOverlay: function() {
          return this._view ? this._view.getOverlay() : i.reject(a.WasNotAddedToMapError())
        },
        getOverlaySync: function() {
          return this._view ? this._view.getOverlaySync() : null
        },
        getOverlays: function() {
          return this._view ? this._view.getOverlays() : i.reject(a.WasNotAddedToMapError())
        },
        getOverlaysSync: function() {
          return this._view ? this._view.getOverlaysSync() : []
        },
        _mapChangeCallback: function(t, e) {
          t && this._clearView(), this._geometry && this._geometry.setMap(e), e && this._setupView();
          var n = this._callbacks.onMapChange;
          n && (n.context ? n.callback.call(n.context, t, e) : n.callback(t, e))
        },
        _onOptionsChange: function() {
          this._events.fire("optionschange", new e({
            type: "optionschange",
            target: this._context
          }))
        },
        _onPropertiesChange: function() {
          this._events.fire("propertieschange", new e({
            type: "propertieschange",
            target: this._context
          }))
        },
        _onGeometryChange: function(t) {
          this._events.fire("geometrychange", new e({
            type: "geometrychange",
            target: this._context,
            originalEvent: t
          }))
        },
        _setupView: function() {
          this._view = new n(this._context, this._geometry, this._properties, this._options, this._events, this._state, this.getMap())
        },
        _clearView: function() {
          this._view.destroy(), this._view = null
        }
      }, t(a)
    });
  }],
  ['3J', function(ym) {
    ym.modules.define("geoObject.EventMappingTable", ["util.defineClass", "MapEvent"], function(e, n, t) {
      function i(e) {
        this._geoObject = e, this.parentchange = !1, this.mapchange = !1, this.optionschange = !1, this.boundschange = !1, this.pixelboundschange = !1, this["*"] = this._defaultMapping
      }
      n(i, {
        _defaultMapping: function(e) {
          return new t({
            currentTarget: this._geoObject
          }, e)
        }
      }), e(i)
    });
  }],
  ['4m', function(ym) {
    ym.modules.define("geoObject.geometryFactory", ["util.Storage", "geometry.Point", "geometry.LineString", "geometry.Polygon", "geometry.Rectangle", "geometry.Circle"], function(e, n, t, r, o, i, c) {
      var a = new n;
      a.createGeometry = function(e) {
        var n = this.get(e.type);
        if (ym.env.debug && !n) throw new Error("geoObject.geometryFactory: неизвестный тип геометрии " + e.type);
        return n(e)
      }, e(a), a.add("Point", function(e) {
        return new t(e.coordinates)
      }), a.add("LineString", function(e) {
        return new r(e.coordinates)
      }), a.add("Polygon", function(e) {
        return new o(e.coordinates, e.fillRule)
      }), a.add("Rectangle", function(e) {
        return new i(e.coordinates)
      }), a.add("Circle", function(e) {
        return new c(e.coordinates, e.radius)
      })
    });
  }],
  ['4p', function(ym) {
    ym.modules.define("geoObject.Hint", ["util.defineClass", "Hint", "event.Manager", "geoObject.optionMapper", "component.sharedEntity.captor.Popup", "option.Manager", "projection.idle", "map.addon.hint", "util.component", "util.preset", "util.pixelBounds", "util.extend", "vow", "popup.managerStorage", "popup.component.checkEmptiness"], function(e, t, o, n, i, s, a, r, c, h, p, u, _, g, l, d) {
      function b(e) {
        this._geoObject = e, this.events = new n({
          context: this
        }), this._setupCaptor(), this._setupListeners()
      }
      t(b, h.createProxyMethods(function() {
        return this._captor
      }, ["close", "isOpen", "getOverlay", "getOverlaySync", "autoPan", "getOwner", "getPosition", "getData", "setOptions", "getOptions"]), {
        destroy: function() {
          this._clearListeners(), this._clearCaptor()
        },
        isEmpty: function(e, t, o) {
          var n = this._specifyData(t);
          return n.options = new a(o || {}, this._geoObject.options, "hint"), d(this._geoObject.getMap(), "hint", this._specifyPosition(e, o && o.projection), n)
        },
        open: function(e, t, o) {
          return this._captor.open(this._specifyPosition(e, o && o.projection), this._specifyData(t), o)
        },
        setPosition: function(e) {
          return this._captor.setPosition(this._specifyPosition(e))
        },
        setData: function(e) {
          return this._captor.setData(this._specifyData(e))
        },
        _setupCaptor: function() {
          var e = this._geoObject.getMap(),
            t = e && c.get(e);
          this._captor = new s(this, this._geoObject, "hint", t), this._captor.events.add("capture", function() {
            this.close(!0)
          }, this)
        },
        _clearCaptor: function() {
          this._captor.destroy(), this._captor = null
        },
        _setupListeners: function() {
          this._geoObject.events.add("mapchange", this._onMapChange, this).add("mouseenterdefaultaction", this._onGeoObjectMouseEnter, this).add(["dragstart", "balloonopen"], this._disable, this).add(["dragend", "balloonclose"], this._enable, this)
        },
        _clearListeners: function() {
          this._geoObject.events.remove(["dragend", "balloonclose"], this._enable, this).remove(["dragstart", "balloonopen"], this._disable, this).remove("mouseenterdefaultaction", this._onGeoObjectMouseEnter, this).remove("mapchange", this._onMapChange, this)
        },
        _onGeoObjectMouseEnter: function(e) {
          this._openAndHandleMouse(e.get("originalEvent").get("globalPixels"))
        },
        _onGeoObjectMouseMove: function(e) {
          return this._captor.setPosition(this._specifyPosition(e.get("globalPixels"), r))
        },
        _onGeoObjectMouseLeave: function(e) {
          this._closeAndUnhandleMouse()
        },
        _openAndHandleMouse: function(e) {
          this._tryOpenOnHover(e).then(function() {
            this._geoObject.events.add("mousemove", this._onGeoObjectMouseMove, this).add("mouseleave", this._onGeoObjectMouseLeave, this)
          }, this)
        },
        _closeAndUnhandleMouse: function(e) {
          this.close(e), this._geoObject.events.remove("mousemove", this._onGeoObjectMouseMove, this).remove("mouseleave", this._onGeoObjectMouseLeave, this)
        },
        _disable: function() {
          this._disabled = !0, this._closeAndUnhandleMouse(!0)
        },
        _enable: function(e) {
          var t = this._geoObject;
          t.state.get("active") || t.state.get("drag") || (this._disabled = !1, t.getMap() && this._openAndHandleMouse())
        },
        _onMapChange: function() {
          this._geoObject.getMap() ? this._setupSharingManager() : this.close(!0)
        },
        _setupSharingManager: function() {
          this._captor.setSharingManager(c.get(this._geoObject.getMap()))
        },
        _tryOpenOnHover: function(e) {
          var t = g.defer(),
            o = g.defer(),
            n = {
              projection: r
            };
          return this._disabled || !this._geoObject.options.get("openHintOnHover", !0) ? t.reject() : this._geoObject.options.get("openEmptyHint", !1) ? t.resolve() : this.isEmpty(e, null, n).then(function(e) {
            e ? t.reject() : t.resolve()
          }, t.reject, t), t.promise().then(function() {
            this._geoObject.state.get("hover") ? (o.resolve(), this.open(e, null, n)) : o.reject()
          }, this), o.promise()
        },
        _specifyPosition: function(e, t) {
          return e ? (t || this._geoObject.options.get("projection")).toGlobalPixels(e, this._geoObject.getMap().getZoom()) : u.getCenter(this._geoObject.geometry.getPixelGeometry().getBounds())
        },
        _specifyData: function(e) {
          var t = this._geoObject;
          return {
            geometry: t.geometry,
            properties: t.properties,
            state: t.state,
            geoObject: t,
            userData: e
          }
        }
      }), l.add("geoObject#hint", b), i.setRule({
        name: "hint",
        rule: "prefixed"
      }).setRule({
        name: "hint",
        key: ["projection"],
        rule: "plain"
      }), e(b)
    });
  }],
  ['4t', function(ym) {
    ym.modules.define("geoObject.metaOptions", ["interactivityModel.geoObject", "map.metaOptions"], function(e, t, o) {
      o.set("geoObjectInteractivityModel", t.geoObject), e({})
    });
  }],
  ['4w', function(ym) {
    ym.modules.define("geoObject.optionMapper", ["option.Mapper"], function(e, o) {
      e(new o)
    });
  }],
  ['4A', function(ym) {
    ym.modules.define("geoObject.View", ["util.defineClass", "vow", "util.array", "util.bind", "util.callbackChunker", "util.cancelableCallback", "constants.zIndex", "option.Manager", "option.Mapper", "Monitor", "geoObject.view.component.Dragger", "geoObject.view.overlayMapping", "overlay.storage", "event.Mapper", "geoObject.view.component.OverlayEventMappingTable"], function(e, t, i, r, s, n, a, o, l, h, _, v, p, c, g, y) {
      function u(e, t, i, r, s, a, l) {
        this._geoObject = e, this._geometry = t, this._properties = i, this._options = r, this._events = s, this._state = a, this._map = l, this._overlays = [], this._oldOverlay = this._overlays[0] || null, this._overlayData = null, this._overlayOptionManager = null, this._overlayRequireCallback = null, this._overlayDeferred = null, this._overlaysDeferred = null, this._chunker = n.get(l), this._chunkerCallbackId = NaN;
        var h = t && "Point" == t.getType();
        this._optionMonitor = r.getMonitor({
          visible: !0,
          draggable: !1,
          interactiveOptions: h,
          interactiveZIndex: h,
          zIndex: o.overlay,
          zIndexActive: h ? o.activePoint : o.active,
          zIndexDrag: o.drag,
          zIndexHover: o.hover
        }), this._zIndexOptionName = "", t ? (this._setupVisible(), this._optionMonitor.get("visible") && this._initOverlayListeners(), this._startOverlayCreating()) : this._overlayRejectMessageFunc = u.GeoObjectIsHiddenError
      }
      u.GeoObjectIsHiddenError = function() {
        return new Error("GeoObject is not visible")
      }, u.GeoObjectRemovedFromMapError = function() {
        return new Error("GeoObject was removed from map")
      }, u.OverlayWasntFoundError = function() {
        return new Error("Overlay wasn't found")
      }, t(u, {
        getOverlay: function() {
          return this._overlayDeferred || (this._overlayDeferred = i.defer(), this._overlayRejectMessageFunc ? this._overlayDeferred.reject(this._overlayRejectMessageFunc()) : this._overlays.length > 0 && this._overlayDeferred.resolve(this._overlays[0])), this._overlayDeferred.promise()
        },
        getOverlaySync: function() {
          return this._overlays[0] || null
        },
        getOverlays: function() {
          return this._overlaysDeferred || (this._overlaysDeferred = i.defer(), this._overlayRejectMessageFunc ? this._overlaysDeferred.reject(this._overlayRejectMessageFunc()) : this._overlays.length > 0 && this._overlaysDeferred.resolve(this._overlays)), this._overlaysDeferred.promise()
        },
        getOverlaysSync: function() {
          return this._overlays.slice()
        },
        destroy: function() {
          this._geometry && (this._clearDraggable(), this._clearPixelGeometryChangeListener(), this._rejectOverlayDeferreds(u.GeoObjectRemovedFromMapError), this._clearOverlays(), this._clearInteractiveOptions(), this._clearOverlayOptionManager(), this._overlayData = null, this._clearZIndex(), this._clearVisible(), this._clearOverlayClassListener())
        },
        _initOverlayListeners: function() {
          this._overlayListenersInited || (this._overlayListenersInited = !0, this._pixelGeometry = this._geometry.getPixelGeometry(), this._setupOverlayClassListener(), this._setupPixelGeometryChangeListener())
        },
        _startOverlayCreating: function() {
          this._overlayDeferred = null, this._overlaysDeferred = null, this._constructOverlays()
        },
        _clearOverlays: function() {
          this._overlayDeferred = null, this._overlaysDeferred = null;
          for (var e = 0, t = this._overlays.length; e < t; e++) this._clearOverlay(this._overlays[e]);
          this._overlays = [], t > 0 && this._fireOverlayChange()
        },
        _constructOverlays: function() {
          if (!this._geometry.getBounds() || !this._optionMonitor.get("visible")) return void this._rejectOverlayDeferreds(u.GeoObjectIsHiddenError);
          this._overlayRejectMessageFunc = null;
          var e = this._getOverlayOptionKey(this._pixelGeometry.getType()),
            t = this._options.get(e);
          if ("string" == typeof t) {
            var i = t;
            if (t = c.get(i), "undefined" == typeof t) return this._overlayRequireCallback = a.create(function(e) {
              this._overlayRequireCallback = null, this._createOverlay(e)
            }, this), void c.require([i]).spread(this._overlayRequireCallback, function() {
              this._rejectOverlayDeferreds(u.OverlayWasntFoundError)
            }, this)
          }
          this._createOverlay(t)
        },
        _createOverlay: function(e) {
          this._overlayClass = e, this._options.get("syncOverlayInit", !1) ? this._setupOverlay() : this._chunkerCallbackId = this._chunker.addCallback(function() {
            this._chunkerCallbackId = NaN, this._setupOverlay()
          }, this)
        },
        _resolveOverlayDeferreds: function() {
          this._overlayDeferred && this._overlayDeferred.resolve(this._overlays[0]), this._overlaysDeferred && this._overlaysDeferred.resolve(this._overlays)
        },
        _rejectOverlayDeferreds: function(e) {
          this._clearAsyncOperations(), this._overlayRejectMessageFunc = e, this._overlayDeferred && this._overlayDeferred.reject(e()), this._overlaysDeferred && this._overlaysDeferred.reject(e())
        },
        _clearAsyncOperations: function() {
          this._overlayRequireCallback && (this._overlayRequireCallback.cancel(), this._overlayRequireCallback = null), this._chunkerCallbackId && (this._chunker.removeCallback(this._chunkerCallbackId), this._chunkerCallbackId = NaN)
        },
        _setupOverlay: function() {
          var e = new this._overlayClass(this._geometry.getPixelGeometry(), this._getOverlayData());
          this._setupDraggable(), e.options.set("zIndex", this._getZIndex()), this._setupOverlayOptionManager();
          var t = e.options.getName();
          this._overlayOptionNames.hasOwnProperty(t) || (this._overlayOptionNames[t] = null, p.setupMapping(this._overlayOptionMapper, t, e.getGeometry().getType())), this._setupInteractiveOptions(), e.options.setParent(this._overlayOptionManager), e.setMap(this._map), e.events.setParent(new g(this._events, new y(this._geoObject))), this._overlays.push(e), this._resolveOverlayDeferreds(), this._fireOverlayChange()
        },
        _clearOverlay: function(e) {
          e.events.setParent(null), e.setMap(null), e.options.setParent(null)
        },
        _getOverlayData: function() {
          return this._overlayData || (this._overlayData = {
            geometry: this._geometry,
            properties: this._properties,
            state: this._state,
            geoObject: this._geoObject
          })
        },
        _getOverlayOptionKey: function(e) {
          return e.charAt(0).toLowerCase() + e.substring(1) + "Overlay"
        },
        _fireOverlayChange: function() {
          var e = this._oldOverlay,
            t = this._overlays[0] || null;
          this._oldOverlay = t, this._events.fire("overlaychange", {
            overlay: t,
            oldOverlay: e
          })
        },
        _setupInteractiveOptions: function() {
          this._optionMonitor.add("interactiveOptions", this._onInteractiveOptionsChange, this), this._optionMonitor.get("interactiveOptions") && (this._setupStateMonitor(this._updateStateMapping), this._setupStateMapping())
        },
        _clearInteractiveOptions: function() {
          this._optionMonitor.get("interactiveOptions") && (this._clearStateMapping(), this._clearStateMonitor(this._updateStateMapping)), this._optionMonitor.remove("interactiveOptions", this._onInteractiveOptionsChange, this)
        },
        _onInteractiveOptionsChange: function(e) {
          e ? (this._setupStateMonitor(this._updateStateMapping), this._setupStateMapping()) : (this._clearStateMapping(), this._clearStateMonitor(this._updateStateMapping))
        },
        _setupStateMapping: function() {
          this._stateOptionMapper = new h, this._stateOptionManager = new l(null, this._options, "stateMapping", this._stateOptionMapper), this._overlayOptionManager.setParent(this._stateOptionManager), this._stateOptionMapper.setRule({
            name: "overlayMapping",
            rule: s(this._stateMappingRule, this)
          })
        },
        _clearStateMapping: function() {
          this._overlayOptionManager && (this._overlayOptionManager.setParent(this._options), this._overlayOptionManager = null), this._stateOptionMapper = null, this._stateOptionManager = null
        },
        _stateMappingRule: function(e) {
          var t = [];
          return this._stateMonitor.get("active") && t.push(h.addPrefix("active", e)), this._stateMonitor.get("drag") && t.push(h.addPrefix("drag", e)), this._stateMonitor.get("hover") && t.push(h.addPrefix("hover", e)), t.length ? (t.push(e), t) : e
        },
        _updateStateMapping: function() {
          this._stateOptionMapper && this._stateOptionMapper.fireChange()
        },
        _setupVisible: function() {
          this._optionMonitor.add("visible", this._onVisibleChange, this)
        },
        _clearVisible: function() {
          this._optionMonitor.remove("visible", this._onVisibleChange, this)
        },
        _onVisibleChange: function(e) {
          e ? (this._initOverlayListeners(), this._startOverlayCreating()) : (this._rejectOverlayDeferreds(u.GeoObjectIsHiddenError), this._clearOverlays())
        },
        _setupOverlayClassListener: function() {
          this._overlayClassOptionKey = this._getOverlayOptionKey(this._pixelGeometry.getType()), this._optionMonitor.add(this._overlayClassOptionKey, this._onOverlayClassChange, this)
        },
        _clearOverlayClassListener: function() {
          this._overlayListenersInited && this._overlayClassOptionKey && this._optionMonitor.remove(this._overlayClassOptionKey, this._onOverlayClassChange, this)
        },
        _onOverlayClassChange: function() {
          this._clearAsyncOperations(), this._clearOverlays(), this._clearOverlayOptionManager(), this._startOverlayCreating()
        },
        _setupPixelGeometryChangeListener: function() {
          this._geometry.events.add("pixelgeometrychange", this._onPixelGeometryChange, this)
        },
        _clearPixelGeometryChangeListener: function() {
          this._overlayListenersInited && this._geometry.events.remove("pixelgeometrychange", this._onPixelGeometryChange, this)
        },
        _onPixelGeometryChange: function() {
          if (this._optionMonitor.get("visible")) {
            var e = this._geometry.getPixelGeometry(),
              t = this._geometry.getBounds(),
              i = e.getType() != this._pixelGeometry.getType();
            if (!t) return this._rejectOverlayDeferreds(u.GeoObjectIsHiddenError), void this._clearOverlays();
            if (i) return this._rejectOverlayDeferreds(u.GeoObjectIsHiddenError), this._clearOverlays(), this._clearOverlayClassListener(), this._pixelGeometry = this._geometry.getPixelGeometry(), this._startOverlayCreating(), void this._setupOverlayClassListener();
            if (!this._overlays.length) return void(this._overlayRequireCallback || this._chunkerCallbackId || (this._rejectOverlayDeferreds(u.GeoObjectIsHiddenError), this._startOverlayCreating()));
            for (var r = 0, s = this._overlays.length; r < s; r++) this._overlays[r].setGeometry(e)
          }
        },
        _setupOverlayOptionManager: function() {
          this._overlayOptionManager || (this._overlayOptionNames = {}, this._overlayOptionMapper = new h, this._overlayOptionManager = new l(null, this._options, "overlayMapping", this._overlayOptionMapper))
        },
        _clearOverlayOptionManager: function() {
          this._overlayOptionManager && (this._overlayOptionManager.setParent(null), this._overlayOptionManager = null)
        },
        _setupDraggable: function() {
          this._draggableInited || (this._draggableInited = !0, this._optionMonitor.add("draggable", this._onDraggableChange, this), this._optionMonitor.get("draggable") && this._setupDragger())
        },
        _clearDraggable: function() {
          this._draggableInited && (this._optionMonitor.get("draggable") && this._clearDragger(), this._optionMonitor.remove("draggable", this._onDraggableChange, this))
        },
        _onDraggableChange: function(e) {
          e ? this._setupDragger() : this._clearDragger()
        },
        _setupDragger: function() {
          this._draggerComponent = new v(this._geoObject, this._events, this._state, this._geometry, {
            onDragStart: this._onDragStart,
            onDragStop: this._onDragStop,
            context: this
          })
        },
        _clearDragger: function() {
          this._draggerComponent && this._draggerComponent.destroy()
        },
        _onDragStart: function() {
          var e = this._overlays;
          if (e)
            for (var t = 0, i = e.length; t < i; t++) e[t].options.set("cursor", "grabbing")
        },
        _onDragStop: function() {
          var e = this._overlays;
          if (e)
            for (var t = 0, i = e.length; t < i; t++) e[t].options.unset("cursor")
        },
        _setupZIndex: function() {
          this._optionMonitor.add("interactiveZIndex", this._onInteractiveZIndexChange, this), this._optionMonitor.get("interactiveZIndex") && this._setupStateMonitor(this._updateZIndexOptionName), this._setupZIndexOptionName(this._getZIndexOptionName())
        },
        _clearZIndex: function() {
          this._zIndexOptionName && (this._clearZIndexOptionName(), this._optionMonitor.get("interactiveZIndex") && this._clearStateMonitor(this._updateZIndexOptionName), this._optionMonitor.remove("interactiveZIndex", this._onInteractiveZIndexChange, this))
        },
        _onInteractiveZIndexChange: function(e) {
          e ? this._setupStateMonitor(this._updateZIndexOptionName) : this._clearStateMonitor(this._updateZIndexOptionName), this._updateZIndexOptionName()
        },
        _setupStateMonitor: function(e) {
          this._stateMonitor || (this._stateMonitor = new _(this._state), this._stateMonitor.add(["active", "drag", "hover"], this._onStateChange, this), this._stateMonitorListeners = []), this._stateMonitorListeners.push(e)
        },
        _clearStateMonitor: function(e) {
          var t = r.indexOf(this._stateMonitorListeners, e);
          t != -1 && this._stateMonitorListeners.splice(t, 1), !this._stateMonitorListeners.length && this._stateMonitor && (this._stateMonitor.destroy(), this._stateMonitor = null)
        },
        _onStateChange: function() {
          for (var e = 0, t = this._stateMonitorListeners.length; e < t; e++) this._stateMonitorListeners[e].call(this)
        },
        _updateZIndexOptionName: function() {
          var e = this._getZIndexOptionName();
          this._zIndexOptionName != e && (this._clearZIndexOptionName(), this._setupZIndexOptionName(e), this._updateOverlaysZIndex())
        },
        _setupZIndexOptionName: function(e) {
          this._zIndexOptionName = e, this._optionMonitor.add(e, this._updateOverlaysZIndex, this)
        },
        _clearZIndexOptionName: function() {
          this._optionMonitor.remove(this._zIndexOptionName, this._updateOverlaysZIndex, this), this._zIndexOptionName = null
        },
        _updateOverlaysZIndex: function() {
          if (this._overlays)
            for (var e = this._getZIndex(), t = 0, i = this._overlays.length; t < i; t++) this._overlays[t].options.set("zIndex", e)
        },
        _getZIndex: function() {
          return this._zIndexDefaults = {
            zIndex: o.overlay,
            zIndexActive: "Point" == this._geometry.getType() ? o.activePoint : o.active,
            zIndexDrag: o.drag,
            zIndexHover: o.hover
          }, this._setupZIndex(), this._getZIndex = this._zIndexGetter, this._zIndexGetter()
        },
        _zIndexGetter: function() {
          return this._optionMonitor.get(this._zIndexOptionName)
        },
        _getZIndexOptionName: function() {
          if (this._stateMonitor) {
            if (this._stateMonitor.get("active")) return "zIndexActive";
            if (this._stateMonitor.get("drag")) return "zIndexDrag";
            if (this._stateMonitor.get("hover")) return "zIndexHover"
          }
          return "zIndex"
        }
      }), e(u)
    });
  }],
  [',o', function(ym) {
    ym.modules.define("geoObject.view.component.Dragger", ["util.fireWithBeforeEvent", "util.DraggerWithAutoPan", "util.Dragger", "Event", "util.matrix.2d"], function(t, e, i, s, o, n) {
      function r(t, e, o, n, r) {
        this._geoObject = t, this._events = e, this._state = o, this._geometry = n, this._options = r, this._geoObjectListener = this._geoObject.events.group().add("mousedown", g, this), this._geoObject.options.get("useAutoPanInDragging", !0) ? this._dragger = new i({
          disableBrowserBehavior: !0,
          useMapMargin: this._geoObject.options.get("useMapMarginInDragging", !0)
        }, t.getMap()) : this._dragger = new s({
          disableBrowserBehavior: !0
        }), this._draggerEvents = this._dragger.events.group().add("start", a, this).add("move", p, this).add("stop", c, this)
      }

      function g(t) {
        var e = t.get("domEvent");
        t.get("target") == this._geoObject && 0 == e.get("button") && (this._dragger.start(e), t.preventDefault())
      }

      function a(t) {
        e(this._events, {
          type: "dragstart",
          target: this._geoObject,
          domEvent: t.get("domEvent"),
          position: t.get("position")
        }, {
          context: this,
          successCallback: h,
          preventCallback: d
        })
      }

      function h(t) {
        this._state.set("drag", !0), this._options.onDragStart && this._options.onDragStart.call(this._options.context), this._events.fire(t.type, t)
      }

      function d(t) {
        this._dragger.stop(t.domEvent)
      }

      function p(t) {
        e(this._events, {
          type: "drag",
          target: this._geoObject,
          pixelOffset: t.get("delta"),
          domEvent: t.get("domEvent"),
          position: t.get("position")
        }, {
          context: this,
          successCallback: _,
          mutableFields: ["pixelOffset"]
        })
      }

      function _(t) {
        this._geometry.applyProjectedTransformation(n.translate([], n.identity(), t.pixelOffset)), this._events.fire(t.type, t)
      }

      function c(t) {
        this._state.get("drag") && (this._state.unset("drag"), this._options.onDragStop && this._options.onDragStop.call(this._options.context), this._events.fire("dragend", new o({
          type: "dragend",
          target: this._geoObject,
          domEvent: t.get("domEvent"),
          position: t.get("position")
        })))
      }
      r.prototype = {
        destroy: function() {
          this._geoObjectListener.removeAll(), this._draggerEvents.removeAll(), this._dragger.stop()
        }
      }, t(r)
    });
  }],
  [',p', function(ym) {
    ym.modules.define("geoObject.view.component.hoverDispatcher", ["util.defineClass", "util.Associate", "MapEvent"], function(e, t, o, n) {
      function s(e) {
        this._map = e, this._object = null
      }
      t(s, {
        setObject: function(e, t) {
          this._object && this._unhoverObject(t), this._object = e, t.get("domEvent").get("propagatedData").processedByHoverDispatcher = !0, this._object && this._hoverObject(t)
        },
        setLastEvent: function(e) {
          e.get("domEvent").get("propagatedData").processedByHoverDispatcher = !0
        },
        _hoverObject: function(e) {
          this._object.state.set("hover", !0), this._object.events.fire("hover", new n({
            type: "hover",
            target: this._object,
            map: this._map
          }, e)), this._map.container.events.add(["mouseenter", "mousemove"], this._onContainerMouseEvent, this)
        },
        _unhoverObject: function(e) {
          this._object.state.set("hover", !1), this._object.events.fire("unhover", new n({
            type: "unhover",
            target: this._object,
            map: this._map
          }, e)), this._map.container.events.remove(["mouseenter", "mousemove"], this._onContainerMouseEvent, this)
        },
        _onContainerMouseEvent: function(e) {
          e.get("domEvent").get("propagatedData").processedByHoverDispatcher || (this._unhoverObject(e), this._object = null)
        }
      }), e(new o(function(e) {
        return new s(e)
      }))
    });
  }],
  [',r', function(ym) {
    ym.modules.define("geoObject.view.component.OverlayEventMappingTable", ["util.defineClass", "MapEvent", "geoObject.view.component.hoverDispatcher"], function(e, t, n, a) {
      function g(e) {
        this._geoObject = e
      }

      function i(e) {
        var t = a.get(this._geoObject.getMap());
        return t.setObject(this._geoObject, e), this._defaultMapping(e)
      }

      function o(e) {
        return a.get(this._geoObject.getMap()).setLastEvent(e), this._defaultMapping(e)
      }

      function p(e) {
        return a.get(this._geoObject.getMap()).setObject(null, e), this._defaultMapping(e)
      }

      function c(e) {
        return new n({
          type: e.get("type"),
          target: this._geoObject,
          map: this._geoObject.getMap(),
          domEvent: e.get("domEvent"),
          originalEvent: e
        }, e)
      }
      t(g, {
        geometrychange: !1,
        propertieschange: !1,
        optionschange: !1,
        datachange: !1,
        mapchange: !1,
        emptinesschange: !1,
        shapechange: !1,
        mouseenter: i,
        mousemove: o,
        mouseleave: p,
        "*": c,
        _hoverMapping: i,
        _defaultMapping: c
      }), e(g)
    });
  }],
  ['$R', function(ym) {
    ym.modules.define("geoObject.view.overlayMapping", ["util.extend", "util.Storage"], function(e, n, t) {
      function i(e, n) {
        return n + e.slice(0, 1).toUpperCase() + e.slice(1)
      }

      function r(e, n) {
        return [i(e, n), e]
      }
      var o = new t,
        u = {
          key: ["projection"],
          rule: "plain"
        },
        a = ["icons", "cursor", "interactivityModel", "pane", "eventsPane", "shadowsPane", "interactive"];
      o.setupMapping = function(e, t, i) {
        var r = this.get(i);
        if (r)
          for (var o = 0, u = r.length; o < u; o++) e.setRule(n({
            name: t
          }, r[o]))
      }, o.add("Point", [u, {
        rule: function(e) {
          return i(e, "icon")
        }
      }, {
        key: a,
        rule: function(e) {
          return r(e, "icon")
        }
      }]), e(o)
    });
  }],
  ['$B', function(ym) {
    ym.modules.define("GeoObjectArray", [], function(e) {
      function o() {
        throw new Error("Класс GeoObjectArray не поддерживается (соответствующая функциональность доступна в GeoObjectCollection)")
      }
      e(o)
    });
  }],
  ['4k', function(ym) {
    ym.modules.define("GeoObjectCollection", ["util.defineClass", "geoObject.abstract.Sequence", "event.globalize", "component.array.ParentArray", "event.Mapper", "geoObject.EventMappingTable", "Event"], function(e, t, n, o, i, c, l, s) {
      function r(e, t) {
        r.superclass.constructor.call(this, e, t), this.events.addController(h), this.events.fire("create", new s({
          type: "create",
          target: this
        }))
      }
      var h = o(r);
      t(r, n, {
        set: function(e, t) {
          return this._collectionComponent.set(e, t), this
        },
        add: function(e, t) {
          return this._collectionComponent.add(e, t), this
        },
        remove: function(e) {
          if (ym.env.debug && this._collectionComponent.indexOf(e) == -1) throw new Error("GeoObjectCollection.remove: удаляемый объект не найден");
          return this._collectionComponent.remove(e), this
        },
        removeAll: function() {
          return this._collectionComponent.removeAll(), this
        },
        splice: function(e, t) {
          return new r({
            children: this._collectionComponent.splice.apply(this._collectionComponent, arguments)
          })
        },
        createCollectionComponent: function(e) {
          return this._collectionComponent = new i(e, this, {
            onAdd: {
              callback: this._onAdd,
              context: this
            },
            onRemove: {
              callback: this._onRemove,
              context: this
            },
            onSet: {
              callback: this._onSet,
              context: this
            }
          }, new c(this.events, new l(this)))
        },
        _onAdd: function(e, t) {
          this.events.fire("add", new s({
            type: "add",
            target: this,
            index: e,
            child: t
          }))
        },
        _onRemove: function(e, t) {
          this.events.fire("remove", new s({
            type: "remove",
            target: this,
            index: e,
            child: t
          }))
        },
        _onSet: function(e, t, n) {
          this.events.fire("set", new s({
            type: "set",
            target: this,
            index: e,
            prevChild: t,
            child: n
          }))
        }
      }), e(r)
    });
  }],
  ['0M', function(ym) {
    ym.modules.define("geoQuery", ["GeoQueryResult", "yandex.counter"], function(e, u, n) {
      function o(e) {
        return n.countByKey("modulesUsage", "geoQuery"), new u(e)
      }
      e(o)
    });
  }],
  ['4C', function(ym) {
    ym.modules.define("GeoQueryResult", ["util.extend", "util.List", "vow", "util.ArrayIterator", "Clusterer", "util.array", "util.bounds", "geoQueryResult.component.search", "geoQueryResult.component.contain", "geoQueryResult.component.distance", "geoQueryResult.component.intersect", "geoQueryResult.component.util", "geoQueryResult.component.geometryPicker", "GeoObject"], function(provide, extend, List, vow, ArrayIterator, Clusterer, utilArray, utilBounds, searchComponent, containComponent, distanceComponent, intersectComponent, utilComponent, geometryPicker, GeoObject) {
      var getFieldValue = utilComponent.getFieldValue,
        notReadyError = "данные запроса еще обрабатываются. Вызовите метод в функции-обработчике метода then.",
        GeoQueryResult = function(e, t) {
          if (this._parent = t || null, this._objects = [], this._map = null, this._cachedBounds = null, this._lastPromise = vow.resolve(), this._resultReady = !0, e) {
            var r = this._isPromise(e),
              o = this._isGeoQuery(e) && !e.isReady();
            if (r || o) {
              this._resultReady = !1;
              var n = vow.defer();
              e.then(function(t) {
                this._objects = this._getObjects(o ? e : t.geoObjects ? t.geoObjects : t), this._resultReady = !0, n.resolve()
              }, function() {
                n.reject()
              }, this), this._lastPromise = n.promise()
            } else this._objects = this._getObjects(e)
          }
        };
      GeoQueryResult.prototype = {
        getIterator: function() {
          if (ym.env.debug && !this._resultReady) throw new Error("GeoQueryResult.getIterator: " + notReadyError);
          return new ArrayIterator(this._objects)
        },
        getParent: function() {
          return this._parent
        },
        add: function(e) {
          return this._createNewResultWhenReady(function(t) {
            var r = this._isPromise(e),
              o = this._isGeoQuery(e) && !e.isReady();
            if (r || o) return t || (t = vow.defer()), e.then(function(r) {
              var n = this._getObjects(o ? e : r.geoObjects ? r.geoObjects : r);
              t.resolve([].concat(this._objects, n))
            }, function() {
              t.reject()
            }, this), t.promise();
            var n = this._getObjects(e);
            return [].concat(this._objects, n)
          }, this)
        },
        remove: function(e) {
          return this._createNewResultWhenReady(function(t) {
            var r = this._isPromise(e),
              o = this._isGeoQuery(e) && !e.isReady();
            if (r || o) return t || (t = vow.defer()), e.then(function(r) {
              var n = this._removeObjects(this._objects, o ? e : r.geoObjects ? r.geoObjects : r);
              t.resolve(n)
            }, function() {
              t.reject()
            }, this), t.promise();
            var n = this._removeObjects(this._objects, e);
            return t ? (t.resolve(n), t.promise()) : n
          }, this)
        },
        getLength: function() {
          if (ym.env.debug && !this._resultReady) throw new Error("GeoQueryResult.getLength: " + notReadyError);
          return this._objects.length
        },
        then: function(e, t, r) {
          return this._lastPromise.then(e, t, r), this
        },
        isReady: function() {
          return this._resultReady
        },
        addToMap: function(e) {
          return this._callMethod(function() {
            for (var t = e.geoObjects, r = 0, o = this._objects.length; r < o; r++) this._objects[r].getMap() != e && t.add(this._objects[r])
          }, arguments), this
        },
        removeFromMap: function(e) {
          return this._callMethod(function() {
            for (var t = e.geoObjects, r = 0, o = this._objects.length; r < o; r++) this._objects[r].getMap() == e && t.remove(this._objects[r])
          }, arguments), this
        },
        addTo: function(e) {
          return this._callMethod(function() {
            for (var t = 0, r = this._objects.length; t < r; t++) e.add(this._objects[t])
          }, arguments), this
        },
        removeFrom: function(e) {
          return this._callMethod(function() {
            for (var t = 0, r = this._objects.length; t < r; t++) e.remove(this._objects[t])
          }, arguments), this
        },
        getBounds: function() {
          if (ym.env.debug && !this._resultReady) throw new Error("GeoQueryResult.getBounds: " + notReadyError);
          return this._cachedBounds || (this._cachedBounds = this._calculateBounds()), this._cachedBounds
        },
        getGlobalPixelBounds: function(e) {
          if (ym.env.debug && !this._resultReady) throw new Error("GeoQueryResult.getGlobalPixelBounds: " + notReadyError);
          return utilBounds.toGlobalPixelBounds(this.getBounds(), e.getZoom(), e.options.get("projection"))
        },
        getGlobalPixelCenter: function(e) {
          if (ym.env.debug && !this._resultReady) throw new Error("GeoQueryResult.getGlobalPixelCenter: " + notReadyError);
          var t = this.getGlobalPixelBounds(e);
          return [(t[0][0] + t[1][0]) / 2, (t[0][1] + t[1][1]) / 2]
        },
        getCenter: function(e) {
          if (ym.env.debug && !this._resultReady) throw new Error("GeoQueryResult.getCenter: " + notReadyError);
          var t = this.getGlobalPixelCenter(e);
          return e.options.get("projection").fromGlobalPixels(t, e.getZoom())
        },
        getMaxZoom: function(e, t) {
          if (ym.env.debug && !this._resultReady) throw new Error("GeoQueryResult.getMaxZoom: " + notReadyError);
          var r = {
            inscribe: !0,
            preciseZoom: !0
          };
          t && t.hasOwnProperty("useMapMargin") && !t.useMapMargin || (r.margin = e.margin.getMargin());
          var o = utilBounds.getCenterAndZoom(this.getBounds(), e.container.getSize(), e.options.get("projection"), r);
          return o.zoom
        },
        applyBoundsToMap: function(e, t) {
          t = extend({
            useMapMargin: !0
          }, t);
          var r = vow.defer(),
            o = function() {
              var o = this.getBounds();
              o && (this._resultReady = !1, e.setBounds(o, t).then(function(e) {
                this._resultReady = !0, e ? r.reject(e) : r.resolve()
              }, this))
            };
          return this._resultReady ? o.call(this) : this.then(o, this), this._lastPromise = r.promise(), this
        },
        slice: function(e, t) {
          return this._createNewResultWhenReady(function(r) {
            var o = this._objects.slice(e, t);
            return r ? (r.resolve(o), r.promise()) : o
          }, this)
        },
        reverse: function() {
          return this._createNewResultWhenReady(function(e) {
            var t = this._objects.slice(0).reverse();
            return e ? (e.resolve(t), e.promise()) : t
          }, this)
        },
        intersect: function(e) {
          if (e.isReady() && this.isReady()) return new GeoQueryResult(this._getIntersection(e), this);
          var t = vow.defer();
          return e.then(function() {
            this.then(function() {
              t.resolve({
                geoObjects: this._getIntersection(e)
              })
            }, function() {
              t.reject()
            }, this)
          }, function() {
            t.reject()
          }, this), new GeoQueryResult(t.promise(), this)
        },
        clusterize: function(e) {
          var t = new Clusterer(e);
          return this._callMethod(function() {
            for (var e = [], r = 0, o = this._objects.length; r < o; r++) "Point" == this._objects[r].geometry.getType() && e.push(this._objects[r]);
            t.add(e)
          }), t
        },
        get: function(e) {
          if (ym.env.debug && !this._resultReady) throw new Error("GeoQueryResult.get: " + notReadyError);
          return this._objects[e]
        },
        indexOf: function(e) {
          if (ym.env.debug && !this._resultReady) throw new Error("GeoQueryResult.indexOf: " + notReadyError);
          return utilArray.indexOf(this._objects, e)
        },
        each: function(e, t) {
          return this._callMethod(function() {
            utilArray.each(this._objects, e, t)
          }), this
        },
        map: function(e, t) {
          return this._createNewResultWhenReady(function(r) {
            var o = utilArray.map(this._objects, e, t);
            return r ? (r.resolve(o), r.promise()) : o
          }, this)
        },
        addEvents: function(e, t, r) {
          return this._callMethod(function() {
            for (var o = 0, n = this._objects.length; o < n; o++) this._objects[o].events.add(e, t, r)
          }), this
        },
        removeEvents: function(e, t, r) {
          return this._callMethod(function() {
            for (var o = 0, n = this._objects.length; o < n; o++) this._objects[o].events.remove(e, t, r)
          }), this
        },
        setProperties: function(e, t) {
          return this._callMethod(function() {
            for (var r = 0, o = this._objects.length; r < o; r++) this._objects[r].properties.set(e, t)
          }), this
        },
        unsetProperties: function(e) {
          return this._callMethod(function() {
            for (var t = 0, r = this._objects.length; t < r; t++) this._objects[t].properties.unset(e)
          }), this
        },
        setOptions: function(e, t) {
          return this._callMethod(function() {
            for (var r = 0, o = this._objects.length; r < o; r++) this._objects[r].options.set(e, t)
          }), this
        },
        unsetOptions: function(e) {
          return this._callMethod(function() {
            for (var t = 0, r = this._objects.length; t < r; t++) this._objects[t].options.unset(e)
          }), this
        },
        getCentralObject: function(e) {
          if (ym.env.debug && !this._resultReady) throw new Error("GeoQueryResult.getCentralObject: " + notReadyError);
          return distanceComponent.getCentralObject(this, e)
        },
        getExtreme: function(e) {
          if (ym.env.debug && !this._resultReady) throw new Error("GeoQueryResult.getExtreme: " + notReadyError);
          return distanceComponent.getExtreme(this, e)
        },
        getExtremeObject: function(e) {
          if (ym.env.debug && !this._resultReady) throw new Error("GeoQueryResult.getExtremeObject: " + notReadyError);
          return distanceComponent.getExtremeObject(this, e)
        },
        getClosestTo: function(e) {
          if (ym.env.debug && !this._resultReady) throw new Error("GeoQueryResult.getClosestTo: " + notReadyError);
          return distanceComponent.getClosestTo(this, e)
        },
        search: function(e) {
          return this._createNewResultWhenReady(function(t) {
            var r = searchComponent(this, e);
            return t ? (t.resolve(r), t.promise()) : r
          }, this)
        },
        searchInside: function(e) {
          var t = geometryPicker(e);
          return this._createNewResultWhenReady(function(e) {
            var r = searchComponent(this, function(e) {
              return t != e.geometry && containComponent(t, e.geometry)
            });
            return e ? (e.resolve(r), e.promise()) : r
          }, this)
        },
        searchContaining: function(e) {
          var t = geometryPicker(e);
          return this._createNewResultWhenReady(function(e) {
            var r = searchComponent(this, function(e) {
              return t != e.geometry && containComponent(e.geometry, t)
            });
            return e ? (e.resolve(r), e.promise()) : r
          }, this)
        },
        searchIntersect: function(e, t) {
          t = extend({
            considerOccurance: !0
          }, t);
          var r = geometryPicker(e);
          return this._createNewResultWhenReady(function(e) {
            var o = searchComponent(this, function(e) {
              return r != e.geometry && intersectComponent(e.geometry, r, t)
            });
            return e ? (e.resolve(o), e.promise()) : o
          }, this)
        },
        sort: function(e) {
          var t;
          if ("string" == typeof e) {
            var r = e.split(" "),
              o = r[0],
              n = r[1] ? r[1] : "asc";
            t = function(e, t) {
              return "asc" == n ? getFieldValue(e, o) < getFieldValue(t, o) ? -1 : 1 : getFieldValue(t, o) < getFieldValue(e, o) ? -1 : 1
            }
          } else t = e;
          return this._createNewResultWhenReady(function(e) {
            var r = this._objects.concat(),
              o = r.sort(t);
            return e ? (e.resolve(o), e.promise()) : o
          }, this)
        },
        sortByDistance: function(e) {
          var t = geometryPicker(e),
            r = function(e, r) {
              return distanceComponent.getDistance(e.geometry, t) - distanceComponent.getDistance(r.geometry, t)
            };
          return this._createNewResultWhenReady(function(e) {
            var t = this._objects.concat(),
              o = t.sort(r);
            return e ? (e.resolve(o), e.promise()) : o
          }, this)
        },
        _callMethod: function(e, t) {
          var r = vow.defer();
          this._resultReady ? (e.apply(this, t || []), r.resolve()) : (this.then(function() {
            e.apply(this, t || []), r.resolve()
          }, function() {
            r.reject()
          }, this), this._lastPromise = r.promise())
        },
        _createNewResultWhenReady: function(e, t) {
          if (this._resultReady) return new GeoQueryResult(e.call(t), this);
          var r = vow.defer();
          return this.then(function() {
            r.resolve(e.call(t))
          }, function() {
            r.reject()
          }, this), new GeoQueryResult(r.promise(), this)
        },
        _calculateBounds: function() {
          if (this._objects.length) {
            for (var e = this._objects[0].getMap(), t = e ? e.options.get("projection") : null, r = [], o = 0, n = this._objects.length; o < n; o++) {
              var s = this._objects[o].geometry.getBounds();
              r.push(s[0], s[1])
            }
            return 0 == r.length ? null : utilBounds.fromPoints(r, t)
          }
          return null
        },
        _getObjects: function(e) {
          var t = [];
          if (this._isGeoQuery(e))
            for (var r, o = e.getIterator();
              (r = o.getNext()) != o.STOP_ITERATION;) t.push(r);
          else if (this._isJson(e)) t = this._createObjectsFromJson(e);
          else
            for (var n = [].concat(e), s = 0, i = n.length; s < i; s++) {
              var u = n[s];
              if (this._isJsonGeometry(u) && t.push(new GeoObject({
                  geometry: u
                })), this._isGeoObject(u) && t.push(u), this._isCollection(u))
                for (var r, o = u.getIterator();
                  (r = o.getNext()) != o.STOP_ITERATION;) t = t.concat(this._getObjects(r))
            }
          return t
        },
        _removeObjects: function(e, t) {
          var r = [];
          if (this._isGeoQuery(t))
            for (var o, n = t.getIterator();
              (o = n.getNext()) != n.STOP_ITERATION;) r.push(o);
          else r = [].concat(t);
          return r.length ? (this._cachedBounds = null, "number" == typeof r[0] ? this._removeByIndexes(e, r) : this._removeByValues(e, r)) : this._objects
        },
        _removeByIndexes: function(e, t) {
          t.sort();
          for (var r = 0, o = 0, n = []; r < e.length;) r < t[o] || o == t.length ? (n.push(e[r]), r++) : r > t[o] ? o++ : (r++, o++);
          return n
        },
        _removeByValues: function(e, t) {
          for (var r = [], o = 0, n = e.length; o < n; o++) {
            for (var s = !0, i = 0, u = t.length; i < u && s; i++) t[i] == e[o] && (s = !1);
            s && r.push(e[o])
          }
          return r
        },
        _getIntersection: function(e) {
          for (var t = e.getIterator(), r = [], o = [];
            (r = t.getNext()) != t.STOP_ITERATION;) o.push(r);
          for (var e = [], n = 0, s = this._objects.length; n < s; n++)
            for (var i = !0, u = 0, c = o.length; u < c && i; u++) o[u] == this._objects[n] && (e.push(this._objects[n]), i = !1);
          return e
        },
        _createObjectsFromJson: function(json) {
          return "string" == typeof json && (json = !/[^,:{}\[\]0-9.\-+Eaeflnr-u \n\r\t]/.test(json.replace(/"(\\.|[^"\\])*"/g, "")) && eval("(" + json + ")")), json ? "Feature" == json.type ? [this._createObjectFromJsonFeature(json)] : this._createObjectsFromJsonFeatureCollection(json) : []
        },
        _createObjectsFromJsonFeatureCollection: function(e) {
          for (var t = [], r = 0, o = e.features.length; r < o; r++) "Feature" == e.features[r].type ? t.push(this._createObjectFromJsonFeature(e.features[r])) : t = t.concat(this._createObjectsFromJsonFeatureCollection(e.features[r]));
          return t
        },
        _createObjectFromJsonFeature: function(e) {
          return new GeoObject({
            geometry: e.geometry,
            properties: e.properties
          }, e.options)
        },
        _isJsonGeometry: function(e) {
          return !(!e.type || !e.coordinates)
        },
        _isGeoObject: function(e) {
          return !!e.geometry
        },
        _isCollection: function(e) {
          return !!e.getIterator
        },
        _isPromise: function(e) {
          return !!e.then && !e.getIterator
        },
        _isGeoQuery: function(e) {
          return !!e.then && !!e.getIterator
        },
        _isJson: function(e) {
          return "string" == typeof e || "Feature" == e.type || "FeatureCollection" == e.type
        }
      }, provide(GeoQueryResult)
    });
  }],
  [',s', function(ym) {
    ym.modules.define("geoQueryResult.component.contain", ["projection.wgs84Mercator", "util.bounds", "coordSystem.geo", "geometry.component.pointInPolygon", "util.math.calculateLineIntersection"], function(e, t, n, r, o, i) {
      function a(e, t) {
        switch (e.getType()) {
          case "Point":
            var n = e.getCoordinates(),
              r = t.getCoordinates();
            return n[0] == r[0] && n[1] == r[1];
          case "LineString":
            return e.getClosest(t.getCoordinates()).distance < u;
          case "Polygon":
          case "Rectangle":
          case "Circle":
          case "LinearRing":
            return e.contains(t.getCoordinates());
          default:
            return !1
        }
      }

      function s(e, t) {
        if (!e.contains) return !1;
        if (!e.contains(t[0])) return !1;
        switch (e.getType()) {
          case "Circle":
          case "Rectangle":
            for (var n = 1, r = t.length; n < r; n++)
              if (!e.contains(t[n])) return !1;
            return !0;
          case "LinearRing":
            return c(e.getCoordinates(), t);
          case "Polygon":
            for (var o = e.getCoordinates(), n = 0, r = o.length; n < r; n++)
              if (!c(o[n], t)) return !1;
            return !0;
          default:
            return !1
        }
      }

      function c(e, t) {
        for (var n = 1, r = e.length; n < r; n++)
          for (var a = 1, s = t.length; a < s; a++) {
            var c = i(e[n], e[n - 1], t[a], t[a - 1]);
            if (c) {
              if (!(c.b < u || 1 - c.b < u)) return !1;
              var g = [(t[a][0] + t[a - 1][0]) / 2, (t[a][1] + t[a - 1][1]) / 2];
              if (!o(g, [e])) return !1
            }
          }
        return !0
      }

      function g(e) {
        var t = e.getCoordinates();
        return [t[0],
          [t[0][0], t[1][1]], t[1],
          [t[1][0], t[0][1]], t[0]
        ]
      }
      var u = .01,
        f = function(e, o) {
          var i = e.options.get("projection") || o.options.get("projection");
          if ("Point" != e.getType() && "Point" != o.getType() && !n.areIntersecting(e.getBounds(), o.getBounds(), i || t)) return !1;
          switch (o.getType()) {
            case "Point":
              return a(e, o);
            case "LineString":
            case "LinearRing":
              return s(e, o.getCoordinates());
            case "Rectangle":
              if (!e.contains) return !1;
              for (var c = g(o), u = 0, f = c.length; u < f; u++)
                if (!e.contains(c[u])) return !1;
              return !0;
            case "Polygon":
              if (!e.contains) return !1;
              for (var c = o.getCoordinates(), u = 0, f = c.length; u < f; u++)
                if (!s(e, c[u])) return !1;
              return !0;
            case "Circle":
              if (!e.contains || !e.contains(o.getCenter())) return !1;
              var l = e.getClosest(o.getCenter()),
                i = o.options.get("projection"),
                d = i ? i.getCoordSystem() : r,
                C = d.getDistance(l.position, o.getCenter());
              return C >= o.getRadius();
            default:
              return !1
          }
        };
      e(f)
    });
  }],
  [',t', function(ym) {
    ym.modules.define("geoQueryResult.component.distance", ["util.bind", "util.vector", "util.math.calculateLineIntersection", "util.array", "geometry.component.findClosestPathPosition", "geoQueryResult.component.geometryPicker", "coordSystem.geo", "geometry.LineString"], function(e, t, n, r, o, s, i, a, u) {
      function c(e, t) {
        switch (t.getType()) {
          case "Point":
            return y(e, t.getCoordinates(), t.options.get("projection"));
          case "Circle":
          case "Polygon":
          case "Rectangle":
            return t.contains(e) ? 0 : t.getClosest(e).distance;
          case "LineString":
            return t.getClosest(e).distance;
          default:
            return null
        }
      }

      function g(e, t) {
        var n = c(e.getCenter(), t),
          r = e.getRadius();
        return n <= r ? 0 : n - r
      }

      function l(e, t) {
        var n = e.getCoordinates(),
          r = new u(n[0]);
        r.options.setParent(e.options), r.setMap(e.getMap());
        for (var o = d(r, t), s = 1, i = n.length; s < i; s++) {
          r.setCoordinates(n[1]);
          var a = d(r, t);
          a < o && (o = a)
        }
        return o
      }

      function f(e, t) {
        var n = e.getCoordinates(),
          r = new u([n[0],
            [n[0][0], n[1][1]], n[1],
            [n[1][0], n[0][1]], n[0]
          ]);
        return r.options.setParent(e.options), r.setMap(e.getMap()), d(r, t)
      }

      function d(e, t) {
        switch (t.getType()) {
          case "Point":
            return c(t.getCoordinates(), e);
          case "Circle":
            return g(t, e);
          case "Polygon":
            return l(t, e);
          case "Rectangle":
          case "LineString":
            var n = m(e.getPixelGeometry().getCoordinates(), p(t)),
              r = t.options.get("projection") || e.options.get("projection"),
              o = t.getMap() || e.getMap();
            return y(r.fromGlobalPixels(n[0], o.getZoom()), r.fromGlobalPixels(n[1], o.getZoom()), r);
          default:
            return null
        }
      }

      function m(e, t) {
        for (var n = b(t, e[0]), r = n.distance, o = [n.position, e[0]], s = 1, i = e.length; s < i; s++) n = b(t, e[s]), n.distance < r && (r = n.distance, o = [n.position, e[s]]);
        for (var s = 0, i = t.length; s < i; s++) n = b(e, t[s]), n.distance < r && (r = n.distance, o = [n.position, t[s]]);
        return o
      }

      function y(e, t, n) {
        var r = n ? n.getCoordSystem() : a;
        return r.getDistance(e, t)
      }

      function p(e) {
        var t = e.getPixelGeometry(),
          n = t.getCoordinates();
        return "Rectangle" == t.getType() && (n = [n[0],
          [n[0][0], n[1][1]], n[1],
          [n[1][0], n[0][1]], n[0]
        ]), n
      }
      var h, C, b = s;
      o.isArray;
      "latlong" == ym.env.coordinatesOrder ? (h = 0, C = 1) : (h = 1, C = 0);
      var v = {
        getCentralObject: function(e, t) {
          if (!e.getLength()) return null;
          var n = t.getCenter(),
            r = function(e) {
              return c(n, e.geometry)
            };
          return this._getClosestObject(e, r)
        },
        getExtreme: function(e, t) {
          var n = e.getBounds();
          switch (t) {
            case "top":
              return n[1][h];
            case "right":
              return n[1][C];
            case "bottom":
              return n[0][h];
            case "left":
              return n[0][C];
            default:
              throw new Error("geoQueryResult.getExtreme: неверное значение ключа.")
          }
        },
        getExtremeObject: function(e, t) {
          if (!e.getLength()) return null;
          var n, r = e.getBounds();
          switch (t) {
            case "top":
              n = function(e) {
                return Math.abs(r[1][h] - e.geometry.getBounds()[1][h])
              };
              break;
            case "right":
              n = function(e) {
                return Math.abs(r[1][C] - e.geometry.getBounds()[1][C])
              };
              break;
            case "bottom":
              n = function(e) {
                return Math.abs(r[0][h] - e.geometry.getBounds()[0][h])
              };
              break;
            case "left":
              n = function(e) {
                return Math.abs(r[0][C] - e.geometry.getBounds()[0][C])
              };
              break;
            default:
              throw new Error("geoQueryResult.getExtremeObject: неверное значение ключа.")
          }
          return this._getClosestObject(e, n)
        },
        getClosestTo: function(e, n) {
          var r = i(n),
            o = t(function(e) {
              return r == e.geometry ? -1 : this.getDistance(r, e.geometry)
            }, this);
          return this._getClosestObject(e, o)
        },
        getDistance: function(e, t) {
          switch (e.getType()) {
            case "Point":
              return c(e.getCoordinates(), t);
            case "Circle":
              return g(e, t);
            case "Polygon":
              return l(e, t);
            case "LineString":
              return d(e, t);
            case "Rectangle":
              return f(e, t);
            default:
              return null
          }
        },
        _getClosestObject: function(e, t) {
          if (!e.getLength()) return null;
          for (var n, r = e.getIterator(), o = r.getNext(), s = t(o);
            (n = r.getNext()) != r.STOP_ITERATION;) {
            var i = t(n);
            i != -1 && (s == -1 || i < s) && (s = i, o = n)
          }
          return s > -1 ? o : null
        }
      };
      e(v)
    });
  }],
  [',u', function(ym) {
    ym.modules.define("geoQueryResult.component.geometryPicker", ["geometry.Circle", "geometry.Rectangle", "geometry.LineString", "geometry.Polygon", "geometry.Point", "util.array", "geoObject.geometryFactory"], function(e, t, o, r, n, y, g, i) {
      e(function(e) {
        if (e.getZoom) {
          var t = new o(e.getBounds(), {
            coordRendering: "boundsPath"
          });
          return t.options.setParent(e.options), t.setMap(e), t
        }
        return e.geometry ? e.geometry : "function" == typeof e.getType ? e : g.isArray(e) ? g.isArray(e[0]) ? new o(e) : new y(e) : i.createGeometry(e)
      })
    });
  }],
  [',v', function(ym) {
    ym.modules.define("geoQueryResult.component.intersect", ["projection.wgs84Mercator", "coordSystem.geo", "util.bounds", "util.math.calculateLineIntersection", "geoQueryResult.component.distance", "geoQueryResult.component.contain"], function(e, t, r, n, o, c, i) {
      function a(e, t, r) {
        switch (t.getType()) {
          case "Point":
            var n = e.getCoordinates(),
              o = t.getCoordinates();
            return n[0] == o[0] && n[1] == o[1];
          case "LineString":
            return t.getClosest(e.getCoordinates()).distance < x;
          case "LinearRing":
          case "Rectangle":
          case "Polygon":
            return !(!r.considerOccurance || !i(t, e)) || t.getClosest(e.getCoordinates()).distance < x;
          case "Circle":
            return d(t, e, r);
          default:
            return !1
        }
      }

      function s(e, t, r) {
        switch (t.getType()) {
          case "Point":
            return a(t, e, r);
          case "LineString":
          case "LinearRing":
            return y(e.getPixelGeometry().getCoordinates(), t.getPixelGeometry().getCoordinates());
          case "Circle":
            return d(t, e, r);
          case "Polygon":
            return !(!r.considerOccurance || !i(t, e)) || C(t.getPixelGeometry(), e.getPixelGeometry().getCoordinates());
          case "Rectangle":
            return !(!r.considerOccurance || !i(t, e)) || y(e.getPixelGeometry().getCoordinates(), f(t));
          default:
            return !1
        }
      }

      function g(e, t, r) {
        switch (t.getType()) {
          case "Point":
            return a(t, e, r);
          case "LineString":
            return !(!r.considerOccurance || !i(e, t)) || y(t.getPixelGeometry().getCoordinates(), e.getPixelGeometry().getCoordinates());
          case "LinearRing":
            return !(!r.considerOccurance || !i(e, t) && !i(t, e)) || y(t.getPixelGeometry().getCoordinates(), e.getPixelGeometry().getCoordinates());
          case "Circle":
            return d(t, e, r);
          case "Polygon":
            return !(!r.considerOccurance || !i(e, t) && !i(t, e)) || C(t.getPixelGeometry(), e.getPixelGeometry().getCoordinates());
          case "Rectangle":
            return !(!r.considerOccurance || !i(e, t) && !i(t, e)) || y(e.getPixelGeometry().getCoordinates(), f(t));
          default:
            return !1
        }
      }

      function u(e, t, r) {
        switch (t.getType()) {
          case "Point":
            return a(t, e, r);
          case "LineString":
            return !(!r.considerOccurance || !i(e, t)) || y(t.getPixelGeometry().getCoordinates(), f(e));
          case "LinearRing":
            return !(!r.considerOccurance || !i(e, t) && !i(t, e)) || y(t.getPixelGeometry().getCoordinates(), f(e));
          case "Circle":
            return d(t, e, r);
          case "Polygon":
            return !(!r.considerOccurance || !i(e, t) && !i(t, e)) || C(t.getPixelGeometry(), f(e));
          case "Rectangle":
            return !(!r.considerOccurance || !i(e, t) && !i(t, e)) || y(f(t), f(e));
          default:
            return !1
        }
      }

      function l(e, t, r) {
        switch (t.getType()) {
          case "Point":
            return a(t, e, r);
          case "LineString":
            return !(!r.considerOccurance || !i(e, t)) || C(e.getPixelGeometry(), t.getPixelGeometry().getCoordinates());
          case "LinearRing":
            return !(!r.considerOccurance || !i(e, t) && !i(t, e)) || C(e.getPixelGeometry(), t.getPixelGeometry().getCoordinates());
          case "Circle":
            return d(t, e, r);
          case "Polygon":
            if (r.considerOccurance && (i(e, t) || i(t, e))) return !0;
            for (var n = t.getPixelGeometry().getCoordinates(), o = 0, c = n.length; o < c; o++)
              if (C(e.getPixelGeometry(), n[o])) return !0;
            return !1;
          case "Rectangle":
            return !(!r.considerOccurance || !i(e, t) && !i(t, e)) || C(e.getPixelGeometry(), f(t));
          default:
            return !1
        }
      }

      function d(e, t, n) {
        switch (t.getType()) {
          case "Point":
            var o = e.options.get("projection") || t.options.get("projection"),
              c = o ? o.getCoordSystem() : r,
              a = c.getDistance(e.getCoordinates(), t.getCoordinates()),
              s = e.getRadius();
            return n.considerOccurance ? a <= s : Math.abs(a - s) < x;
          case "LineString":
            var g = i(e, t);
            return g ? !!n.considerOccurance : G(t, e) < x;
          case "LinearRing":
          case "Rectangle":
          case "Polygon":
            var g = i(e, t) || i(t, e);
            return g ? !!n.considerOccurance : G(t, e) < x;
          case "Circle":
            return P(e, t, n);
          default:
            return !1
        }
      }

      function y(e, t) {
        for (var r = 1, n = e.length; r < n; r++)
          for (var c = 1, i = t.length; c < i; c++)
            if (o(e[r], e[r - 1], t[c], t[c - 1])) return !0;
        return !1
      }

      function P(e, t, n) {
        var o = e.options.get("projection") || t.options.get("projection"),
          c = o ? o.getCoordSystem() : r,
          i = c.getDistance(e.getCenter(), t.getCenter()),
          a = e.getRadius(),
          s = t.getRadius(),
          g = Math.abs(a - s) >= i;
        return g ? !!n.considerOccurance : i <= a + s
      }

      function C(e, t) {
        for (var r = e.getCoordinates(), n = 0, o = r.length; n < o; n++)
          if (y(r[n], t)) return !0;
        return !1
      }

      function f(e) {
        var t = e.getPixelGeometry(),
          r = t.getCoordinates();
        return "Rectangle" == t.getType() && (r = m(r)), r
      }

      function m(e) {
        return [e[0],
          [e[0][0], e[1][1]], e[1],
          [e[1][0], e[0][1]], e[0]
        ]
      }

      function p(e) {
        return [
          [e[0][0] - x, e[0][1] - x],
          [e[1][0] + x, e[1][1] + x]
        ]
      }
      var x = .001,
        G = c.getDistance,
        R = function(e, r, o) {
          if (o = o || {}, "Point" != e.getType() && "Point" != r.getType()) {
            var c = e.options.get("projection") || r.options.get("projection");
            if (!n.areIntersecting(p(e.getBounds()), p(r.getBounds()), c || t)) return !1
          }
          switch (e.getType()) {
            case "Point":
              return a(e, r, o);
            case "LineString":
              return s(e, r, o);
            case "LinearRing":
              return g(e, r, o);
            case "Rectangle":
              return u(e, r, o);
            case "Polygon":
              return l(e, r, o);
            case "Circle":
              return d(e, r, o);
            default:
              return !1
          }
        };
      e(R)
    });
  }],
  [',w', function(ym) {
    ym.modules.define("geoQueryResult.component.search", ["geoQueryResult.component.util"], function(e, n) {
      function u(e) {
        var n = e.match(/^([\w.]*)\s*(<|<\=|\=|\=\=|\!\=|>\=|>|rlike|regexp)\s*([\w.]*|".*"|'.*')$/i),
          u = n[1],
          r = l[n[2].toLowerCase()],
          o = n[3];
        return o = '"' == o.charAt(0) || "'" == o.charAt(0) ? o.slice(1, o.length - 1) : i[o] ? i[o].value : Number(o),
          function(e) {
            return r(t(e, u), o)
          }
      }
      var t = n.getFieldValue,
        r = function(e, n) {
          for (var t = "string" == typeof n ? u(n) : n, r = [], l = e.getIterator(), o = 0, i = l.getNext(); i != l.STOP_ITERATION;) t(i, o, this) && r.push(i), i = l.getNext(), o++;
          return r
        },
        l = {
          "<": function(e, n) {
            return null != e && null != n && e < n
          },
          "<=": function(e, n) {
            return null != e && null != n && e <= n
          },
          "==": function(e, n) {
            return e == n
          },
          "!=": function(e, n) {
            return e != n
          },
          ">=": function(e, n) {
            return null != e && null != n && e >= n
          },
          ">": function(e, n) {
            return null != e && null != n && e > n
          },
          regexp: function(e, n) {
            return e && e.match && null != e.match(new RegExp(n))
          }
        };
      l["="] = l["=="], l.rlike = l.regexp;
      var o, i = {
        "true": {
          value: !0
        },
        "false": {
          value: !1
        },
        "null": {
          value: null
        },
        undefined: {
          value: o
        }
      };
      e(r)
    });
  }],
  [',x', function(ym) {
    ym.modules.define("geoQueryResult.component.util", [], function(e) {
      var t = {
          getFieldValue: function(e, t) {
            if (r[t]) return r[t](e);
            var n = t.indexOf("."),
              o = i[t.slice(0, n)],
              g = t.slice(n + 1);
            return o(e, g)
          }
        },
        n = "latlong" == ym.env.coordinatesOrder ? 0 : 1,
        o = 0 == n ? 1 : 0,
        r = {
          lat: function(e) {
            return "Point" == e.geometry.getType() ? e.geometry.getCoordinates()[n] : null
          },
          lng: function(e) {
            return "Point" == e.geometry.getType() ? e.geometry.getCoordinates()[o] : null
          },
          x: function(e) {
            return "Point" == e.geometry.getType() ? e.geometry.getPixelGeometry().getCoordinates()[0] : null
          },
          y: function(e) {
            return "Point" == e.geometry.getType() ? e.geometry.getPixelGeometry().getCoordinates()[1] : null
          }
        },
        i = {
          geometry: function(e, t) {
            var n, o = t.split("."),
              r = o[0];
            if ("type" == r) n = e.geometry.getType();
            else if ("coordinates" == r) {
              n = e.geometry.getCoordinates();
              for (var i = 1; i < o.length; i++) n = n[o[i]]
            }
            return n
          },
          properties: function(e, t) {
            return e.properties.get(t)
          },
          options: function(e, t) {
            return e.options.get(t)
          }
        };
      r["long"] = r.lng, e(t)
    });
  }],
  ['4F', function(ym) {
    ym.modules.define("geoXml.getJson", ["util.jsonp", "vow"], function(e, n, o) {
      function r(e) {
        return n({
          url: s,
          requestParams: {
            url: e,
            key: ym.env.key
          },
          postprocessUrl: function(e) {
            return ym.env.hostConfigQuery ? e + "&" + ym.env.hostConfigQuery : e
          }
        })
      }
      var s = ym.env.hosts.api.services.geoxml + "1.2/geoxml.xml";
      e(r)
    });
  }],
  ['4K', function(ym) {
    ym.modules.define("geoXml.load", ["geoXml.getJson", "geoXml.util", "vow", "yandex.counter"], function(e, o, t, s, n) {
      function a(e) {
        n.countByKey("modulesUsage", "geoXml.load"), e = t.resolveUrl(e, window.location.href);
        var a = s.defer();
        return o(e).then(function(o) {
          var t;
          o.ymaps ? t = ["geoXml.parser.ymapsml.geoObjects", "geoXml.parser.ymapsml.MapState"] : o.gpx ? t = ["geoXml.parser.gpx.geoObjects"] : o.kml && (t = ["geoXml.parser.kml.geoObjects"]), ym.modules.require(t, function(t, s) {
            var n, l, m;
            if (o.ymaps) n = t(o.ymaps, e), o.ymaps.Representation && o.ymaps.Representation.View && (l = new s(o.ymaps.Representation.View));
            else if (o.gpx) n = t(o.gpx);
            else if (o.kml) {
              var r = t(o.kml, e);
              n = r.collection, m = r.wait, m && m.then(function() {
                a.resolve({
                  geoObjects: n
                })
              })
            }
            m || a.resolve({
              geoObjects: n,
              mapState: l
            })
          })
        }, function(e) {
          a.reject(e)
        }), a.promise()
      }
      e(a)
    });
  }],
  ['4M', function(ym) {
    ym.modules.define("geoXml.util", ["option.presetStorage"], function(e, t) {
      var a = {
        checkStyle: function(e) {
          if (e && !t.get(e)) {
            var a = {};
            e.replace(/^default#(?:([a-z]+)(?:Small)?|([a-zA-Z]+))(?:Point|Icon)$/, function(e, n, r) {
              var l = "islands#" + (n || r) + "Icon";
              t.get(l) && (a.preset = l)
            }), t.add(e, a)
          }
        },
        resolveUrl: function(e, t) {
          if (/^https?:\/\//.test(e)) return e;
          for (var a, n = /^((?:[^\/]+):\/\/(?:[^\/]+))(\/(?:.*))$/.exec(t), r = n[1], l = n[2].split("/"), s = e.split("/"), i = l.slice(1, l.length - 1), o = 0, c = s.length; o < c; o++) switch (a = s[o]) {
            case "":
              0 == o ? i = [] : o == c - 1 && i.push(a);
              break;
            case ".":
              break;
            case "..":
              i.pop();
              break;
            default:
              i.push(a)
          }
          return r + "/" + i.join("/")
        }
      };
      e(a)
    });
  }],
  ['0$', function(ym) {
    ym.modules.define("getZoomRange", ["LayerCollection", "layer.storage", "mapType.storage"], function(e, o, n, t) {
      function r(e, r, a) {
        if (ym.env.debug) {
          if ("undefined" == typeof e) throw new Error("getZoomRange: не передан параметр mapType");
          if ("undefined" == typeof r) throw new Error("getZoomRange: не указана точка для определения диапазона масштабирования ll")
        }
        for (var g = t.get(e).getLayers(), i = new o, f = 0, d = g.length; f < d; f++) {
          var l = n.get(g[f]);
          i.add(new l)
        }
        a && i.options.setParent(a.options);
        var m = i.getZoomRange(r);
        return i.options.setParent(null), m
      }
      e(r)
    });
  }],
  ['0)', function(ym) {
    ym.modules.define("graphics.constants", [], function(n) {
      n({
        ZERO: 0,
        ADDING: 1,
        REMOVING: 2,
        ACTIVE: 3
      })
    });
  }],
  ['-_', function(ym) {
    ym.modules.define("graphics.generator.simplify2", [], function(r) {
      function n(r, n, e) {
        if (r.length < 6) return function() {
          return {
            points: r,
            indexes: n
          }
        };
        var i = t(r, e);
        return function(t) {
          for (var e = [], a = [], f = t * t, o = i(f), u = (r[0], 0), d = r.length; u < d; u++)
            if (o[u] >= f || 0 == u || u == d - 1) {
              e.push(r[u]), a.push(n ? n[u] : u)
            }
          return {
            points: e,
            indexes: a
          }
        }
      }

      function t(r, n) {
        function t(f, u, d, s, h) {
          var c = 0;
          if (!d) {
            for (var l = -1, v = [r[u][0] - r[f][0], r[u][1] - r[f][1]], g = 0, x = n.length; g < x; ++g) {
              var y = n[g];
              if (y > f) {
                if (y < u) {
                  l = y, c = a;
                  break
                }
                break
              }
            }
            if (l < 0) {
              if (Math.abs(v[0]) > i || Math.abs(v[1]) > i)
                for (var p = v[0] * v[0] + v[1] * v[1], A = 1 / p, g = f + 1; g < u; ++g) {
                  var w = e(r[g], r[f], r[u], v, A);
                  w > c && (l = g, c = w)
                } else l = Math.round(.5 * (f + u)), c = h;
              o[l] = c
            }
            d = {
              start: f,
              end: u,
              index: l,
              distance: c
            }
          }
          return d.index && d.distance > s && (d.index - f >= 2 && (d.left = t(f, d.index, d.left, s, d.distance)), u - d.index >= 2 && (d.right = t(d.index, u, d.right, s, d.distance))), d
        }
        for (var f = r.length, o = [], u = 0, d = r.length; u < d; ++u) o[u] = 0;
        n || (n = []);
        for (var s = 0, u = 0, d = n.length; u < d; ++u) o[n[u]] = a;
        return function(r) {
          return s = t(0, f - 1, s, r, a), o
        }
      }

      function e(r, n, t, e, i) {
        var a, f = +n[0],
          o = +n[1];
        a = +((r[0] - f) * e[0] + (r[1] - o) * e[1]) * i, a > 1 ? (f = +t[0], o = +t[1]) : a > 0 && (f += +e[0] * a, o += +e[1] * a);
        var u = +r[0] - f,
          d = +r[1] - o;
        return +u * u + d * d
      }
      r(n);
      var i = 1 / Math.pow(2, 22),
        a = 1e5;
      window.Uint8Array ? Uint8Array : Array, window.Float32Array ? Float32Array : Array
    });
  }],
  ['49', function(ym) {
    ym.modules.define("graphics.renderManager", ["graphics.renderManager.pane", "util.Associate"], function(e, r, n) {
      var a = new n(function(e, n) {
        return new r(e, n)
      });
      e({
        getContainer: function(e) {
          var r = e.getMap();
          if (ym.env.debug && !r) throw new Error("graphics.render.sliceshape.manager: передан пустой указатель на контейнер");
          return a.get(e, r)
        }
      })
    });
  }],
  ['4V', function(ym) {
    ym.modules.define("graphics.renderManager.canvasTile", ["util.dom.element", "util.dom.style", "util.pixelBounds", "graphics.renderManager.constants", "graphics.renderManager.functions"], function(e, a, n, t, r, i) {
      function d(e, a, n, t) {
        if (e.length != a.length) return !0;
        for (var r = 0, i = e.length; r < i; ++r)
          if (n[e[r]].id != t[a[r]].id) return !0;
        return !1
      }

      function o(e, a, n) {
        for (var t = 0, r = "x" + a, i = e; t < u && n[i + r]; ++i) t++;
        return t
      }

      function s(e, a, n) {
        for (var t = 1e3, r = 0, i = [0, 0], d = a, s = 0; s < u; ++d, ++s) {
          var l = o(e, d, n);
          if (0 == l) break;
          var g = Math.min(l - 1, t),
            f = g + s;
          r < f && (i = [g, s], r = f), t = g
        }
        return i
      }

      function l(e) {
        var a, n, t, r, i, d, o, l = [],
          g = {};
        for (a = 0, n = e.length; a < n; ++a) g[e[a][0]] = e[a];
        for (a = 0, n = e.length; a < n; ++a) {
          var f = e[a];
          if (g[f[0]]) {
            var h = s(f[1], f[2], g),
              p = [];
            for (t = f[1], i = f[1] + h[0]; t <= i; ++t)
              for (r = f[2], d = f[2] + h[1]; r <= d; ++r) o = t + "x" + r, p.push(g[o]), g[o] = !1;
            l.push({
              dimension: h,
              items: p
            })
          }
        }
        return l
      }

      function g(e, a, n, t, r) {
        e.drawImage(a, r * (n[0] - t[0]), r * (n[1] - t[1]))
      }
      var f, h = {
          element: a,
          style: n
        },
        p = r.tileSize,
        u = r.renderLineLimit,
        m = null,
        c = {
          place: function(e, a) {
            return e.data = e.data || {}, this.process(e, a), e.data = e.newData, e.data.items = e.items, e.data.element
          },
          renderGroup: function(e, a) {
            var n, t, r, i = a.items,
              d = i[0],
              o = [
                [d[1] * p, d[2] * p],
                [(d[1] + a.dimension[0] + 1) * p, (d[2] + a.dimension[1] + 1) * p]
              ],
              s = f,
              l = a.items.length;
            1 == l && (s = e.newData.grid[d[0]].pane);
            var h = [];
            for (r = 0; r < l; ++r) h = h.concat(e.newData.grid[i[r][0]].items || []);
            if (m = e.items, h.sort(this._itemsSort), m = null, s = this.fillTilePane(e, h, s), s.updateClipping(o, !1, 0), s.lockBoundsTo(o), s.flush(), s.removeAll(), n = s.holder(), s.margin) {
              var u = [s.margin.left, s.margin.top],
                c = s.clippingOffset,
                D = [u[0] + c[0], u[1] + c[1]];
              if (1 == l) e.newData.grid[d[0]].pane = s;
              else
                for (f = s, r = 0; r < l; ++r) {
                  var v = e.newData.grid[i[r][0]];
                  t = v.pane = this.fillTilePane(e, v.items, v.pane), t.updateClipping([
                    [i[r][1] * p, i[r][2] * p],
                    [(i[r][1] + 1) * p, (i[r][2] + 1) * p]
                  ], !1, 0), t.lockBoundsTo([
                    [i[r][1] * p, i[r][2] * p],
                    [(i[r][1] + 1) * p, (i[r][2] + 1) * p]
                  ]), t.resize(), t.removeAll(), t.prepareRender();
                  var w = [t.margin.left, t.margin.top],
                    M = t.clippingOffset,
                    x = [w[0] + M[0], w[1] + M[1]],
                    B = t.scaleFactor,
                    P = t.getCanvas();
                  g(P, n, D, x, B)
                }
            }
          },
          fillTilePane: function(e, a, n) {
            for (var t = e.items, r = 0, i = a.length; r < i; r++) {
              var d = t[a[r]].shape.getGraphics();
              n || (n = d.createPane(), n.setPositionPolicy(!1, !0)), d.getPane() != n && n.addShape(d), t[a[r]].changed = 0
            }
            return n
          },
          process: function(e, a) {
            var n = a.getVisibleBounds(0),
              r = [
                [Math.floor(n[0][0] / p), Math.floor(n[0][1] / p)],
                [Math.floor(n[1][0] / p), Math.floor(n[1][1] / p)]
              ];
            e.newData && (t.containsBounds(e.newData.bounds, r) || (e.newData = 0)), e.newData || (e.newData = this.createDataGrid(e.items, r), e.newData.element = e.data.element, e.newData.element || (e.newData.element = h.element.create()));
            var i, o, s, g, f, u = e.data.bounds,
              m = e.newData.bounds,
              c = 0;
            if (e.data.grid)
              for (i = u[0][0]; i < u[1][0]; i++)
                for (o = u[0][1]; o < u[1][1]; o++) f = i + "x" + o, e.data.grid[f] && (!e.newData.grid[f] && e.data.grid[f].pane && h.element.remove(e.data.grid[f].pane.holder()), e.newData.grid[f] && (e.newData.grid[f].pane = e.data.grid[f].pane, e.newData.grid[f].changed += e.data.grid[f].changed, d(e.data.grid[f].items, e.newData.grid[f].items, e.data.items, e.items) && e.newData.grid[f].changed++));
            else e.data.grid = {};
            var D = [],
              v = [];
            if (e.newData.grid) {
              for (i = m[0][0]; i < m[1][0]; i++)
                for (o = m[0][1]; o < m[1][1]; o++) f = i + "x" + o, e.newData.grid[f] && (i >= r[0][0] && i <= r[1][0] && o >= r[0][1] && o <= r[1][1] ? (D.push(f), e.data.grid[f] && !e.newData.grid[f].changed && e.newData.grid[f].pane || (v.push([f, i, o]), e.newData.grid[f].changed = 0, e.newData.grid[f].updated = 1)) : e.newData.grid[f].pane && h.element.remove(e.newData.grid[f].pane.holder()));
              var w = l(v);
              for (s = 0, g = w.length; s < g; ++s) {
                var M = w[s];
                this.renderGroup(e, M), c++
              }
              for (s = 0, g = D.length; s < g; ++s) {
                f = D[s];
                var x = e.newData.grid[f].pane;
                if (x.margin) {
                  var B = a.toClientPixels([x.margin.left, x.margin.top]),
                    P = x.clippingOffset,
                    b = x.holder();
                  e.newData.grid[f].updated = 0, h.style.setPosition(b, [B[0] + P[0], B[1] + P[1]]), b.parentNode != e.newData.element && e.newData.element.appendChild(b)
                }
              }
            }
          },
          createDataGrid: function(e, a) {
            for (var n, r, i, d, o, s, l, g = [], f = {}, h = 2, u = [
                [a[0][0] - h, a[0][1] - h],
                [a[1][0] + h, a[1][1] + h]
              ], m = 0, c = e.length; m < c; ++m)
              if (n = e[m].shape.getGraphics().getBounds(), i = e[m]._canvas_lastBounds, r = t.getIntersection(u, [
                  [Math.floor(n[0][0] / p), Math.floor(n[0][1] / p)],
                  [Math.ceil(n[1][0] / p), Math.ceil(n[1][1] / p)]
                ])) {
                for (g.push(r), l = e[m].changed, e[m]._canvas_lastBounds = r, d = r[0][0]; d < r[1][0]; d++)
                  for (o = r[0][1]; o < r[1][1]; o++) s = d + "x" + o, f[s] = f[s] || {
                    items: [],
                    changed: 0
                  }, f[s].items.push(m), f[s].changed += l;
                if (i)
                  for (d = i[0][0]; d < i[1][0]; d++)
                    for (o = i[0][1]; o < i[1][1]; o++)(d < r[0][0] || d > r[1][0] || o < r[0][1] || o > r[1][1]) && (s = d + "x" + o, f[s] && (f[s].changed += l))
              }
            var D = t.fromBounds(g),
              v = [D[1][0] - D[0][0], D[1][1] - D[0][1]];
            return {
              gridSize: v,
              bounds: D,
              grid: f
            }
          },
          _itemsSort: function(e, a) {
            return -i.zIndexComparison(m[e].shape, m[a].shape)
          }
        };
      e(c)
    });
  }],
  ['4Y', function(ym) {
    ym.modules.define("graphics.renderManager.constants", ["system.browser", "util.hd"], function(e, i, n) {
      var i = ym.env.browser,
        r = i.isMobile || i.isTablet;
      if ("MSIE" == i.name || "IEMobile" == i.name) e({
        tileSize: 256,
        renderLineLimit: 1
      });
      else {
        var t = n.getPixelRatio(),
          s = t > 1 ? 256 : 320;
        e({
          tileSize: s,
          renderLineLimit: r ? 1 : 2
        })
      }
    });
  }],
  ['42', function(ym) {
    ym.modules.define("graphics.renderManager.functions", [], function(e) {
      function r(e, r) {
        if (!r || !e) return 0;
        var n = r,
          t = e;
        if (!n || !t) return 0;
        var d = n.getZIndex(),
          i = t.getZIndex();
        return d != i ? d - i : n.getZOrder() - t.getZOrder()
      }
      e({
        zIndexComparison: r
      })
    });
  }],
  ['45', function(ym) {
    ym.modules.define("graphics.renderManager.NodePane", ["util.dom.element", "util.dom.style", "graphics.renderManager.canvasTile", "graphics.renderManager.functions", "util.css"], function(e, t, s, n, i, a) {
      function h(e, n) {
        this._manager = n, this.element = t.create({
          parentNode: e,
          className: a.addPrefix("node-pane"),
          css: {
            position: "absolute",
            left: 0,
            top: 0,
            zIndex: 0
          }
        }), s.patch(this.element, {
          selectable: !1
        }), this._commandsList = [], this._hasChangedOrder = 0, this._clusters = [], this._items = [], this._counter = 0
      }
      var d = -1,
        r = -2,
        o = -3,
        l = -4;
      h.prototype = {
        add: function(e) {
          this._commandsList.push([this._insert, e])
        },
        remove: function(e) {
          this._commandsList.push([this._remove, e])
        },
        hide: function(e) {
          this._commandsList.push([this._hide, e])
        },
        update: function(e) {
          e.__nodePaneId && (e.__nodePaneId.changed++, e.__nodePaneId.cluster && e.__nodePaneId.cluster.changed++, this._hasChangedOrder++)
        },
        executeQueue: function() {
          var e, t; + new Date;
          for (e = 0, t = this._commandsList.length; e < t; ++e) this._commandsList[e][0].call(this, this._commandsList[e][1]);
          this._commandsList = [], this._hasChangedOrder && (this.sortElements(), this.updateClusters(), this._hasChangedOrder = 0), this.modifyNodes(), this.removeUnused()
        },
        sortElements: function() {
          this._items.sort(function(e, t) {
            return i.zIndexComparison(e.shape, t.shape)
          })
        },
        updateClusters: function() {
          var e, s, n, i, a = "",
            h = [],
            r = [],
            o = null;
          for (e = 0, n = this._items.length; e < n; e++) {
            var l = this._items[e].shape,
              _ = l.getTechName();
            if (this._items[e].index >= d) {
              var u = "canvas" == _ || "webgl" == _;
              (_ != a || l.isDynamic && u) && (o && o.items.length && h.push(o), o = {
                tech: _,
                special: u,
                items: [],
                changed: 0,
                startZIndex: l.getZIndex()
              }), o.items.push(this._items[e]), this._items[e].сluster = o, o.changed += this._items[e].changed, a = l.isDynamic && u ? "" : _
            } else r.push(this._items[e])
          }
          for (o && o.items.length && h.push(o), e = 0, n = this._clusters.length; e < n; e++) {
            var c = !1;
            for (s = 0, i = h.length; s < i; ++s)
              if (this._clusters[e].tech == h[s].tech && !h[s].used) {
                h[s].data = this._clusters[e].data, h[s].used = !0, h[s].topNode = this._clusters[e].topNode, c = !0;
                break
              }
            c || (this._clusters[e].data && this._clusters[e].data.element && t.remove(this._clusters[e].data.element), this._clusters[e].topNode && t.remove(this._clusters[e].topNode))
          }
          this._clusters = h, this._unusedItems = r
        },
        _insert: function(e) {
          if (!e.__nodePaneId) {
            var t = {
              shape: e,
              id: this._counter++,
              index: -1,
              nodeId: this,
              changed: 0,
              prevElement: null
            };
            this._items.push(t), e.__nodePaneId = t
          }
          e.__nodePaneId.index < d && (e.__nodePaneId.index = d), e.__nodePaneId.changed++, this._hasChangedOrder++
        },
        _hide: function(e) {
          e.__nodePaneId && (e.__nodePaneId.index = r, e.__nodePaneId.prevElement = null)
        },
        _remove: function(e) {
          e.__nodePaneId && (this._hide(e), e.__nodePaneId.index = l), this._hasChangedOrder++
        },
        _placeNodes: function(e, t) {
          for (var s = 0, n = 0, i = t.length; n < i; ++n)
            if (t[n].index >= d) {
              var a = t[n].shape;
              a.getPane() || a.attachToContainer();
              var h = a.getPane(),
                r = h.holder();
              h.setPositionPolicy(!1, !0);
              var o = a.reposite();
              (t[n].changed || o) && (h.flush(), t[n].changed = 0);
              var l = r.parentNode == e;
              l || (t[n].index = d, t[n].prevElement = null), t[n].index == n && l || (t[n].index = n, s ? s != r.nextSibling && (e.insertBefore(r, s), t[n].prevElement = s) : (t[n].prevElement = null, e.appendChild(r)), h.changed(a), h.flush()), s = r
            } else this._removeShape(t[n]);
          return s
        },
        _placeSpecial: function(e, t) {
          var s = null;
          if ("canvas" != t.tech) throw new Error("graphics.renderManager.NodePane: неизвесный тип " + t.tech);
          return s = n.place(t, this._manager), e.appendChild(s), s
        },
        modifyNodes: function() {
          for (var e = null, n = null, i = 0, a = this._clusters.length; i < a; ++i) {
            var h = this._clusters[i],
              d = h.topNode;
            d && d.nextSibling == n || (d || (d = h.topNode = t.create({
              className: "graphics-" + h.tech
            }), s.css(d, {
              position: "absolute",
              transform: "translateZ(0)",
              left: 0,
              top: 0
            })), n ? this.element.insertBefore(d, n) : this.element.firstChild ? this.element.insertBefore(d, this.element.firstChild) : this.element.appendChild(d)), s.css(d, {
              zIndex: h.startZIndex
            }), ym.env.debug && s.attr(d, {
              itemsCount: h.items.length
            }), n = d, e = h.special && h.items.length > 0 ? this._placeSpecial(d, h) : this._placeNodes(d, h.items)
          }
        },
        removeUnused: function() {
          if (this._unusedItems)
            for (var e = 0, t = this._unusedItems.length; e < t; ++e) this._removeShape(this._unusedItems[e]);
          this._unusedItems = null
        },
        _removeShape: function(e) {
          var t = e.index;
          if (t <= r && e.shape) {
            var s = e.shape,
              n = s.getPane(),
              i = n ? n.holder() : null;
            i && i.parentNode && i.parentNode.removeChild(i), e.index = o
          }
          t == l && this._unlinkShape(e)
        },
        _unlinkShape: function(e) {
          var t = e.shape;
          t && t.__nodePaneId && (t.__nodePaneId.shape = null, t.__nodePaneId.nodeId = null, t.__nodePaneId.prevElement = null, t.__nodePaneId.сluster = null, t.__nodePaneId = null);
          for (var s = 0, n = this._items.length; s < n; ++s)
            if (this._items[s] === e) {
              this._items.splice(s, 1);
              break
            }
        },
        destroy: function() {
          for (var e = this._items.length - 1; e >= 0; --e) this.remove(this._items[e].shape);
          t.remove(this.element)
        }
      }, e(h)
    });
  }],
  ['47', function(ym) {
    ym.modules.define("graphics.renderManager.pane", ["util.defineClass", "graphics.renderManager.ShapeStorage", "util.scheduler.Group", "util.hd", "graphics.renderManager.constants", "graphics.constants", "vow", "event.Manager"], function(e, t, i, n, s, r, h, o, a) {
      function d(e, t) {
        this._map = t, this._container = e, this._gl = 0, this.events = new a({
          context: this
        }), this._paneEvents = e.events.group().add("viewportchange", this.scheduleUpdate, this).add("panesizechange", this._onSizeChange, this).add("actionend", this.scheduleUpdate, this).add("rendertick", this._renderGraphicsTick, this).add("rendertock", this.scheduleUpdate, this), this._storage = new i(this, e.getElement()), this._commandQueue = [], this._scheduler = new n, t.events.add("destroy", this._onMapDestroy, this)
      }
      var c, l;
      t(d, {
        add: function(e) {
          this._commandQueue.push(["add", e]), this.scheduleUpdate()
        },
        remove: function(e) {
          this._commandQueue.push(["remove", e]), this.scheduleUpdate()
        },
        glAdd: function(e, t) {
          e.state != h.ACTIVE && (e.state = h.ADDING, this._getWebGl().then(function(i) {
            i.addLeaf(e, t)
          }))
        },
        glRemove: function(e) {
          e.state && (e.state = h.ZERO, this._gl && this._gl.removeLeaf(e))
        },
        scheduleUpdate: function() {
          !this._map || this._inRender || this._updateScheduled || this._scheduler.schedule("raf", this._beforeRenderGraphics, this), this._updateScheduled = !0
        },
        _renderGraphicsTick: function() {
          this._gl && this._gl.update({
            render: !0
          }), this._renderGraphics()
        },
        _beforeRenderGraphics: function() {
          this._updateScheduled && this._renderGraphics()
        },
        _renderGraphics: function() {
          if (this._scheduler.unschedule("raf", this._renderGraphics, this), this._inRender = !0, this._updateScheduled = !1, this._map) {
            var e, t;
            for (e = 0, t = this._commandQueue.length; e < t; ++e) this._storage[this._commandQueue[e][0]](this._commandQueue[e][1]);
            this._commandQueue = [], this._render(), this._glRender(), this._inRender = !1, this._updateScheduled && (this._updateScheduled = !1, this.scheduleUpdate())
          }
        },
        _glRender: function() {
          this._gl && this._gl.render({
            render: !0
          })
        },
        _onSizeChange: function() {
          this._gl && this._gl.resize(this.getViewport())
        },
        getViewport: function() {
          return this._container.getViewport()
        },
        toClientPixels: function(e) {
          return this._container.toClientPixels(e)
        },
        getVisibleBounds: function(e) {
          e = e || this._map.options.get("canvasViewportMargin") || r.tileSize / 2;
          var t = this.getViewport();
          return this._map.action.getCurrentState().isTicking && (e = -1), [this._container.fromClientPixels([t[0][0] - e, t[0][1] - e]), this._container.fromClientPixels([t[1][0] + e, t[1][1] + e])]
        },
        _render: function() {
          this._storage.process()
        },
        getZoom: function() {
          return this._container.getZoom()
        },
        getElement: function() {
          return this._container.getElement()
        },
        _onMapDestroy: function() {
          this._map = null, this._container = null, this._scheduler.removeAll(), this._dropWebGl(), this._paneEvents.removeAll()
        },
        _getWebGl: function() {
          return this._webglLoadingPromise || (this._webglLoadingPromise = o.defer(), ym.modules.require(["graphics.webgl.Context", "util.matrix.2d"], function(e, t) {
            c = e, l = t, this._createWebGl(), this._onSizeChange(), this._webglLoadingPromise.resolve(this._gl)
          }, this)), this._webglLoadingPromise.promise()
        },
        _dropWebGl: function() {
          this._gl && (this._gl.events.remove("fail", this._onWebGlFail, this), this._gl.destroy()), this._webglLoadingPromise = null
        },
        _createWebGl: function() {
          var e = 0;
          return this._gl = new c(this.getElement(), e = {
            renderManager: this,
            spawnElement: !0,
            uniforms: {
              viewportDimension: function() {
                var e = this.getViewport();
                return [e[1][0] - e[0][0], e[1][1] - e[0][1], 1]
              }.bind(this),
              projectionScale: function(t) {
                var i = e.uniforms.viewportDimension();
                return [t / i[0], -t / i[1]]
              }.bind(this),
              projectionMatrix: function(t) {
                var i = e.uniforms.projectionScale(1);
                return t = l.identity(t), l.scale(t, t, i), t
              }.bind(this),
              mapCamera: function() {
                var e = Math.pow(2, this._container.getZoom()),
                  t = this._container.getPosition(),
                  i = this._container.getOffset();
                return {
                  scale: e,
                  zoom: this._container.getZoom(),
                  center: t,
                  offset: i
                }
              }.bind(this),
              modelViewMatrix: function(t) {
                var i = (this._map, this._container.getZoom()),
                  n = Math.pow(2, i),
                  s = this._container.getPosition(),
                  r = this._container.getOffset(),
                  h = 0,
                  o = [-s[0] + r[0], -s[1] + r[1]],
                  a = this._gl.getState().DPI,
                  d = e.uniforms.viewportDimension(),
                  c = h ? 2 * a : a,
                  u = [.5 * (Math.ceil(c * d[0]) % 2), .5 * (Math.ceil(c * d[1]) % 2)],
                  _ = [Math.round(o[0] * c) / c, Math.round(o[1] * c) / c],
                  g = [(u[0] + _[0]) / n, (u[1] + _[1]) / n, 1],
                  p = 2,
                  m = [p * n, p * n];
                return t = l.identity(t), l.scale(t, t, m), l.translate(t, t, g), t
              }.bind(this)
            }
          }), this._gl.events.add("fail", this._onWebGlFail, this), this._gl
        },
        _onWebGlFail: function() {
          this.events.fire("webglfail"), this._dropWebGl()
        }
      }), e(d)
    });
  }],
  ['4-', function(ym) {
    ym.modules.define("graphics.renderManager.ShapeStorage", ["graphics.renderManager.NodePane", "util.List", "util.id", "util.pixelBounds", "graphics.renderManager.constants"], function(e, t, n, s, i, r) {
      function a(e, s) {
        this.shapes = new n, this.wrappers = {}, this.manager = e, this.rendered = [], this.nodePane = new t(s, e), this.viewportBounds = null, this.viewportBoundsGen = 0
      }

      function o(e) {
        var t = e.shape.getBounds();
        return e.bounds = t, e.boundsCheckGen = 0, e.position = i.getCenter(t), e.size = i.getSize(t), e.zIndex = e.shape.getZIndex(), e.isPersistentVisible = "canvas" == e.shape.getTechName(), e
      }

      function h(e, t) {
        var n = o({
          order: c++,
          shape: e
        });
        return n.id = s.get(n), n._wrapId = t, n
      }

      function d() {
        this.master.update(o(this))
      }

      function p(e, t) {
        return e && t && e[0][0] == t[0][0] && e[0][1] == t[0][1] && e[1][0] == t[1][0] && e[1][1] == t[1][1]
      }
      var u = r.tileSize;
      a.prototype = {
        add: function(e) {
          var t = this._wrap(e);
          this.shapes.insert(t), this._linkCompontents(t)
        },
        remove: function(e) {
          var t = this._wrap(e);
          t.deleted = !0, this.shapes.remove(t), this._unlinkComponent(t), this.nodePane.remove(e), delete this.wrappers[t._wrapId]
        },
        update: function(e) {
          this.nodePane.update(e.shape), this.manager.scheduleUpdate()
        },
        _wrap: function(e) {
          var t = s.get(e);
          return this.wrappers[t] || (this.wrappers[t] = h(e, t))
        },
        _linkCompontents: function(e) {
          this._unlinkComponent(e), e.master = this, e.events = e.shape.events.group().add(["geometryUpdate", "geometryChanged", "needRedraw", "orderChange"], d, e)
        },
        _unlinkComponent: function(e) {
          e.events && e.events.removeAll()
        },
        process: function() {
          var e = this.manager.getVisibleBounds();
          e[0][0] = Math.floor(e[0][0] / u) * u, e[0][1] = Math.floor(e[0][1] / u) * u, e[1][0] = Math.ceil(e[1][0] / u) * u, e[1][1] = Math.ceil(e[1][1] / u) * u, p(e, this.viewportBounds) || (this.viewportBounds = e, this.viewportBoundsGen++), this.dynamicTest(), this.nodePane.executeQueue()
        },
        dynamicTest: function() {
          for (var e = this.shapes, t = e.first; t;) {
            var n = t.obj;
            if (n.boundsCheckGen != this.viewportBoundsGen) {
              var s = !!n.isPersistentVisible || i.areIntersecting(this.viewportBounds, n.bounds);
              n.boundsCheckGen = this.viewportBoundsGen, s != n.visible && (s ? this._showObject(n) : this._hideObject(n))
            }
            if (t == e.last) break;
            t = t.next
          }
        },
        _showObject: function(e) {
          e.visible = !0, this.nodePane.add(e.shape)
        },
        _hideObject: function(e) {
          e.visible = !1, this.nodePane.hide(e.shape)
        }
      };
      var c = 0;
      e(a)
    });
  }],
  ['0@', function(ym) {
    ym.modules.define("Hint", ["util.defineClass", "Popup", "util.dom.style", "util.dom.viewport", "vow", "hint.metaOptions"], function(t, e, s, i, o, n) {
      function r(t, e) {
        r.superclass.constructor.call(this, t, e), this.options.setName("hint"), this._setupHoverListeners()
      }
      r.UnderCursorError = function() {
        return new Error("Hint is under cursor and 'holdByMouse' option is activated")
      }, e(r, s, {
        open: function(t, e) {
          var s = this.isOpen(),
            i = r.superclass.open.call(this, t, e);
          return s || i.then(function() {
            this.isOpen() && this.setPosition(this.getPosition())
          }, null, null, this), i
        },
        setPosition: function(t) {
          return r.superclass.setPosition.call(this, this.isOpen() ? this._fitPane(t) : t)
        },
        doClose: function(t) {
          return !t && this._mouseOver && this.options.get("holdByMouse", !0) ? (this.getOverlaySync().events.once("mouseleave", this.close, this), n.reject(r.UnderCursorError())) : r.superclass.doClose.call(this)
        },
        _setupHoverListeners: function() {
          this._mouseOver = !1, this.events.add(["mouseenter", "mouseleave"], function(t) {
            this._mouseOver = "mouseenter" == t.get("type")
          }, this)
        },
        _fitPane: function(t) {
          var e = this.getPosition(),
            s = t || e;
          if (ym.env.debug && !s) throw new Error("Hint._fitPane: Не задана позиция.");
          if (!this.options.get("fitPane", !0)) return s;
          var n = this.getOverlaySync(),
            r = n.getLayoutSync();
          if (!r || !r.getShape()) return s;
          var u, l, a, h = this.options.get("projection"),
            p = h.toGlobalPixels(s, this.getMap().getZoom()),
            c = r.getShape().getBounds(),
            g = [c[1][0] - c[0][0], c[1][1] - c[0][1]],
            f = i.getOffset(n.getElement());
          if (t) {
            var v = h.toGlobalPixels(e, this.getMap().getZoom());
            f = [f[0] + (p[0] - v[0]), f[1] + (p[1] - v[1])]
          }
          if ("visible" == this.getMap().panes.get(this.options.get("pane", "outerHint")).getOverflow()) {
            var m = n.getMap().container.getOffset(),
              d = o.getSize(),
              O = o.getScrollOffsets();
            u = [O, [d[0] + O[0], d[1] + O[1]]], f = [f[0] + m[0], f[1] + m[1]]
          } else u = [
            [0, 0], n.getMap().container.getSize()
          ];
          return f[0] < u[0][0] ? p[0] -= f[0] - u[0][0] : (l = u[1][0] - (f[0] + g[0]), l < 0 && (p[0] += l)), f[1] < u[0][1] ? p[1] -= f[1] - u[0][1] : (a = u[1][1] - (f[1] + g[1]), a < 1 && (p[1] += a)), h.fromGlobalPixels(p, this.getMap().getZoom())
        }
      }), t(r)
    });
  }],
  ['0z', function(ym) {
    ym.modules.define("hint.metaOptions", ["map.metaOptions", "map.optionMapper", "constants.zIndex", "interactivityModel.opaque", "map.pane.helper.hint"], function(t, n, e, i, a) {
      n.set({
        hintOverlay: "html#hint",
        hintOpenTimeout: 300,
        hintCloseTimeout: 700,
        hintOffset: [10, 10],
        hintPane: "outerHint",
        hintZIndex: i.hint,
        hintInteractivityModel: a,
        hintLayout: "islands#hint",
        hintContentLayout: "default#content",
        hintMaxWidth: 400,
        hintMaxHeight: 400
      }), e.setRule({
        name: "hint",
        rule: "prefixed"
      }).setRule({
        name: "hint",
        key: ["projection"],
        rule: "plain"
      }), t({})
    });
  }],
  ['1a', function(ym) {
    ym.modules.define("Hotspot", ["util.defineClass", "event.Manager"], function(t, e, n) {
      function i(t, e) {
        this._shape = t, this._zIndex = e || 0, this._id = null, this.events = new n({
          context: this
        })
      }
      e(i, {
        setShape: function(t) {
          this._shape = t, this.events.fire("shapechange")
        },
        getShape: function() {
          return this._shape
        },
        setZIndex: function(t) {
          this._zIndex = t || 0
        },
        getZIndex: function() {
          return this._zIndex
        },
        destroy: function() {
          this._shape = null
        },
        setId: function(t) {
          this._id = t
        },
        getId: function() {
          return this._id || null
        }
      }), t(i)
    });
  }],
  ['5d', function(ym) {
    ym.modules.define("hotspot.Container", ["util.defineClass", "hotspot.container.Internal", "event.Manager", "hotspot.counter", "util.id"], function(t, n, e, i, r, s) {
      function o(t) {
        this._internalContainers = {}, this._internalContainerListeners = {}, this._internalContainerCounter = 0, this._baseSize = t || 256, this.events = new i({
          context: this
        }), this._hotspotsHash = {}, this._hotspotListeners = {}, this._adding = !1
      }
      n(o, {
        add: function(t) {
          this._adding = !0;
          for (var n = {}, e = 0, i = t.length; e < i; e++) {
            var o = t[e];
            r.setNumber(o), this._hotspotListeners[s.get(o)] = o.events.group().add("shapechange", this._onHotspotShapeChange, this);
            var a = this._getContainerType(o);
            this._hotspotsHash[s.get(o)] = a, n[a] || (n[a] = []), n[a].push(o)
          }
          for (var e in n) n.hasOwnProperty(e) && this._addHotspotsToContainer(n[e], e);
          this._adding = !1
        },
        remove: function(t) {
          for (var n = {}, e = 0, i = t.length; e < i; e++) {
            var r = t[e],
              o = this._getContainerType(r);
            this._hotspotListeners[s.get(r)].removeAll(), n[o] ? n[o].push(r) : n[o] = [r], delete this._hotspotListeners[s.get(r)]
          }
          for (var e in n) n.hasOwnProperty(e) && this._internalContainers[e].remove(n[e])
        },
        clear: function() {
          for (var t in this._internalContainers) this._internalContainers.hasOwnProperty(t) && (this._internalContainers[t].forEach(function(t) {
            this._hotspotListeners[s.get(t)].removeAll()
          }, this), this._internalContainers[t] && this._internalContainers[t].clear());
          this._hotspotsHash = {};
          for (var t in this._internalContainers) this._internalContainers.hasOwnProperty(t) && this._removeInternalContainer(t);
          this._hotspotListeners = {}
        },
        setParent: function() {},
        getObjectInPosition: function(t, n, e) {
          var i = null,
            s = e;
          for (var o in this._internalContainers)
            if (this._internalContainers.hasOwnProperty(o)) {
              var a = this._internalContainers[o].getObjectInPosition(t, n);
              if (a) {
                var h = a.getZIndex() || 0;
                null == i || h > s ? (i = a, s = h) : h == s && r.getNumber(a) > r.getNumber(i) && (i = a)
              }
            }
          return i || null
        },
        forEach: function(t, n) {
          for (var e in this._internalContainers) this._internalContainers.hasOwnProperty(e) && this._internalContainers[e].forEach(t, n)
        },
        _addHotspotsToContainer: function(t, n) {
          if (!this._internalContainers[n]) {
            var i = new e;
            this._internalContainers[n] = i, this._internalContainerListeners[n] = i.events.group().add("empty", function() {
              this._removeInternalContainer(n)
            }, this), this._internalContainerCounter++
          }
          this._internalContainers[n].add(t)
        },
        _removeInternalContainer: function(t) {
          delete this._internalContainers[t], this._internalContainerListeners[t].removeAll(), delete this._internalContainerListeners[t], this._internalContainerCounter--, 0 == this._internalContainerCounter && this.events.fire("empty")
        },
        _onHotspotShapeChange: function(t) {
          if (!this._adding) {
            var n = t.get("target"),
              e = this._getContainerType(n),
              i = this._hotspotsHash[s.get(n)];
            i != e ? (this._addHotspotsToContainer([n], e), this._internalContainers[i].remove([n]), this._hotspotsHash[s.get(n)] = e) : this._internalContainers[i].setUnordered(n)
          }
        },
        _getContainerType: function(t) {
          return 0
        }
      }), t(o)
    });
  }],
  ['_7', function(ym) {
    ym.modules.define("hotspot.container.Internal", ["util.defineClass", "event.Manager", "hotspot.counter", "util.array", "util.PrTree", "util.scheduler.manager", "util.id"], function(e, t, r, s, n, i, o, h) {
      function a() {
        this._prTree = new i, this.events = new r({
          context: this
        }), this._operations = [], this._unordered = [], this._wrappers = {}
      }
      t(a, {
        add: function(e) {
          this._operations.push({
            type: "add",
            hotspots: e
          }), this._triggerChange()
        },
        remove: function(e) {
          this._operations.push({
            type: "remove",
            hotspots: e
          }), this._triggerChange()
        },
        clear: function() {
          this._wrappers = {}, this._unordered = [], this._operations = [], this._prTree.removeAll(), o.unschedule("raf", this._flatten, this)
        },
        getObjectInPosition: function(e, t, r) {
          this._flatten();
          var n, i = r,
            o = this._prTree.search([e, e]);
          if (!o.length) return null;
          for (var h = 0; h < o.length; h++) {
            var a = o[h].hotspot;
            if (a.getShape().contains(e)) {
              var p = a.getZIndex() || 0;
              "undefined" == typeof i || p > i ? (n = a, i = p) : p == i && s.getNumber(a) > s.getNumber(n) && (n = a)
            }
          }
          return n || null
        },
        setUnordered: function(e) {
          var t = h.get(e);
          this._wrappers[t] && this._unordered.push(e), this._triggerChange()
        },
        forEach: function(e, t) {
          this._flatten(), this._prTree.each(function(r) {
            e.call(t, r.hotspot)
          })
        },
        _flatten: function() {
          if (o.unschedule("raf", this._flatten, this), this._unordered.length) {
            this._removeHotspots(this._unordered, !0);
            for (var e = 0; e < this._unordered.length; e++) this._getWrapper(this._unordered[e], !0);
            this._operations.unshift({
              type: "add",
              hotspots: this._unordered
            }), this._unordered = []
          }
          var t = this._filterOperations(this._operations),
            r = 0 == this._prTree.getLength() && 0 == t.added.length;
          this._operations = [], t.removed.length && this._removeHotspots(t.removed), t.added.length && this._prTree.insert(t.added), r || 0 != this._prTree.getLength() || this.events.fire("empty")
        },
        _removeHotspots: function(e, t) {
          for (var r = 0, s = e.length; r < s; r++) {
            var n = h.get(e[r]),
              i = this._wrappers[n];
            i && (this._prTree.remove(i), t || delete this._wrappers[n])
          }
        },
        _triggerChange: function() {
          o.schedule("raf", this._flatten, this)
        },
        _filterOperations: function(e) {
          var t = this._flattenOperations(e);
          return this._filterNulls(t)
        },
        _flattenOperations: function(e) {
          for (var t = [], r = [], s = {}, n = {}, i = 0, o = 0, a = e.length; o < a; o++)
            for (var p = e[o], d = "add" == p.type ? s : n, u = "add" == p.type ? n : s, _ = 0, l = p.hotspots.length; _ < l; _++) {
              var f = p.hotspots[_],
                g = h.get(f);
              g in d && delete t[d[g]], d[g] = i, g in u && (delete t[u[g]], delete u[g]), t[i] = f, r[i] = p.type, i++
            }
          return {
            hotspots: t,
            types: r,
            addIndex: s,
            removeIndex: n
          }
        },
        _filterNulls: function(e) {
          for (var t = [], r = [], s = 0, n = e.hotspots.length; s < n; s++) {
            var i = e.hotspots[s];
            i && ("add" == e.types[s] ? t.push(this._getWrapper(i)) : r.push(i))
          }
          return {
            added: t,
            removed: r
          }
        },
        _getWrapper: function(e, t) {
          var r = h.get(e);
          return this._wrappers[r] ? t && (this._wrappers[r].bbox = e.getShape().getBounds()) : this._wrappers[r] = {
            hotspot: e,
            bbox: e.getShape().getBounds()
          }, this._wrappers[r]
        }
      }), e(a)
    });
  }],
  ['5f', function(ym) {
    ym.modules.define("hotspot.counter", [], function(t) {
      var e = new function() {
        this._currentNumber = -1, this._prefix = "hotspotSerialNumber_" + (new Date).getTime() + Math.round(1e4 * Math.random()), this.setNumber = function(t) {
          t[this._prefix] = ++this._currentNumber
        }, this.getNumber = function(t) {
          return t[this._prefix]
        }
      };
      t(e)
    });
  }],
  ['5h', function(ym) {
    ym.modules.define("hotspot.Layer", ["util.defineClass", "event.globalize", "collection.Item", "Monitor", "constants.mapDomEvents", "hotspot.layer.Container", "hotspot.Container", "hotspot.Manager", "hotspot.layer.optionMapper", "layer.optionMapper", "util.bind", "util.id", "Event", "vow", "util.math.areEqual", "theme.islands.hotspot.meta.full"], function(t, e, o, s, i, n, r, a, l, h, c, u, _, p, d, g) {
      function m(t, e) {
        return e + t.slice(0, 1).toUpperCase() + t.slice(1)
      }
      for (var b = {}, f = 0, j = n.length; f < j; f++) b[n[f]] = !0;
      var v = function(t, e) {
          v.superclass.constructor.call(this, e), this.events.addController(y), this.options.setName("hotspotLayer"), this.options.setMapper(h), this._objectSource = t, this._objectSourceListener = this._objectSource.events.group().add("update", this.update, this), this._container = new r(this), this._temporaryContainer = null, this._temporaryContainerState = null, this._temporaryObjectsByHotspotId = {}, this._temporaryContainerTileStatus = null, this._containerListener = this._container.events.group(), this._activeTileStatus = null, this._mapListener = null, this.events.fire("create"), this._cursorSet = null, this._controller = {
            onBeforeEventFiring: u(this._onBeforeObjectEventFiring, this),
            onAfterEventFiring: u(this._onAfterObjectEventFiring, this)
          }, this._objects = [], this._layerObjectsByHotspotId = {}, this._optionMonitor = null, this._mapActionCounter = 0, this._lastDataRequest = null, this._lastObjectsRequest = null, this._lastRequestObjectsDeferred = null, this._lastObjectsLoadCallback = null
        },
        y = o(v);
      v.OutdatedTile = function() {
        return new Error("hotspot.Layer: requested tile data is outdated.")
      }, e(v, s, {
        getObjectSource: function() {
          return this._objectSource
        },
        update: function() {
          this._lastRequestObjectsDeferred && (this._lastRequestObjectsDeferred.reject(new v.OutdatedTile), this._lastRequestObjectsDeferred = null), this._lastObjectsRequest = null, this._lastObjectsLoadCallback = null, this._layerObjectsByHotspotId = {}, this.events.fire("update")
        },
        getObjectInPosition: function(t) {
          var e = this.getMap();
          if (!e) return null;
          var o = e.getZoom(),
            s = this._getTile(t),
            i = this._container.getActiveTileAndZoom();
          return i.tile && g(s, i.tile) && i.zoom == o ? this._getObjectFromLayerContainer(t, s, o) : this._getObjectFromTemporaryContainer(t, s, o)
        },
        _getObjectFromLayerContainer: function(t, e, o) {
          var s = d.defer();
          if ("ready" == this._activeTileStatus) s.resolve(this._getObjectFromLayerContainerSync(t));
          else {
            var i = this._getObjectFromLayerContainerSync(t);
            i ? s.resolve(i) : this._container.events.once("dataload", function(o) {
              g(o.get("tile"), e) ? s.resolve(this._getObjectFromLayerContainerSync(t)) : s.reject(new v.OutdatedTile)
            }, this)
          }
          return s.promise()
        },
        _getObjectFromTemporaryContainer: function(t, e, o) {
          var s = d.defer(),
            i = this._temporaryContainerState,
            n = i && g(i.tile, e) && i.zoom == o;
          return this._temporaryContainer && n && "ready" == this._temporaryContainerTileStatus ? s.resolve(this._getObjectFromTemporaryContainerSync(t)) : (this._temporaryContainer ? n || (this._temporaryObjectsByHotspotId = {}, this._temporaryContainer.clear()) : this._temporaryContainer = new a, this._temporaryContainerState = {
            tile: e,
            zoom: o
          }, this._temporaryContainerTileStatus = "loading", this._requestObjects(e, o).then(function(i) {
            var n = this._temporaryContainerState;
            if (this._temporaryContainerTileStatus = "ready", g(e, n.tile) && o == n.zoom) {
              for (var r, a = [], l = 0, h = i.length; l < h; l++) r = i[l].getHotspot(), this._temporaryObjectsByHotspotId[_.get(r)] = i[l], a.push(r);
              this._temporaryContainer.add(a), s.resolve(this._getObjectFromTemporaryContainerSync(t))
            } else s.reject(new v.OutdatedTile)
          }, this)), s.promise()
        },
        _getObjectFromLayerContainerSync: function(t) {
          var e = this.getMap(),
            o = this._container.getObjectInPosition(e.options.get("projection").toGlobalPixels(t, e.getZoom()), e.getZoom());
          return o ? this._layerObjectsByHotspotId[_.get(o)] : null
        },
        _getObjectFromTemporaryContainerSync: function(t) {
          var e = this.getMap(),
            o = this._temporaryContainer.getObjectInPosition(this.options.get("projection").toGlobalPixels(t, e.getZoom()), e.getZoom());
          return o ? this._temporaryObjectsByHotspotId[_.get(o)] : null
        },
        _onBeforeObjectEventFiring: function(t, e, o) {
          if (b[e] && ("mouseleave" == e || "mouseenter" == e)) {
            var s, i, n = o.get("relatedTarget"),
              r = o.get("target");
            r && r.getId && (s = r.getId()), n && n.getId && (i = n.getId()), s && s == i && (o.stopImmediatePropagation(), o.preventDefault())
          }
        },
        _onAfterObjectEventFiring: function(t, e, o) {
          if (b[e] && !o.isImmediatePropagationStopped()) {
            var s = t.params.context;
            this.events.fire(e, new p({
              type: e,
              activeObject: s,
              pagePixels: o.get("pagePixels"),
              clientPixels: o.get("clientPixels"),
              globalPixels: o.get("globalPixels"),
              coords: o.get("coords"),
              domEvent: o.get("domEvent"),
              target: this
            })), this.options.get("dontChangeCursor") || this._checkCursor(e)
          }
        },
        onAddToMap: function(t) {
          this._containerListener.add("datarequest", this._onDataRequest, this), this._mapListener = t.events.group().add("boundschange", this._onMapBoundsChange, this).add("actionbegin", this._onMapActionBegin, this).add(["actionend", "actionbreak"], this._onMapActionEnd, this), this._optionMonitor = new i(this.options).add("zIndex", this._onZIndexChange, this).add("pane", this._onPaneChange, this), this.events.fire("addtomap", {
            target: this,
            type: "addtomap"
          });
          var e = this.options.get("pane", "events"),
            o = "string" == typeof e ? t.panes.get(e) : e;
          this._containerList = l.get(o).getContainerList(), this._containerList.insert(this._container, this.options.get("zIndex", 0))
        },
        onRemoveFromMap: function(t) {
          this._containerList.remove(this._container), this._containerListener.removeAll(), this._mapListener.removeAll(), this._optionMonitor.removeAll(), this.getObjectSource().cancelLastRequest(), this._cursorSet && (this._cursorSet.remove(), this._cursorSet = null), this._temporaryContainer && (this._temporaryContainer.clear(), this._temporaryContainerState = null, this._temporaryContainerTileStatus = null), this._lastRequestObjectsDeferred && (this._lastRequestObjectsDeferred.reject(new v.OutdatedTile), this._lastRequestObjectsDeferred = null), this._lastObjectsRequest = null, this._mapActionCounter = 0, this._lastObjectsLoadCallback = null, this._layerObjectsByHotspotId = {}, this._activeTileStatus = null, this.events.fire("removefrommap", {
            target: this,
            type: "removefrommap"
          })
        },
        _onPaneChange: function() {
          this._containerList.remove(this._container);
          var t = this.options.get("pane", "events"),
            e = "string" == typeof t ? this.getMap().panes.get(t) : t;
          this._containerList = l.get(e).getContainerList(), this._containerList.insert(this._container)
        },
        _onZIndexChange: function() {
          var t = this.getMap();
          t && (this.onRemoveFromMap(t), this.onAddToMap(t))
        },
        _onMapBoundsChange: function(t) {
          t.get("newZoom") != t.get("oldZoom") && this.getObjectSource().cancelLastRequest()
        },
        _onMapActionBegin: function() {
          this._mapActionCounter++
        },
        _onMapActionEnd: function() {
          if (this._mapActionCounter--, this._lastDataRequest) {
            var t = "round" == this.options.get("tilesRoundingMethod", "round") ? Math.round(this._lastDataRequest.zoom) == Math.round(this.getMap().getZoom()) : Math.floor(this._lastDataRequest.zoom) == Math.floor(this.getMap().getZoom());
            t && this._loadData(this._lastDataRequest.tile, this._lastDataRequest.zoom), this._lastDataRequest = null
          }
        },
        _onDataRequest: function(t) {
          this._mapActionCounter > 0 ? this._lastDataRequest = {
            tile: t.get("tile"),
            zoom: t.get("zoom")
          } : this._loadData(t.get("tile"), t.get("zoom"))
        },
        _loadData: function(t, e) {
          this._activeTileStatus = "loading", this._requestObjects(t, e).then(this._getLoadListener(t, e), this)
        },
        _requestObjects: function(t, e) {
          if (!this._lastObjectsRequest || !g(this._lastObjectsRequest.tile, t) || this._lastObjectsRequest.zoom != e) {
            this._lastRequestObjectsDeferred && this._lastRequestObjectsDeferred.reject(new v.OutdatedTile);
            var o = this._lastRequestObjectsDeferred = d.defer();
            this._lastObjectsRequest = {
              tile: t,
              zoom: e
            }, this.getObjectSource().requestObjects(this, t, e, u(function(t) {
              o == this._lastRequestObjectsDeferred && o.resolve(t)
            }, this))
          }
          return this._lastRequestObjectsDeferred.promise()
        },
        _getLoadListener: function(t, e) {
          var o = this._lastObjectsLoadCallback = function(s) {
            o == this._lastObjectsLoadCallback && this._onObjectsLoaded(t, e, s)
          };
          return o
        },
        _onObjectsLoaded: function(t, e, o) {
          var s = this._container.getActiveTileAndZoom();
          if (s.tile && g(t, s.tile) && s.zoom == e) {
            this._activeTileStatus = "ready", this._objects = o, this._layerObjectsByHotspotId = {};
            for (var i = 0, n = o.length; i < n; i++) o[i].options.setParent(this.options), o[i].events.addController(this._controller), this._layerObjectsByHotspotId[_.get(o[i].getHotspot())] = o[i];
            this.events.fire("dataload", {
              tile: t,
              zoom: e,
              objects: this._objects
            })
          }
        },
        _checkCursor: function(t) {
          if ("mouseenter" == t) this._cursorSet || (this._cursorSet = this.getMap().cursors.push(this.options.get("cursor") || "pointer"));
          else if ("mouseleave" == t) {
            var e = this.getMap();
            e && this._cursorSet && (this._cursorSet.remove(), this._cursorSet = null)
          }
        },
        _getTile: function(t) {
          var e = this.options.get("projection").toGlobalPixels(t, this.getMap().getZoom());
          return [Math.floor(e[0] / 256), Math.floor(e[1] / 256)]
        }
      }), c.setRule({
        name: "hotspotLayer",
        rule: function(t, e) {
          return [m(t, e), t]
        }
      }), c.setRule({
        name: "hotspotLayer",
        key: ["projection"],
        rule: "plain"
      }), t(v)
    });
  }],
  [':n', function(ym) {
    ym.modules.define("hotspot.layer.addon.balloon", ["hotspot.Layer", "popup.addonBuilder", "hotspot.layer.Balloon"], function(a, e, o, t) {
      a(o.build({
        type: "balloon",
        metaEventManager: e.getMetaEventManager(),
        defaultManager: t
      }))
    });
  }],
  [':o', function(ym) {
    ym.modules.define("hotspot.layer.addon.hint", ["hotspot.Layer", "popup.addonBuilder", "hotspot.layer.Hint"], function(e, t, a, n) {
      e(a.build({
        type: "hint",
        metaEventManager: t.getMetaEventManager(),
        defaultManager: n
      }))
    });
  }],
  ['_9', function(ym) {
    ym.modules.define("hotspot.layer.Balloon", ["util.defineClass", "Balloon", "component.sharedEntity.captor.Balloon", "event.Manager", "map.addon.balloon", "hotspot.layer.optionMapper", "option.Manager", "projection.idle", "util.component", "util.extend", "util.preset", "popup.managerStorage", "popup.component.checkEmptiness", "balloon.component.getBalloonMode"], function(t, o, e, n, a, i, s, p, h, r, l, c, u, _, g) {
      function d(t) {
        this._hotspotLayer = t, this.events = new a({
          context: this
        }), this._setupCaptor(), this._setupListeners(), this._checkMapListener(t.getMap())
      }
      var f = {
        autoPan: !1
      };
      o(d, r.createProxyMethods(function() {
        return this._captor
      }, ["open", "close", "isOpen", "getOverlay", "getOverlaySync", "autoPan", "getOwner", "setPosition", "getPosition", "setData", "getData", "setOptions", "getOptions"]), {
        destroy: function() {
          this._clearListeners(), this._clearCaptor()
        },
        isEmpty: function(t, o, e) {
          var n = this._specifyData(o),
            a = {
              projection: h,
              panelMode: "panel" == g(this._hotspotLayer.getMap(), this._hotspotLayer.options.get("balloonPanelMaxMapArea"))
            };
          return n.options = new p(e ? l(a, e) : a, this._hotspotLayer.options, "balloon"), _(this._hotspotLayer.getMap(), "balloon", t, n)
        },
        open: function(t, o, e) {
          return this._captor.open(t, this._specifyData(o), e)
        },
        setData: function(t) {
          return this._captor.setData(this._specifyData(t))
        },
        _setupCaptor: function() {
          var t = this._hotspotLayer.getMap(),
            o = t && i.get(t);
          this._captor = new n(this, this._hotspotLayer, "balloon", o)
        },
        _clearCaptor: function() {
          this._captor.destroy(), this._captor = null
        },
        _setupListeners: function() {
          this._hotspotLayer.events.add("mapchange", this._onMapChange, this).add("clickdefaultaction", this.onClickDefault, this)
        },
        _clearListeners: function() {
          this._hotspotLayer.events.remove("clickdefaultaction", this.onClickDefault, this).remove("mapchange", this._onMapChange, this), this._checkMapListener(null)
        },
        onClickDefault: function(t) {
          var o = this._hotspotLayer.options;
          if (o.get("openBalloonOnClick", !0)) {
            var e = t.get("originalEvent"),
              n = e.get("activeObject"),
              a = e.get("globalPixels"),
              i = n.getProperties();
            o.get("openEmptyBalloon", !1) ? this.open(a, i) : this.isEmpty(a, i).then(function(t) {
              t || this.open(a, i)
            }, this)
          }
        },
        _specifyData: function(t) {
          return t || (t = {}), t.layer = this._hotspotLayer, t
        },
        _onMapChange: function() {
          var t = this._hotspotLayer.getMap();
          t ? this._setupSharingManager() : this.close(), this._checkMapListener(t)
        },
        _checkMapListener: function(t) {
          this._mapEventsListener && this._mapEventsListener.removeAll(), t ? (this._mapEventsListener = t.events.group().add("boundschange", this._onMapBoundsChange, this), this._oldMapZoom = t.getZoom()) : this._mapEventsListener = null
        },
        _setupSharingManager: function() {
          this._captor.setSharingManager(i.get(this._hotspotLayer.getMap()))
        },
        _onMapBoundsChange: function(t) {
          var o = this._oldMapZoom,
            e = this._hotspotLayer.getMap().getZoom();
          if (this._oldMapZoom = e, this.isOpen() && o != e) {
            if (this._hotspotLayer.options.get("closeBalloonOnZoomChange")) {
              var n = "round" == this._hotspotLayer.options.get("tilesRoundingMethod", "round") ? Math.round(this._initialZoom) != Math.round(e) : Math.floor(this._initialZoom) != Math.floor(e);
              if (n) return void this.close()
            }
            var a = this._captor.getPosition(),
              i = Math.pow(2, e - o);
            this._disableAutoPan(), this.setPosition([a[0] * i, a[1] * i]), this._enableAutoPan()
          }
        },
        _disableAutoPan: function() {
          c.addTo(this.getOptions(), f)
        },
        _enableAutoPan: function() {
          c.removeFrom(this.getOptions(), f)
        }
      }), u.add("hotspot#balloon", d), s.setRule({
        name: "balloon",
        rule: "prefixed"
      }), t(d)
    });
  }],
  ['_$', function(ym) {
    ym.modules.define("hotspot.layer.Container", ["util.defineClass", "hotspot.Container", "event.Manager", "util.math.cycleRestrict", "util.math.areEqual"], function(t, e, o, i, s, n) {
      function r(t, e) {
        o.call(this, e), this.events = new i({
          context: this
        }), this._tile = null, this._zoom = null, this._missedPosition = null, this._layer = t, this._listener = t.events.group().add("dataload", this._onDataLoaded, this).add("update", this._onLayerUpdate, this).add(["addtomap", "removefrommap"], this._onMapChange, this), this._location = null, this._projection = null
      }
      e(r, o, {
        getObjectInPosition: function(t, e, o) {
          var i, s, n = this._convertPosition(t, e),
            l = this._layer.getMap().getZoom(),
            a = "round" == this._layer.options.get("tilesRoundingMethod", "round") ? Math.round(l) : Math.floor(l),
            h = a - l,
            u = this._toZeroWorld(n);
          return h && (i = Math.pow(2, h), u = [i * u[0], i * u[1]]), l = a, s = [Math.floor(u[0] / 256), Math.floor(u[1] / 256)], this.setActiveTileAndZoom(s, l), r.superclass.getObjectInPosition.call(this, u, l, o)
        },
        setParent: function(t) {
          t ? (this._containerListListener = t.events.group().add("positionchange", this._onPositionChange, this), this._resolveProjection()) : this._containerListListener.removeAll()
        },
        getLayer: function() {
          return this._layer
        },
        remove: function() {
          if (ym.env.debug) throw new Error("hotspot.container.HotspotLayerContainer.remove: Объекты класса не поддерживают удаление элементов по одному.")
        },
        setActiveTileAndZoom: function(t, e) {
          this._equals(t, this._tile) && this._zoom == e ? this._requestedTile && (this._requestedTile = null) : (this._zoom = e, this._equals(t, this._requestedTile) || (this._requestedTile = t, this.events.fire("datarequest", {
            tile: t,
            zoom: e
          })))
        },
        getActiveTileAndZoom: function() {
          return {
            tile: this._requestedTile || this._tile,
            zoom: this._zoom
          }
        },
        _onPositionChange: function(t) {
          var e = t.get("added");
          if (e.length > 0) {
            var o = e[e.length - 1],
              i = o.zoom,
              s = this._toZeroWorld(this._convertPosition(o.position, i)),
              n = "round" == this._layer.options.get("tilesRoundingMethod", "round") ? Math.round(i) : Math.floor(i),
              r = 256 * Math.pow(2, i - n),
              l = [Math.floor(s[0] / r), Math.floor(s[1] / r)];
            this.setActiveTileAndZoom(l, n)
          }
        },
        _onLayerUpdate: function() {
          this.clear();
          var t = this._layer.getMap();
          if (t) {
            if (this._requestedTile || this._tile) {
              this._requestedTile || (this._requestedTile = this._tile), this._tile = null;
              var e = this._layer.getMap().getZoom();
              this.events.fire("datarequest", {
                tile: this._requestedTile,
                zoom: "round" == this._layer.options.get("tilesRoundingMethod", "round") ? Math.round(e) : Math.floor(e)
              })
            }
          } else this._tile = null
        },
        _onMapChange: function() {
          this._requestedTile = null
        },
        _onDataLoaded: function(t) {
          var e = t.get("tile"),
            o = t.get("zoom");
          if (this._equals(e, this._requestedTile) && o == this._zoom) {
            this._tile = e;
            for (var i = t.get("objects"), s = [], n = 0, r = i.length; n < r; n++) s.push(i[n].getHotspot());
            this.clear(), this.add(s), this._requestedTile = null, this.events.fire("dataload", {
              tile: e,
              zoom: o
            })
          }
        },
        _equals: function(t, e) {
          return !(!t || !e) && n(t, e)
        },
        _toZeroWorld: function(t) {
          for (var e = this._layer.getMap(), o = e.options.get("projection").isCycled(), i = 256 * Math.pow(2, e.getZoom()), n = [], r = 0; r < 2; r++) o[r] ? n[r] = s(t[r], 0, i - 1) : n[r] = t[r];
          return n
        },
        _convertPosition: function(t, e) {
          if (!this._projection.diff) return t;
          var o = this._projection.map.fromGlobalPixels(t, e);
          return this._projection.self.toGlobalPixels(o, e)
        },
        _resolveProjection: function() {
          var t = this._layer.options.get("projection"),
            e = this._layer.getMap().options.get("projection");
          this._projection = {
            self: t,
            map: e,
            diff: e != t
          }
        }
      }), t(r)
    });
  }],
  ['__', function(ym) {
    ym.modules.define("hotspot.layer.Hint", ["util.defineClass", "Hint", "component.sharedEntity.captor.Popup", "event.Manager", "map.addon.hint", "hotspot.layer.optionMapper", "hotspot.Manager", "option.Manager", "projection.idle", "util.component", "util.extend", "util.preset", "popup.managerStorage", "popup.component.checkEmptiness"], function(t, e, o, s, n, i, a, r, p, h, u, c, _, g, l) {
      function y(t) {
        this._hotspotLayer = t, this.events = new n({
          context: this
        }), this._setupCaptor(), this._setupListeners()
      }
      e(y, u.createProxyMethods(function() {
        return this._captor
      }, ["close", "isOpen", "getOverlay", "getOverlaySync", "getOwner", "setPosition", "getPosition", "getData", "setOptions", "getOptions"]), {
        destroy: function() {
          this._clearListeners(), this._clearCaptor()
        },
        isEmpty: function(t, e, o) {
          var s = this._specifyData(e),
            n = {
              projection: h
            };
          return s.options = new p(o ? c(n, o) : n, this._hotspotLayer.options, "hint"), l(this._hotspotLayer.getMap(), "hint", t, s)
        },
        open: function(t, e, o) {
          return this._captor.open(t, this._specifyData(e), o)
        },
        setData: function(t) {
          return this._captor.setData(this._specifyData(t))
        },
        _setupCaptor: function() {
          var t = this._hotspotLayer.getMap(),
            e = t && i.get(t);
          this._captor = new s(this, this._hotspotLayer, "hint", e)
        },
        _clearCaptor: function() {
          this._captor.destroy(), this._captor = null
        },
        _setupListeners: function() {
          this._hotspotLayer.events.add("mapchange", this._onMapChange, this), this._startMouseenterListening()
        },
        _clearListeners: function() {
          this._hotspotLayer.events.remove("mapchange", this._onMapChange, this), this._stopMouseenterListening()
        },
        _onMouseEnterDefault: function(t) {
          var e = this._hotspotLayer;
          if (e.options.get("openHintOnHover", !0)) {
            var o = t.get("originalEvent"),
              s = o.get("globalPixels"),
              n = o.get("activeObject"),
              i = n.getProperties();
            this._hotspotLayer.options.get("openEmptyHint", !1) ? this.open(s, i) : this.isEmpty(s, i).then(function(t) {
              t || this.open(s, i).then(function() {
                var t = e.getMap(),
                  o = e.options.get("pane", "events"),
                  s = "string" == typeof o ? t.panes.get(o) : o;
                r.get(s).getActiveHotspot() != n.getHotspot() && this.close()
              }, this)
            }, this), e.events.add("mousemove", this._onHotspotLayerMouseMove, this).add("mouseleave", this._onHotspotLayerMouseLeave, this)
          }
        },
        _onMapChange: function() {
          this._hotspotLayer.getMap() ? this._setupSharingManager() : (this._clearHotspotEvents(), this.close(!0))
        },
        _setupSharingManager: function() {
          this._captor.setSharingManager(i.get(this._hotspotLayer.getMap()))
        },
        _onHotspotLayerMouseMove: function(t) {
          this.setPosition(t.get("globalPixels"))
        },
        _clearHotspotEvents: function() {
          this._hotspotLayer.events.remove("mousemove", this._onHotspotLayerMouseMove, this).remove("mouseleave", this._onHotspotLayerMouseLeave, this)
        },
        _onHotspotLayerMouseLeave: function() {
          this.close(), this._clearHotspotEvents()
        },
        _specifyData: function(t) {
          return t || (t = {}), t.layer = this._hotspotLayer, t
        },
        _startMouseenterListening: function() {
          this._hotspotLayer.events.add("mouseenterdefaultaction", this._onMouseEnterDefault, this)
        },
        _stopMouseenterListening: function() {
          this._hotspotLayer.events.remove("mouseenterdefaultaction", this._onMouseEnterDefault, this)
        }
      }), g.add("hotspot#hint", y), a.setRule({
        name: "hint",
        rule: "prefixed"
      }), t(y)
    });
  }],
  ['_!', function(ym) {
    ym.modules.define("hotspot.layer.Object", ["util.defineClass", "option.Manager", "event.Manager", "Hotspot", "interactivityModel.EventController", "interactivityModel.layer"], function(t, e, i, o, s, n, r) {
      function h(t, e, s) {
        this._geometry = e.geometry, this._properties = e.properties, this.options = new i(s), this.events = new o({
          context: this
        }), this._setupHotspot(t, this.options.get("zIndex")), this._interactivityModel = this.options.get("interactivityModel", r), this._interactivityEventController = new n(this._interactivityModel), this.events.addController(this._interactivityEventController)
      }
      t(e(h, {
        getHotspot: function() {
          return this._hotspot
        },
        setGeometry: function(t) {
          this._geometry = t
        },
        getGeometry: function() {
          return this._geometry
        },
        setProperties: function(t) {
          this._properties = t
        },
        getProperties: function() {
          return this._properties
        },
        setId: function(t) {
          this._id = t, this._hotspot && this._hotspot.setId(this.getId())
        },
        getId: function() {
          return this._id
        },
        destroy: function() {
          this._clearHotspot(), this.events.removeController(this._interactivityEventController), this._geometry = null, this._interactivityEventController = null
        },
        _setupHotspot: function(t, e) {
          this._hotspot = new s(t, e), this._hotspot.events.setParent(this.events), this._hotspot.setId(this.getId())
        },
        _clearHotspot: function() {
          this._hotspot.events.setParent(null), this._hotspot.destroy(), this._hotspot = null
        }
      }))
    });
  }],
  ['_*', function(ym) {
    ym.modules.define("hotspot.layer.ObjectSource", ["util.defineClass", "util.Chunker", "util.bind", "hotspot.loader", "hotspot.layer.Object", "interactivityModel.storage", "interactivityModel.layer", "event.Manager", "option.Manager", "geometry.pixel.Polygon", "geometry.pixel.Rectangle", "geometry.pixel.MultiPolygon", "shape.Polygon", "shape.Rectangle", "shape.MultiPolygon", "vow"], function(e, t, o, n, i, r, a, s, l, p, c, u, g, h, f, y, m) {
      var v = {
          ConvexPolygon: c,
          Polygon: c,
          MultiConvexPolygon: g,
          MultiPolygon: g,
          Rectangle: u
        },
        d = {
          Polygon: h,
          MultiPolygon: y,
          Rectangle: f
        },
        _ = function(e, t, o) {
          this._tileUrlTemplate = e, this._keyTemplate = t, this.options = new p(o), this.events = new l, this._lastRequest = null, this.options.setName("objectSource")
        };
      t(_, {
        getTileUrl: function(e, t) {
          var o, n = this._tileUrlTemplate;
          return o = "function" == typeof n ? this._tileUrlTemplate(e, t) : this._processTemplate(n, e, t)
        },
        getKey: function(e, t) {
          var o = this._keyTemplate;
          if (!o) return null;
          var n;
          return "function" == typeof o && (n = o(e, t)), n = this._processTemplate(o, e, t)
        },
        getTileUrlTemplate: function() {
          return this._tileUrlTemplate
        },
        setTileUrlTemplate: function(e) {
          this._tileUrlTemplate = e
        },
        getKeyTemplate: function() {
          return this._keyTemplate
        },
        setKeyTemplate: function(e) {
          this._keyTemplate = e
        },
        requestObjects: function(e, t, o, n) {
          if (this.restrict(e, t, o)) n([]);
          else {
            var r = this.getKey(t, o);
            this.cancelLastRequest();
            var a = this._lastRequest = i.load(this.getTileUrl(t, o), {
              key: r,
              noCache: this.options.get("noCache"),
              notJsonpResponse: this.options.get("notJsonpResponse"),
              callback: function(i) {
                a == this._lastRequest && this.parseResponse(e, i, n, t, o)
              },
              context: this
            })
          }
        },
        cancelLastRequest: function() {
          var e = this._lastRequest;
          if (e) {
            if (e instanceof Array)
              for (var t = 0, o = e.length; t < o; t++) e[t].abort && e[t].abort();
            else e.abort && e.abort();
            this._lastRequest = null
          }
        },
        restrict: function(e, t, o) {
          var n = this.options.get("maxZoom", 23),
            i = this.options.get("minZoom", 0);
          if (o > n) return !0;
          if (o < i) return !0;
          var r = this.options.get("bounds");
          if (r) {
            var a = [256 * (t[0] + .5), 256 * (t[1] + .5)],
              s = e.getMap();
            if (!s) return !1;
            var l = s.options.get("projection").fromGlobalPixels(a),
              p = r[1],
              c = r[0];
            if (c[0] > l[0] || c[1] < l[1] || p[0] < l[0] || p[1] > l[1]) return !0
          }
          return !1
        },
        parseResponse: function(e, t, o, n, i) {
          t && !t.error && this._parser(e, t.data, o, n)
        },
        _processTemplate: function(e, t, o) {
          for (var n, i = e.replace(/%x/g, t[0].toString()).replace(/%y/g, t[1].toString()).replace(/%z/g, o.toString()).replace(/%c/g, "x=" + t[0] + "&y=" + t[1] + "&z=" + o).replace(/%l/g, "lang=" + ym.env.lang).replace(/{{ scale }}/g, 1); n = /%d\|?(\d+)?/.exec(i);) {
            for (var r = n && n[1] || 4, a = n && n[0] || "%d", s = 0, l = 0, p = Math.ceil(Math.log(r) / Math.log(2)); l < p; l++) s += (t[(l + 1) % 2] >> Math.floor(l / 2) & 1) << l;
            i = i.replace(a, (s + 1).toString())
          }
          return i
        },
        _parser: function(e, t, i, l) {
          var p = e.getMap();
          p || i([]);
          var c = [256 * l[0], 256 * l[1]],
            u = e.options.get("interactivityModel") || s,
            g = "string" == typeof u ? a.get(u) : u,
            h = [],
            f = new o(t.features, {
              timeout: 0,
              chunkSize: 30,
              worker: n(function(e) {
                var t = e.properties.HotspotMetaData || {},
                  o = t.zIndex,
                  n = this._makePixelGeometry(t.RenderedGeometry.type, this._makeCoordinates(t.RenderedGeometry.coordinates, c)),
                  i = new r(this._makeShape(n), e, {
                    zIndex: o,
                    interactivityModel: g
                  });
                i.setId(t.id), h.push(i)
              }, this)
            });
          f.start(function() {
            i(h)
          })
        },
        _makeCoordinates: function(e, t) {
          var o = [];
          if (e[0].length)
            for (var n = 0, i = e.length; n < i; n++) o[n] = this._makeCoordinates(e[n], t);
          else o = [e[0] + t[0], e[1] + t[1]];
          return o
        },
        _makePixelGeometry: function(e, t) {
          var o = v[e],
            n = !1;
          return "MultiConvexPolygon" != e && "ConvexPolygon" != e || (n = !0), new o(t, "evenOdd", {
            convex: n
          })
        },
        _makeShape: function(e) {
          var t = d[e.getType()];
          return new t(e)
        }
      }), e(_)
    });
  }],
  ['_(', function(ym) {
    ym.modules.define("hotspot.layer.optionMapper", ["option.Mapper"], function(o, e) {
      o(new e)
    });
  }],
  ['5l', function(ym) {
    ym.modules.define("hotspot.loader", ["util.extend", "util.bind", "util.jsonp", "vow"], function(e, n, o, a, t) {
      function r(e, n) {
        if (d[e]) d[e].push(n);
        else {
          d[e] = [n];
          var o = function() {
            delete d[e]
          };
          i[e] = window.setTimeout(o, 24e4)
        }
      }
      var d = {},
        i = {},
        l = null,
        c = {
          load: function(e, d) {
            d = d || {};
            var i, l = {};
            if (d.key && d.key instanceof Array) {
              for (var c = 0, f = d.key.length; c < f; c++) {
                var u = {
                  callback: d.callback[c],
                  context: d.context[c]
                };
                l[d.key[c]] = {
                  abort: function() {
                    u.aborted = !0, l.deferred.reject("aborted")
                  }
                }, r(d.key[c], u)
              }
              i = d.padding || d.key.join("_").replace(/\W/g, "_")
            } else {
              var h;
              if (d.key || d.id) {
                h = d.key || d.id || Math.random();
                var u = n(d, {
                  loaderUrl: e
                });
                r(h, u), l = {
                  abort: function() {
                    u.aborted = !0, l.deferred.reject("aborted")
                  }
                }, i = d.padding || h.replace(/\W/g, "_")
              } else h = Math.random(), i = d.padding || null
            }
            if (i) {
              var k = window[i];
              window[i] = o(function(e) {
                this.onLoad(d.key, e), window[i] = k
              }, this)
            }
            var s = a({
                padding: i,
                noCache: d.noCache,
                url: e
              }),
              v = t.defer();
            return l.deferred = v, s.then(function(e) {
              this.onLoad(d.key, e), v.resolve(e)
            }, function(e) {
              v.reject(e)
            }, this), l
          },
          onLoad: function(e, n) {
            for (var o = [].concat(e), a = 0, t = o.length; a < t; a++) {
              var r = o[a],
                c = d[r];
              if (c) {
                for (var f = 0, u = c.length; f < u; f++) c[f].callback && !c[f].aborted && c[f].callback.call(c[f].context || window, n);
                delete i[r], delete d[r]
              }
            }
            l && l.onLoad(e, n)
          }
        };
      e(c)
    });
  }],
  ['5m', function(ym) {
    ym.modules.define("hotspot.Manager", ["util.defineClass", "event.Manager", "MapEvent", "constants.hotspotEvents", "hotspot.Container", "hotspot.manager.ContainerList", "hotspot.manager.EventController", "util.id", "util.math.areEqual", "util.WeakMap"], function(t, e, n, i, s, o, a, r, h, c, v) {
      function _(t) {
        if (this.events = new n({
            context: this
          }), this._lastEvents = {}, this._activeObject = null, this._containersByZIndex = {}, "undefined" == typeof t) throw new Error("hotspot.Manager: Не удалось получить пейн.");
        this._pane = t, this._map = t.getMap(), this._mapListener = this._map.events.group().add("boundschange", this._onMapBoundsChange, this), this._containerList = new a(this, t), this._containerList.events.add("found", this._onObjectsFound, this), this._paneController = new r(t, this), t.events.addController(this._paneController), u.set(t, this)
      }

      function l(t, e) {
        return {
          position: t.get("globalPixels"),
          zoom: e,
          type: t.get("type")
        }
      }

      function p(t) {
        for (var e = 0, n = d.length; e < n; e++) t.originalEvent[d[e]] = t.get(d[e])
      }
      var u = new v,
        d = ["pagePixels", "clientPixels", "globalPixels", "coords"];
      _.get = function(t) {
        return u.get(t)
      }, e(_, {
        destroy: function() {
          this._pane && (this._pane.events.removeController(this._paneController), this._paneController = null, this._containerList.events.remove("found", this._onObjectsFound, this), this._containerList.clear(), this._containerList = null, this._mapListener.removeAll(), u.remove(this._pane), this._pane = this._map = this._activeObject = null, this._lastEvents = this._containersByZIndex = {})
        },
        getContainerList: function() {
          return this._containerList
        },
        addHotspots: function(t, e) {
          this.getContainerList() && (this._containersByZIndex[e] || this._insertContainerByZIndex(e), this._containersByZIndex[e].add(t))
        },
        removeHotspots: function(t, e) {
          this._containersByZIndex[e] && this._containersByZIndex[e].remove(t)
        },
        focus: function(t, e) {
          var n = this._getActiveObjectByEvent(e);
          if (n) {
            var i = this._activeObject;
            this._activeObject = n, this._enterObject(i, e)
          } else e && e.allowMapEvent()
        },
        process: function(t, e) {
          var n = this._getActiveObjectByEvent(e);
          n ? this._removeLastEvent(t) : (this._addLastEvent(t, e), e.allowMapEvent()), this._processEvent(t, e, n)
        },
        blur: function(t, e) {
          this._activeObject ? (this._leaveObject(null, e), this._activeObject = null) : e && e.allowMapEvent(), this._clearLastEvents()
        },
        getActiveHotspot: function() {
          return this._activeObject
        },
        _onMapBoundsChange: function(t) {
          t.get("oldZoom") != t.get("newZoom") && this._clearLastEvents()
        },
        _getActiveObjectByEvent: function(t) {
          return this._containerList.getObjectInPosition(t.get("globalPixels"), this._map.getZoom())
        },
        _processEvent: function(t, e, n) {
          if (this._activeObject != n) {
            this._activeObject ? this._leaveObject(n, e) : this._leaveMap(n, e);
            var s = this._activeObject;
            this._activeObject = n, this._activeObject ? this._enterObject(s, e) : this._enterMap(s, e)
          }
          this._activeObject && this._activeObject.events.fire(t, new i({
            type: t,
            map: this._map,
            target: this._activeObject,
            origin: "hotspots",
            originalEvent: e
          }, e))
        },
        _insertContainerByZIndex: function(t) {
          var e = new o;
          e.events.once("empty", function() {
            this.getContainerList() && (this.getContainerList().remove(e), this._containersByZIndex[t] = null)
          }, this), this.getContainerList().insert(e, t), this._containersByZIndex[t] = e
        },
        _onObjectsFound: function(t) {
          for (var e = t.get("found"), n = [], o = s.order, a = 0, r = o.length; a < r; a++) {
            var h = o[a],
              c = this._lastEvents[h];
            if (c && e[h]) {
              var v = e[h].activeObject;
              this._processEvent(h, new i({
                type: h,
                target: v,
                map: this._map,
                origin: "hotspots"
              }, c.event), v), n.push(l(c.event, c.zoom)), delete this._lastEvents[h]
            }
          }
          this.events.fire("positionchange", {
            added: [],
            removed: n
          })
        },
        _addLastEvent: function(t, e) {
          "mousemove" == t && this._clearLastEvents();
          var n = this._lastEvents[t];
          p(e), this._lastEvents[t] = {
            event: e,
            zoom: this._map.getZoom()
          }, this.events.fire("positionchange", {
            pane: this._pane,
            added: [l(e, this._map.getZoom())],
            removed: n ? [l(n.event, n.zoom)] : []
          })
        },
        _removeLastEvent: function(t) {
          var e = this._lastEvents[t];
          e && (delete this._lastEvents[t], this.events.fire("positionchange", {
            pane: this._pane,
            added: [],
            removed: [l(e.event, e.zoom)]
          }))
        },
        _clearLastEvents: function() {
          for (var t, e, n = [], i = 0, o = s.order.length; i < o; i++) t = s.order[i], e = this._lastEvents[t], e && n.push(l(e.event, e.zoom));
          this._lastEvents = {}, this.events.fire("positionchange", {
            pane: this._pane,
            added: [],
            removed: n
          })
        },
        _leaveMap: function(t, e) {
          this._map.events.fire("mouseleave", new i({
            type: "mouseleave",
            target: this._map,
            map: this._map,
            relatedTarget: t,
            origin: "hotspots"
          }, e))
        },
        _enterObject: function(t, e) {
          this._activeObject.events.fire("mouseenter", new i({
            type: "mouseenter",
            target: this._activeObject,
            map: this._map,
            relatedTarget: t || this._map,
            origin: "hotspots"
          }, e))
        },
        _leaveObject: function(t, e) {
          this._activeObject.events.fire("mouseleave", new i({
            type: "mouseleave",
            target: this._activeObject,
            map: this._map,
            relatedTarget: t || this._map,
            origin: "hotspots"
          }, e))
        },
        _enterMap: function(t, e) {
          this._map.events.fire("mouseenter", new i({
            type: "mouseenter",
            target: this._map,
            map: this._map,
            relatedTarget: t,
            origin: "hotspots"
          }, e))
        }
      }), t(_)
    });
  }],
  ['_,', function(ym) {
    ym.modules.define("hotspot.manager.ContainerList", ["util.defineClass", "util.List", "util.id", "util.math.areEqual", "event.Manager", "util.extend", "hotspot.counter", "interactivityModel.geoObject", "util.bind"], function(t, e, i, n, o, s, a, r, h, u) {
      function l(t, e) {
        t.events.add("positionchange", this._onPositionChange, this), this._pane = e, this._map = e.getMap(), this._list = new i, this._containerListeners = {}, this.events = new s({
          context: this
        }), this._loadTickTimeout = null, this._positionStack = [], this._containerZIndex = {}
      }
      e(l, {
        clear: function() {
          for (var t, e = this._list.getIterator();
            (t = e.getNext()) != e.STOP_ITERATION;) t.clear()
        },
        getObjectInPosition: function(t, e) {
          for (var i, o, s = this._list.getIterator(), a = null, h = null;
            (i = s.getNext()) != s.STOP_ITERATION;) {
            var u = this._containerZIndex[n.get(i)];
            if (a && "number" == typeof o && o > u) return a;
            "number" == typeof o && o != u && (h = null);
            var l = i.getObjectInPosition(t, e, h);
            if (l) {
              var c = l.getZIndex() || 0;
              "number" != typeof h || c > h ? (a = l, h = c, o = u) : c == h && r.getNumber(l) > r.getNumber(a) && (a = l)
            }
          }
          return a || null
        },
        insert: function(t, e) {
          this._list.insert(t, this._getNextObject(e));
          var i = n.get(t);
          this._containerZIndex[i] = e || 0, this._containerListeners[i] = t.events.group().add("dataload", this._onDataLoaded, this), t.setParent(this)
        },
        remove: function(t) {
          this._list.remove(t);
          var e = n.get(t);
          this._containerListeners[e].removeAll(), delete this._containerListeners[e], delete this._containerZIndex[e], t.setParent(null)
        },
        _onPositionChange: function(t) {
          if (t.get("pane") == this._pane) {
            var e, i, n = t.get("added"),
              o = t.get("removed"),
              s = [];
            for (e = 0, i = this._positionStack.length; e < i; e++) {
              for (var a = !1, r = 0, h = o.length; r < h; r++) this._posEquals(this._positionStack[e], o[r]) && (a = !0);
              a || s.push(this._positionStack[e])
            }
            for (this._positionStack = s, e = 0, i = n.length; e < i; e++) this._positionStack.push(n[e]);
            this.events.fire("positionchange", {
              added: n,
              removed: o
            })
          }
        },
        _onDataLoaded: function(t) {
          var e = function() {
            for (var t, e, i = {}, n = this._map.getZoom(), o = 0, s = this._positionStack.length; o < s; o++) t = this._positionStack[o], (e = this.getObjectInPosition(t.position, n)) && (i[t.type] = a(t, {
              activeObject: e
            }));
            this.events.fire("found", {
              found: i
            }), this._loadTickTimeout = null, this._positionStack = []
          };
          this._loadTickTimeout && window.clearTimeout(this._loadTickTimeout), this._loadTickTimeout = window.setTimeout(u(e, this), 100)
        },
        _posEquals: function(t, e) {
          return t.zoom == e.zoom && t.type == e.type && o(t.position, e.position)
        },
        _getNextObject: function(t) {
          for (var e, i = this._list.getIterator();
            (e = i.getNext()) != i.STOP_ITERATION;)
            if (this._containerZIndex[n.get(e)] <= t) return e;
          return null
        }
      }), t(l)
    });
  }],
  ['_:', function(ym) {
    ym.modules.define("hotspot.manager.EventController", ["util.defineClass", "constants.hotspotEvents"], function(t, e, o) {
      function s(t, e) {
        this._pane = t, this._manager = e
      }

      function n(t) {
        return t.isImmediatePropagationStopped && t.isImmediatePropagationStopped()
      }
      e(s, {
        onBeforeEventFiring: function(t, e, s) {
          if (o.types[e] && "hotspots" != s.get("origin") && !n(s)) {
            if (this._testFiredAs(e, s)) return;
            "mouseenter" == e ? this._manager.focus(e, s) : "mouseleave" == e ? this._manager.blur(e, s) : this._manager.process(e, s)
          }
        },
        _testFiredAs: function(t, e) {
          var o = e.get("domEvent");
          if (o) {
            var s = o.get("propagatedData");
            if (s.hotspotFiredAs || (s.hotspotFiredAs = {}), s.hotspotFiredAs[t]) return !0;
            s.hotspotFiredAs[t] = !0
          }
          return !1
        }
      }), t(s)
    });
  }],
  ['5o', function(ym) {
    ym.modules.define("hotspot.ObjectSource", ["hotspot.layer.ObjectSource"], function(e, o) {
      e(o)
    });
  }],
  ['1d', function(ym) {
    ym.modules.define("Inception", ["util.defineClass", "event.Manager", "domEvent.manager", "data.Manager", "meta", "util.id", "util.querystring", "util.extend", "system.browser", "yandex.counter"], function(e, t, i, a, n, s, o, r, h, _, d) {
      function m(e, t, i) {
        this._url = e, this._iframeReady = !1, this._setupData(t), this._options = h({
          initialWidth: 0,
          initialHeight: 0
        }, i), this._createIFrame(), this._setupEvents(), d.countByKey("modulesUsage", "inception." + e.substr(1).replace(/\//g, "_") + ".2_1")
      }
      e(t(m, {
        setParentElement: function(e) {
          this._parentElement = e, e.appendChild(this._iframe)
        },
        destroy: function() {
          this._clearEvents(), this._clearIFrame(), this._clearData()
        },
        _setupData: function(e) {
          this._data = "function" == typeof e.get ? e : new n(e), this._data.events.add("change", this._updateData, this)
        },
        _clearData: function() {
          this._data.events.remove("change", this._updateData, this), this._data = null
        },
        _updateData: function() {
          this._iframeReady && this._sendToIFrame("datachange", this._data.getAll())
        },
        _createIFrame: function() {
          var e = this._iframe = document.createElement("iframe"),
            t = this._iframeId = o.get(e),
            i = r.stringify({
              lang: s.languageCode + "_" + s.countryCode,
              iframe_id: t,
              url: this._url,
              api_version: s.version,
              counter_prefix: ym.env.server.params.counter_prefix
            });
          e.src = ym.env.hosts.api.services.inception + "?" + i, e.width = this._options.initialWidth, e.height = this._options.initialHeight, e.scrolling = "no", e.style.overflow = "hidden", e.frameBorder = 0
        },
        _clearIFrame: function() {
          this._iframeReady = !1, this._iframe.src = "about:blank", this._clearParentElement(), this._iframe = null
        },
        _clearParentElement: function() {
          this._parentElement && (this._parentElement.removeChild(this._iframe), this._parentElement = null)
        },
        _onIframeLoad: function() {
          this._iframeReady = !0, this._updateData()
        },
        _setupEvents: function() {
          this.events = new i({
            context: this
          }), this.events.add("sizechange", this._onSizeChange, this), a.add(this._iframe, "load", this._onIframeLoad, this), a.add(window, "message", this._onPostMessage, this)
        },
        _clearEvents: function() {
          a.remove(window, "message", this._onPostMessage, this), a.remove(this._iframe, "load", this._onIframeLoad, this), this.events.remove("sizechange", this._onSizeChange, this), this.events = null
        },
        _onSizeChange: function(e) {
          var t = e.get("size");
          this._iframe.width = t[0], this._iframe.height = t[1]
        },
        _onPostMessage: function(e) {
          if (e.get("data")) {
            var t = e.get("data").split("&"),
              i = t[0],
              a = t[1],
              n = t[2];
            i == this._iframeId && this.events.fire(a, JSON.parse(decodeURIComponent(n)))
          }
        },
        _sendToIFrame: function(e, t) {
          var i = this._iframe.contentWindow || this._iframe,
            a = "function" == typeof i.postMessage || _.oldIE && "object" == typeof i.postMessage;
          i && a && i.postMessage(e + "&" + encodeURIComponent(JSON.stringify(t)), "*")
        }
      }))
    });
  }],
  ['5r', function(ym) {
    ym.modules.define("interactivityModel.EventController", ["util.defineClass", "util.array", "constants.mapDomEvents", "interactivityModel.storage"], function(t, i, e, n, o) {
      function a(t) {
        this._interactivityModel = o.get(t)
      }
      for (var r = {}, l = 0, c = n.length; l < c; l++) r[n[l]] = !0;
      i(a, {
        setInteractivityModel: function(t) {
          this._interactivityModel = o.get(t)
        },
        getInteractivityModel: function() {
          return this._interactivityModel
        },
        onBeforeEventFiring: function(t, i, e) {
          var n;
          if (this._interactivityModel && r[i]) {
            var o = this._interactivityModel[i];
            o && ("function" == typeof o ? o(e) : (o.allowMapEvent && e.allowMapEvent(), o.stopPropagation && e.stopPropagation(), o.cancel && (n = !1)))
          }
          return n
        }
      }), t(a)
    });
  }],
  ['5s', function(ym) {
    ym.modules.define("interactivityModel.geoObject", ["constants.mapDomEvents", "interactivityModel.storage"], function(t, e, l) {
      for (var o = {}, a = 0, n = e.length; a < n; a++) o[e[a]] = {};
      o.wheel.allowMapEvent = !0, o.mousedown.allowMapEvent = !0, o.contextmenu.allowMapEvent = !0, o.multitouchstart.allowMapEvent = !0, o.multitouchmove.allowMapEvent = !0, o.multitouchend.allowMapEvent = !0, o.dblclick.allowMapEvent = !0, l.add("default#geoObject", o), t(o)
    });
  }],
  ['5u', function(ym) {
    ym.modules.define("interactivityModel.layer", ["constants.mapDomEvents", "interactivityModel.storage"], function(t, e, a) {
      for (var l = {}, o = 0, n = e.length; o < n; o++) l[e[o]] = {};
      l.wheel.allowMapEvent = !0, l.mousedown.allowMapEvent = !0, l.contextmenu.allowMapEvent = !0, l.multitouchstart.allowMapEvent = !0, l.multitouchmove.allowMapEvent = !0, l.multitouchend.allowMapEvent = !0, a.add("default#layer", l), t(l)
    });
  }],
  ['5w', function(ym) {
    ym.modules.define("interactivityModel.opaque", ["interactivityModel.storage"], function(e, t) {
      var a = {};
      t.add("default#opaque", a), e(a)
    });
  }],
  ['5x', function(ym) {
    ym.modules.define("interactivityModel.silent", ["constants.mapDomEvents", "interactivityModel.storage"], function(t, e, n) {
      for (var a = {}, i = 0, l = e.length; i < l; i++) a[e[i]] = {
        allowMapEvent: !0,
        cancel: !0
      };
      n.add("default#silent", a), t(a)
    });
  }],
  ['5A', function(ym) {
    ym.modules.define("interactivityModel.storage", ["util.Storage"], function(e, t) {
      e(new t)
    });
  }],
  ['5C', function(ym) {
    ym.modules.define("interactivityModel.transparent", ["constants.mapDomEvents", "interactivityModel.storage"], function(t, a, e) {
      for (var n = {}, o = 0, r = a.length; o < r; o++) n[a[o]] = {
        allowMapEvent: !0
      };
      e.add("default#transparent", n), t(n)
    });
  }],
  ['1@', function(ym) {
    ym.modules.define("islets-circle-dot-icon-with-caption", function(n) {
      return [this.name + (n.env.browser.oldIE ? ".ie8" : ".standard")]
    }, function(n) {
      n({})
    });
  }],
  ['8m', function(ym) {
    ym.modules.define('islets-circle-dot-icon-with-caption.standard', ['system.provideCss'], function(provide, provideCss) {
      provideCss(".ymaps-2-1-42-islets_circle-dot-icon-with-caption__caption-block{position:absolute;top:-13px}.ymaps-2-1-42-islets_circle-dot-icon-with-caption__caption-block .ymaps-2-1-42-islets_icon-caption{padding-left:16px}", provide);
    });
  }],
  ['1J', function(ym) {
    ym.modules.define("islets-dot-icon-with-caption", function(n) {
      return [this.name + (n.env.browser.oldIE ? ".ie8" : ".standard")]
    }, function(n) {
      n({})
    });
  }],
  ['8D', function(ym) {
    ym.modules.define('islets-dot-icon-with-caption.standard', ['system.provideCss'], function(provide, provideCss) {
      provideCss(".ymaps-2-1-42-islets_dot-icon-with-caption__caption-block{position:absolute;top:-37px}.ymaps-2-1-42-islets_dot-icon-with-caption__caption-block .ymaps-2-1-42-islets_icon-caption{padding-left:20px}", provide);
    });
  }],
  ['2k', function(ym) {
    ym.modules.define("islets-icon-caption", function(n) {
      return [this.name + (n.env.browser.oldIE ? ".ie8" : ".standard")]
    }, function(n) {
      n({})
    });
  }],
  ['8$', function(ym) {
    ym.modules.define('islets-icon-caption.standard', ['system.provideCss'], function(provide, provideCss) {
      provideCss(".ymaps-2-1-42-islets_icon-caption{white-space:nowrap;font:13px/27px Arial,sans-serif;border-radius:5px;height:27px;text-overflow:ellipsis;overflow:hidden;background:rgba(255,255,255,.85);padding:0 8px 0 0;position:absolute;margin-top:-1px}", provide);
    });
  }],
  ['1g', function(ym) {
    ym.modules.define("Layer", ["util.defineClass", "util.bind", "util.dom.element", "util.hd", "constants.zIndex", "event.globalize", "collection.Item", "layer.optionMapper", "layer.tileContainer.storage", "layer.component.TileSource", "layer.component.TilePositioner", "Monitor", "map.pane.helper.ground"], function(t, e, i, n, o, s, r, a, l, h, _, u, p) {
      var d, g = function(t, e) {
        g.superclass.constructor.call(this, e), this.options.setName("layer"), this.options.setMapper(l), this._tileUrlTemplate = o.selectValue(t), this._tileSource = new _(this), this._tilePositioner = new u(this), this.events.addController(d), this._pane = null, this._tileContainer = null, this._initialZoom = null, this._tileContainerZoom = 0, this._optionMonitor = new p(this.options), this._optionMonitor.add("brightness", this._onBrightnessChange, this, {
          defaultValue: .5
        }).add("zIndex", this._onZIndexChange, this, {
          defaultValue: s.layer
        })
      };
      d = r(g), e(g, a, {
        update: function(t) {
          this._pane && this._tileContainer && (this._tileContainer.redraw({
            reload: !0,
            animate: !0,
            updateBounds: t
          }), this.events.fire("update"))
        },
        reinitialize: function() {
          var t = "round" == this.options.get("tilesRoundingMethod", "round") ? Math.round(this._pane.getZoom()) : Math.floor(this._pane.getZoom());
          this._tileContainerZoom = t, this._tileContainer.setTileZoom(t, this.getViewport())
        },
        setTileUrlTemplate: function(t) {
          this._tileUrlTemplate = o.selectValue(t), this.events.fire("tiletemplatechange")
        },
        getTileUrlTemplate: function() {
          return this._tileUrlTemplate
        },
        getTileUrl: function(t, e) {
          var i = this._tileSource.getTileUrl(t, e);
          return i ? o.selectValue(i) : null
        },
        numberToClientBounds: function(t, e) {
          return this._tilePositioner.numberToClientBounds(t, e)
        },
        numberToGlobalBounds: function(t, e, i) {
          return this._tilePositioner.numberToGlobalBounds(t, e, i)
        },
        clientPixelsToNumber: function(t, e) {
          return this._tilePositioner.clientPixelsToNumber(t, e)
        },
        getTileSize: function(t) {
          return this.options.get("tileSize", [256, 256])
        },
        restrict: function(t, e) {
          return this._tileSource.restrict(t, e)
        },
        _ensureElementExists: function() {
          this._element = n.create({
            css: {
              position: "absolute"
            },
            parentNode: this._pane.getElement()
          })
        },
        _setWebGLPane: function() {
          var t = this.getMap();
          this._pane = this.options.get("webglPane", t.panes.get("ground-webgl")), this._pane = t.panes.get(this._pane)
        },
        onAddToMap: function(t) {
          this._tilePositioner.onAddToMap(t), this._webglImplementation = 0, this._pane = this.options.get("pane", t.panes.get("ground"));
          var e;
          this.options.get("webgl") && this.options.get("webglEnabled") && ym.supports.graphics.hasWebGl() && (e = this.options.get("WebglTileContainerClass")) ? this._webglImplementation = 1 : e = this.options.get("tileContainerClass"), "string" == typeof e ? h.require(e, function(t) {
            t || (this._webglImplementation = 0, t = this.options.get("tileContainerClass")), this._initializeContainer(t)
          }, function() {
            this._webglImplementation = 0, this._initializeContainer(this.options.get("tileContainerClass"))
          }, this) : this._initializeContainer(e), this._onZIndexChange(this._optionMonitor.get("zIndex")), this._initialZoom = this._pane.getZoom()
        },
        _initializeContainer: function(t) {
          this._webglImplementation ? this._setWebGLPane() : this._ensureElementExists(), this._paneListeners = this._pane.events.group().add("actionbegin", this._onActionStart, this).add("viewportchange", this._onViewportChange, this).add("clientpixelschange", this._onClientPixelsChange, this).add("actionend", this._onActionEnd, this).add("actionrestart", this._onActionRestart, this);
          var e = this._tileContainer = new t(this);
          e.setParent(this), e.options.setParent(this.options), e.events.setParent(this.events), this._tileContainerListeners = e.events.group().add("ready", this._onTileContainerReady, this).add("fail", this._onTileContainerFail, this), this._onZIndexChange(this._optionMonitor.get("zIndex")), this.reinitialize()
        },
        onRemoveFromMap: function(t) {
          if (this._tileContainer) {
            var e = this._tileContainer;
            e.setParent(null), e.options.setParent(null), e.events.setParent(null), this._tileContainerListeners.removeAll(), this._tileContainer = null
          }
          this._paneListeners && this._paneListeners.removeAll(), this._element && n.remove(this._element), this._tilePositioner.onRemoveFromMap(t)
        },
        getPane: function() {
          return this._pane
        },
        getElement: function() {
          return this._element
        },
        toClientPixels: function(t) {
          return this._pane.toClientPixels(t)
        },
        fromClientPixels: function(t) {
          return this._pane.fromClientPixels(t)
        },
        getZoom: function() {
          return this._pane.getZoom()
        },
        getViewport: function() {
          return this._pane.getViewport()
        },
        getBrightness: function() {
          return this._optionMonitor.get("brightness")
        },
        _onBrightnessChange: function(t, e) {
          this.events.fire("brightnesschange", {
            newBrightness: t,
            oldBrightness: e
          })
        },
        _onZIndexChange: function(t) {
          this._element ? this._element.style.zIndex = t : this._tileContainer && this._tileContainer.setZIndex(t)
        },
        _onActionStart: function() {
          this.events.fire("actionstart"), this._initialZoom = this._pane.getZoom(), this._isActionStarted = !0
        },
        _onViewportChange: function() {
          this._isActionStarted && !this.options.get("loadTilesInAction", !0) || (0 === this._initialZoom || this._pane.getZoom() >= this._initialZoom - 1) && this._tileContainer && this._tileContainer.setViewport(this._pane.getViewport())
        },
        _onClientPixelsChange: function() {
          this._tileContainer && this._tileContainer.redraw()
        },
        _onActionEnd: function() {
          this.events.fire("beforeactionend"), this._isActionStarted = !1, this._updateContainer(), this._initialZoom = 0, this.events.fire("actionend")
        },
        _onActionRestart: function() {
          this._updateContainer()
        },
        _updateContainer: function() {
          var t = this._pane.getZoom(),
            e = "round" == this.options.get("tilesRoundingMethod", "round") ? Math.round(this._tileContainerZoom) != Math.round(t) : Math.floor(this._tileContainerZoom) != Math.floor(t);
          e ? this.reinitialize() : this._tileContainer && this._tileContainer.setViewport(this.getViewport())
        },
        _onTileContainerReady: function() {
          this.events.fire("ready")
        },
        _onTileContainerFail: function() {
          ym.logger.error("Layer: contailer lost"), this.events.fire("fail");
          var t = this.getMap();
          this.onRemoveFromMap(t), this.onAddToMap(t)
        }
      }), t(g)
    });
  }],
  ['_@', function(ym) {
    ym.modules.define("layer.component.TilePositioner", ["util.math.cycleRestrict"], function(t, o) {
      var e = function(t) {
          return [Math.round(t[0]), Math.round(t[1])]
        },
        i = function(t) {
          this._layer = t, this._projections = {
            self: null,
            parent: null,
            differ: !1
          }
        };
      i.prototype = {
        numberToGlobalBounds: function(t, o, e) {
          var i = this._layer.getTileSize(o),
            n = [i[0] * Math.pow(2, e - o), i[1] * Math.pow(2, e - o)],
            r = [t[0] * n[0], t[1] * n[1]],
            s = [r, [r[0] + n[0], r[1] + n[1]]];
          if (this._projections.differ) {
            var l = {
              from: this._projections.self,
              to: this._projections.parent
            };
            s = [this._convertGlobalPixelPoint(s[0], e, l), this._convertGlobalPixelPoint(s[1], e, l)]
          }
          return s
        },
        numberToClientBounds: function(t, o) {
          var i = this.numberToGlobalBounds(t, o, this._layer.getZoom());
          return [e(this._layer.toClientPixels(i[0])), e(this._layer.toClientPixels(i[1]))]
        },
        clientPixelsToNumber: function(t, o) {
          var e = this._layer.getTileSize(o),
            i = this._layer.getZoom(),
            n = [e[0] * Math.pow(2, i - o), e[1] * Math.pow(2, i - o)],
            r = this._layer.fromClientPixels(t);
          if (this._projections.differ) {
            var s = {
              from: this._projections.parent,
              to: this._projections.self
            };
            r = this._convertGlobalPixelPoint(r, i, s)
          }
          return [Math.floor(r[0] / n[0]), Math.floor(r[1] / n[1])]
        },
        onAddToMap: function(t) {
          this._projections = this._resolveProjections(), this._layer.options.events.add("change", this._onOptionsChange, this)
        },
        onRemoveFromMap: function(t) {
          this._layer.options.events.remove("change", this._onOptionsChange, this)
        },
        _resolveProjections: function() {
          var t = this._layer,
            o = t.options.get("projection"),
            e = t.getParent().options.get("projection");
          return {
            self: o,
            parent: e,
            differ: o != e
          }
        },
        _onOptionsChange: function() {
          var t = this._projections,
            o = this._resolveProjections();
          t.self == o.self && t.parent == o.parent || (this._projections = o, this._layer.update())
        },
        _convertGlobalPixelPoint: function(t, e, i) {
          var n = Math.pow(2, e + 8),
            r = i.to.isCycled(),
            s = [r[0] ? Math.floor(t[0] / n) * n : 0, r[1] ? Math.floor(t[1] / n) * n : 0],
            l = [r[0] ? o(t[0], 0, n) : t[0], r[1] ? o(t[1], 0, n) : t[1]],
            a = i.from.fromGlobalPixels(l, e),
            h = i.to.toGlobalPixels(a, e);
          return [h[0] + s[0], h[1] + s[1]]
        }
      }, t(i)
    });
  }],
  ['_q', function(ym) {
    ym.modules.define("layer.component.TileSource", ["util.hd", "util.math.cycleRestrict", "util.processUrlTemplate"], function(e, t, r, i) {
      var l = function(e) {
        this._layer = e
      };
      l.prototype = {
        getTileUrl: function(e, t) {
          var r = this._layer.restrict(e, t),
            i = r ? this._renderTemplate(r, t) : null;
          return i
        },
        restrict: function(e, t) {
          var i = this._layer.getTileSize(t),
            l = [Math.ceil(Math.pow(2, t + 8) / i[0]), Math.ceil(Math.pow(2, t + 8) / i[1])],
            n = e[0],
            o = e[1],
            a = this._layer.options.get("projection").isCycled();
          if (n < 0 || n >= l[0]) {
            if (!a[0]) return null;
            n = r(n, 0, l[0])
          }
          if (o < 0 || o >= l[1]) {
            if (!a[1]) return null;
            o = r(o, 0, l[1])
          }
          return [n, o]
        },
        _renderTemplate: function(e, r) {
          var l = this._layer.getTileUrlTemplate();
          if ("function" == typeof l) return l(e, r);
          var n = t.getLimitedPixelRatio();
          return n = n < 1 ? 1 : n, i(l, {
            tileNumber: e,
            zoom: r,
            scale: n
          })
        }
      }, e(l)
    });
  }],
  ['0t', function(ym) {
    ym.modules.define("layer.domTileNotFound.css", ["not-found-tile"], function(o) {
      o({})
    });
  }],
  ['5F', function(ym) {
    ym.modules.define("layer.optionMapper", ["option.Mapper"], function(e, n) {
      e(new n)
    });
  }],
  ['5L', function(ym) {
    ym.modules.define("layer.storage", ["util.Storage"], function(e, n) {
      e(new n)
    });
  }],
  ['_i', function(ym) {
    ym.modules.define("layer.tile.CanvasTile", ["event.Manager", "option.Manager", "util.imageLoader", "util.scheduler.strategy.Processing", "util.dom.element", "localization.common.current", "layer.tile.storage"], function(i, t, e, n, a, s, r, o) {
      var h = r.layer.tileNotFound,
        _ = {},
        l = function(i, a, s) {
          this.options = a.get && "function" == typeof a.get ? a : new e(a), this.events = new t({
            context: this
          }), this._imageSize = [0, 0], this._renderOptions = s || {}, this._url = i, i ? (this._loadingImageUrl = i, n.load({
            url: i,
            priority: this._renderOptions.priority,
            channel: "tiles"
          }, this._onLoad, this)) : this._onLoad()
        };
      l.prototype = {
        renderAt: function(i, t, e, n) {
          this._clientPixelBounds = e, this._context = i, this._canvasSize = t, this._renderOptions.tileTransparent = this.options.get("tileTransparent"), this._renderOptions.animate = n && this.options.get("tileAnimateOpacity"), this._loaded && this._draw(), this._rendered = !0
        },
        destroy: function() {
          this._imageSource = this._image = null, this._loaded || n.cancel(this._url, this._onLoad, this), this._animation && this._animation.stop()
        },
        isReady: function() {
          return this._ready
        },
        _onLoad: function(i, t) {
          if (this._imageSource = i, !this._loaded) {
            if (this._renderOptions.image = i, this._error = !t, this._error && !this._renderOptions.tileTransparent) {
              var e = this.options.get("notFoundTile");
              if (this._loadingImageUrl != e && "string" == typeof e) return this._loadingImageUrl = e, void n.load({
                url: e,
                priority: this._renderOptions.priority
              }, this._onLoad, this);
              this._imageSource = this._createErrorCanvas()
            }
            if (this._loaded = !0, this._imageSource) {
              this._imageSize = [this._imageSource.naturalWidth || this._imageSource.width, this._imageSource.naturalHeight || this._imageSource.height], this._renderOptions.imageSize = this._imageSize;
              var a = this.options.get("imagePreprocess");
              this._renderOptions.errorImage = this._createErrorCanvas(this._imageSize), this._image = a ? a(this._imageSource, this._renderOptions) : this._imageSource, this._rendered && this._draw()
            }
          }
        },
        _draw: function() {
          if (this._animation && (this._animation.stop(), this._animation = null), this._error && this._renderOptions.tileTransparent) return void this._onReady();
          var i = this.options.get("tileAnimationDuration", 350),
            t = 0;
          this._renderOptions.animate && i ? (this._animation = new a(function(i) {
            var e = i.progress,
              n = t ? (1 - e / t) / (1 - 1 / t) : e;
            1 == e ? (n = 1, this._animation.stop(), this._animation = null) : t = e, this._context.globalAlpha = n, this._drawImage(), 1 == n && this._onReady()
          }, this, {
            duration: i
          }), this._animation.start()) : (this._context.globalAlpha = 1, this._drawImage(), this._onReady())
        },
        _drawImage: function() {
          var i = this._getIntersection();
          if (i) {
            var t = i[0],
              e = i[1],
              n = this.options.get("imageProxy"),
              a = n ? n(this._image) : this._image;
            this._context.drawImage(a, Math.round(t[0][0]), Math.round(t[0][1]), Math.round(t[1][0] - t[0][0]), Math.round(t[1][1] - t[0][1]), Math.round(e[0][0]), Math.round(e[0][1]), Math.round(e[1][0] - e[0][0]), Math.round(e[1][1] - e[0][1]))
          }
        },
        _getIntersection: function() {
          if (!this._clientPixelBounds) return null;
          var i = this._canvasSize[0] < 1 || this._canvasSize[1] < 1 || this._imageSize[0] < 1 || this._imageSize[1] < 1,
            t = [this._clientPixelBounds[0].slice(), this._clientPixelBounds[1].slice()],
            e = t[1][0] <= 0 || t[1][1] <= 0 || t[0][0] >= this._canvasSize[0] || t[0][1] >= this._canvasSize[1];
          if (i || e) return null;
          var n = [
              [0, 0], this._imageSize.slice()
            ],
            a = [this._imageSize[0] / (t[1][0] - t[0][0]), this._imageSize[1] / (t[1][1] - t[0][1])],
            s = [
              [Math.min(t[0][0], 0), Math.min(t[0][1], 0)],
              [Math.max(t[1][0] - this._canvasSize[0], 0), Math.max(t[1][1] - this._canvasSize[1], 0)]
            ];
          return t[0][0] -= s[0][0], n[0][0] -= Math.round(a[0] * s[0][0]), t[0][1] -= s[0][1], n[0][1] -= Math.round(a[1] * s[0][1]), t[1][0] -= s[1][0], n[1][0] -= Math.round(a[0] * s[1][0]), t[1][1] -= s[1][1], n[1][1] -= Math.round(a[1] * s[1][1]), n[0][0] == n[1][0] || n[0][1] == n[1][1] || t[0][0] == t[1][0] || t[0][1] == t[1][1] ? null : [n, t]
        },
        _createErrorCanvas: function() {
          var i = this.options.get("tileSize", [256, 256]),
            t = i.join("x");
          if (_[t]) return _[t];
          var e = s.create({
              tagName: "canvas",
              css: {
                position: "absolute"
              }
            }),
            n = i[0],
            a = i[1],
            r = e.getContext("2d"),
            o = h.split("<br/>"),
            l = 15,
            d = o.length,
            u = Math.round((a - (d - 1) * l) / 2),
            g = Math.round(n / 2);
          e.width = n, e.height = a, r.fillStyle = "rgb(190, 190, 190)", r.font = "10px Arial", r.textBaseline = "middle", r.textAlign = "center", r.fillRect(0, 0, n, a), r.fillStyle = "rgb(0, 0, 0)";
          for (var c = 0, m = o.length; c < m; c++) r.fillText(o[c], g, u + c * l);
          return _[t] = e
        },
        _onReady: function() {
          this._ready = !0, this.events.fire("ready")
        }
      }, o.add("default#canvas", l), i(l)
    });
  }],
  ['_z', function(ym) {
    ym.modules.define("layer.tile.DomTile", ["util.dom.element", "util.dom.style", "domEvent.manager", "event.Manager", "Event", "option.Manager", "localization.common.current", "util.imageLoader", "layer.tile.storage", "util.css", "util.bind", "system.browser", "layer.domTileNotFound.css"], function(t, e, i, n, s, o, a, r, l, h, d, c, _) {
      function m(t, e, i) {
        var n, s = t[0],
          o = t[1],
          a = [Math.ceil(o[0]) - Math.floor(s[0]), Math.ceil(o[1]) - Math.floor(s[1])];
        if ("css3" != i && "css3-3d" != i || !y) n = {
          size: [Math.ceil(a[0]), Math.ceil(a[1])],
          position: [Math.floor(s[0]), Math.floor(s[1])],
          css: {
            position: "absolute"
          }
        };
        else {
          var r = [Math.floor(s[0]), Math.floor(s[1])],
            l = Math.ceil(e[0]),
            h = Math.ceil(e[1]),
            d = a[0] / l,
            c = a[1] / h,
            m = d > c ? 1 : d / c,
            u = d > c ? c / d : 1;
          n = _.androidBrokenBuild ? {
            patch: {
              transform: {
                scale: [d, c]
              }
            },
            size: [l, h]
          } : {
            patch: {
              transform: {
                scale: [m, u]
              }
            },
            size: [a[0] / m, a[1] / u]
          }, n.patch.transform.offset = r, n.patch.transform.use3D = "css3-3d" == i, n.css = {
            position: "absolute",
            transformOrigin: "0px 0px"
          }
        }
        return n
      }
      var u = ym.supports,
        p = r.layer.tileNotFound,
        f = u.css.checkTransitionProperty("opacity"),
        g = !!f,
        y = !!u.css.checkProperty("transform"),
        M = function(t, e, i) {
          this.options = e.get && "function" == typeof e.get ? e : new a(e), this.events = new s, this._renderOptions = i || {}, t ? (this._url = t, this._usedUrl = "", this._loadState = "loading", this._ready = !1, l.load({
            url: t,
            priority: this._renderOptions.priority,
            channel: "tiles"
          }, this._onLoad, this)) : (this._ready = !0, this._loadState = "error")
        };
      M.prototype = {
        renderAt: function(t, i, n) {
          this._element && this._element.parentNode != t && e.remove(this._element), this._context = t, this._clientPixelBounds = i, this._renderOptions.tileTransparent = this.options.get("tileTransparent"), this._renderOptions.animate = g && n && this.options.get("tileAnimateOpacity"), "loading" != this._loadState ? this._draw() : this._rendered = !0
        },
        destroy: function() {
          this._cancelAnimation(), "loading" == this._loadState && l.cancel(this._url, this._onLoad, this), this._element && (e.remove(this._element), this._element = null), this._context = null
        },
        isReady: function() {
          return this._ready
        },
        _onLoad: function(t, e) {
          t && (this._imageSize = [t.naturalWidth || t.width, t.naturalHeight || t.height], this._usedUrl = t.src, this._renderOptions.imageSize = this._imageSize), this._renderOptions.image = t, "loading" == this._loadState && (this._loadState = e ? "loaded" : "error", this._rendered && this._draw())
        },
        _elementCreate: function(t) {
          var i = this.options.get("elementPreprocess");
          return t = i ? i(t, this._renderOptions) : t, this._renderOptions.animate && (t.css[f] = 0), e.create(t)
        },
        _draw: function() {
          this._cancelAnimation();
          var t = this._renderOptions.tileTransparent,
            e = m(this._clientPixelBounds, this._getImageSize(), this.options.get("tilePositionEngine", "css2"));
          if (this._element) e.patch && i.patch(this._element, e.patch), e.size && i.setSize(this._element, e.size), e.position && i.setPosition(this._element, e.position), e.css[f] = void 0, i.css(this._element, e.css);
          else {
            if ((e.patch || (e.patch = {})).selectable = !1, e.parentNode = this._context, "loaded" == this._loadState) e.patch.scaledBackground = this._usedUrl, e.patch.printBackground = this._usedUrl.replace(/scale=\d\.?\d*/, "scale=1");
            else if (!t) {
              var n = this.options.get("notFoundTile");
              "string" == typeof n ? (e.patch.scaledBackground = n, e.patch.printBackground = n.replace(/scale=\d\.?\d*/, "scale=1")) : (e.css.backgroundColor = "#bebebe", e.html = '<ymaps class="' + d.addPrefix("tile-not-found") + '">' + p + "</ymaps>")
            }
            this._element = this._elementCreate(e)
          }
          this._renderOptions.animate ? this._applyAnimation(this.options.get("tileAnimationDuration", 300)) : this._onReady()
        },
        _getImageSize: function() {
          return "error" == this._loadState ? [Math.ceil(this._clientPixelBounds[1][0]) - Math.floor(this._clientPixelBounds[0][0]), Math.ceil(this._clientPixelBounds[1][1]) - Math.floor(this._clientPixelBounds[0][1])] : this._imageSize
        },
        _applyAnimation: function(t) {
          t > 0 ? (this._ready = !1, this._transiting = !0, n.add(this._element, "transitionend", this._onTransitionEnd, this), i.css(this._element, {
            transitionProperty: f,
            transitionDuration: t + "ms"
          }), this._startAnimationTimeoutId = setTimeout(c(function() {
            this._startAnimationTimeoutId = 0;
            var t = {};
            t[f] = 1, i.css(this._element, t)
          }, this), 32)) : this._onReady()
        },
        _cancelAnimation: function(t) {
          this._startAnimationTimeoutId > 0 && (clearTimeout(this._startAnimationTimeoutId), this._startAnimationTimeoutId = 0), this._transiting && (n.remove(this._element, "transitionend", this._onTransitionEnd, this), t && i.css(this._element, {
            transitionProperty: "",
            transitionDuration: null
          }), this._transiting = !1)
        },
        _onTransitionEnd: function() {
          this._cancelAnimation(!0), this._onReady()
        },
        _onReady: function() {
          this._ready = !0, this.events.fire("ready", new o({
            target: this
          }))
        }
      }, h.add("default#dom", M), t(M)
    });
  }],
  ['_Q', function(ym) {
    ym.modules.define("layer.tile.storage", ["util.Storage"], function(e, t) {
      e(new t)
    });
  }],
  ['_I', function(ym) {
    ym.modules.define("layer.tileContainer.CanvasContainer", ["util.defineClass", "collection.Item", "layer.tile.storage", "layer.tileContainer.storage", "layer.tile.CanvasTile", "util.dom.element", "util.dom.style", "util.tile.Storage", "util.math.areEqual", "util.math.areEqualPaths", "util.hd", "util.pixelBounds"], function(e, t, i, s, n, r, a, l, o, h, d, _, v) {
      var u = ym.env.browser,
        c = u.isMobile || u.isTablet,
        f = c && ym.env.enterprise,
        T = function(e, t) {
          T.superclass.constructor.call(this, t), this._layer = e, this._canvas = null, this._viewport = null, this.tiles = null
        };
      t(T, i, {
        onAddToMap: function() {
          this._canvas = this._createElement(), this._canvasContext = this._canvas.getContext("2d"), this._layer.getElement().appendChild(this._canvas), this.tiles && this._viewport && this.setTileZoom(this.tiles.getTileZoom())
        },
        onRemoveFromMap: function(e) {
          a.remove(this._canvas), this.tiles && (this.tiles.events.remove("ready", this._onTilesReady, this), this._freeTiles()), this._freeOldTiles(), this._canvas = null, this._canvasContext = null
        },
        setTileZoom: function(e, t) {
          this._freeOldTiles(), t && (this._viewport = t);
          var i = this.getMap();
          if (i && this._setDimensions(), this.tiles) {
            this.tiles.events.remove("ready", this._onTilesReady, this);
            var s = this.tiles.getTileZoom();
            if (i && s != e && !this.options.get("tileTransparent")) {
              this._oldTiles = this.tiles;
              var n = [];
              this._oldTiles.each(function(e, t) {
                e.isReady() || (e.destroy(), n.push(t))
              });
              for (var r = 0, a = n.length; r < a; r++) this._oldTiles.remove(n[r]);
              this._renderTiles(this._oldTiles, !1)
            } else this._freeTiles()
          }
          if (this.tiles = new o(e), this.tiles.events.add("ready", this._onTilesReady, this), i) {
            var r, a, l = this.tiles,
              h = this._getTileRange(),
              d = this._getTilesDiff(l, h);
            for (r = 0, a = d.added.length; r < a; r++) {
              var _ = d.added[r],
                v = this.getTile(_, e, _[2]);
              this.tiles.add(_, v), this._renderTile(v, _, e, !this.options.get("tileTransparent"))
            }
            this._setPosition()
          }
        },
        setViewport: function(e) {
          var t = this._viewport;
          this._viewport = e;
          var i, s, n = this.tiles,
            r = this._getTileRange(),
            a = this._getTilesDiff(this.tiles, r);
          if (!d(this._viewport, t) || a.removed.length || a.added.length) {
            for (i = 0, s = a.removed.length; i < s; i++) {
              var l = n.get(a.removed[i]);
              l && (n.remove(a.removed[i]), l.destroy())
            }
            for (i = 0, s = a.added.length; i < s; i++) {
              var o = a.added[i],
                l = this.getTile(o, n.getTileZoom(), o[2]);
              n.add(o, l)
            }
            this._renderAtViewport()
          }
        },
        redraw: function(e) {
          if (this.getMap()) {
            var t, i = this.tiles.getTileZoom(),
              s = !1,
              n = !1;
            if (e && (s = e.reload, n = !this.options.get("tileTransparent") && e.animate, t = e.updateBounds ? v.fromPoints(e.updateBounds) : null), this._clearCanvas(), this._oldTiles && this._renderTiles(this._oldTiles, !1), this.tiles.each(function(e, r) {
                var a = !t || v.containsPoint(t, r);
                return s && a ? (this.tiles.remove(r), void e.destroy()) : void this._renderTile(e, r, i, n && a)
              }, this), s)
              for (var r = this._getTilesDiff(this.tiles, this._getTileRange()), a = 0, l = r.added.length; a < l; a++) {
                var o = r.added[a],
                  h = this.getTile(o, i, o[2]);
                this.tiles.add(o, h), this._renderTile(h, o, i, n)
              }
          }
        },
        _renderTiles: function(e, t) {
          var i = e.getTileZoom();
          e.each(function(e, s) {
            this._renderTile(e, s, i, t)
          }, this)
        },
        _renderTile: function(e, t, i, s) {
          e.renderAt(this._canvasContext, this._currentCanvasSize, this._numberToClientBounds(t, i), s)
        },
        _freeOldTiles: function() {
          this._oldTiles && (this._oldTiles.each(function(e) {
            e.destroy()
          }), this._oldTiles.removeAll(), this._oldTiles = null)
        },
        _renderAtViewport: function() {
          this._setDimensions(), this._setPosition(), this._oldTiles && this._renderTiles(this._oldTiles, !1), this._renderTiles(this.tiles, !1)
        },
        _createElement: function() {
          var e = a.create({
            tagName: "canvas",
            css: {
              position: "absolute"
            }
          });
          return c && "iOS" == u.osFamily && (e.patch = {
            transform: {
              offset: [0, 0],
              use3D: !0
            }
          }), e
        },
        getTile: function(e, t, i) {
          var n = this.options.get("tileClass", "default#canvas"),
            r = this._layer.getTileUrl(e, t);
          return "string" == typeof n && (n = s.get(n)), new n(r, this.options, {
            priority: i,
            tileNumber: e,
            tileZoom: t,
            restrictedTileNumber: this._layer.restrict(e, t)
          })
        },
        _onTilesReady: function() {
          this.events.fire("ready"), this._freeOldTiles()
        },
        _freeTiles: function() {
          this.tiles.each(function(e) {
            e.destroy()
          }), this.tiles.removeAll(), this.tiles = null
        },
        _getTileRange: function() {
          var e = this.tiles.getTileZoom();
          return [this._layer.clientPixelsToNumber(this._viewport[0], e), this._layer.clientPixelsToNumber(this._viewport[1], e)]
        },
        _getTilesDiff: function(e, t) {
          var i, s, n = {
              added: [],
              removed: []
            },
            r = t[0],
            a = t[1],
            l = a[0] - r[0],
            o = a[1] - r[1],
            h = l + o,
            d = h / l,
            _ = h / o,
            v = Math.round(r[0] + l / 2),
            u = Math.round(r[1] + o / 2);
          for (i = r[0]; i <= a[0]; i++)
            for (s = r[1]; s <= a[1]; s++) e.get([i, s]) || n.added.push([i, s, h - Math.max(d * Math.abs(v - i), _ * Math.abs(u - s))]);
          return e.each(function(e, t) {
            t = [parseInt(t[0]), parseInt(t[1])], (t[0] < r[0] || t[0] > a[0] || t[1] < r[1] || t[1] > a[1]) && n.removed.push(t)
          }), n
        },
        _numberToClientBounds: function(e, t) {
          var i = this._viewport[0],
            s = this._layer.numberToClientBounds(e, t);
          return [
            [s[0][0] - i[0], s[0][1] - i[1]],
            [s[1][0] - i[0], s[1][1] - i[1]]
          ]
        },
        _clearCanvas: function() {
          this._canvasContext.clearRect(0, 0, this._currentCanvasSize[0], this._currentCanvasSize[1])
        },
        _setPosition: function() {
          var e = [Math.round(this._viewport[0][0]), Math.round(this._viewport[0][1])];
          l.setPosition(this._canvas, e)
        },
        _setDimensions: function() {
          var e = v.getSize(this._viewport);
          if (this._currentCanvasSize && h(e, this._currentCanvasSize)) this._clearCanvas();
          else {
            this._currentCanvasSize = e, l.setSize(this._canvas, this._currentCanvasSize);
            var t = _.getPixelRatio(),
              i = _.getBackingStorePixelRatio(this._canvasContext),
              s = t / i;
            s = s < 1 ? 1 : s, f && (s = 1), s > 1 && s < 1.5 && (s = 2), l.attr(this._canvas, {
              width: this._currentCanvasSize[0] * s,
              height: this._currentCanvasSize[1] * s
            }), 1 != s && this._canvasContext.scale(s, s)
          }
        }
      }), n.add("default#canvas", T), e(T)
    });
  }],
  ['_Z', function(ym) {
    ym.modules.define("layer.tileContainer.DomContainer", ["util.defineClass", "util.dom.element", "util.dom.style", "util.tile.Storage", "collection.Item", "layer.tile.storage", "layer.tileContainer.storage", "util.pixelBounds", "util.css", "layer.tile.DomTile"], function(e, t, i, s, l, o, n, r, h, a) {
      function d(e, t) {
        d.superclass.constructor.call(this, t), this._layer = e
      }
      t(d, o, {
        onAddToMap: function() {
          var e = {
            css: {
              position: "absolute"
            },
            position: [0, 0],
            parentNode: this.getParent().getElement()
          };
          this._element = i.create(e), this.tiles && this._viewport && this._arrange()
        },
        onRemoveFromMap: function(e) {
          i.remove(this._element), this.tiles && (this.tiles.events.remove("ready", this._onTilesReady, this), this._freeTiles()), this._freeOldTiles(), this._element = null
        },
        getTile: function(e, t, i) {
          var s, l = this._layer.getTileUrl(e, t),
            o = this.options.get("tileClass", "default#dom");
          if (l) s = o;
          else {
            var r = this.options.get("notFoundTile", null);
            "string" != typeof r && r ? s = r : (l = r, s = o)
          }
          return "string" == typeof s && (s = n.get(s)), new s(l, this.options, {
            priority: i,
            tileNumber: e,
            tileZoom: t,
            restrictedTileNumber: this._layer.restrict(e, t)
          })
        },
        _onTilesReady: function() {
          this.events.fire("ready"), this._freeOldTiles()
        },
        _freeTiles: function() {
          this.tiles.each(function(e) {
            e.destroy()
          }), this.tiles.removeAll(), this.tiles = null
        },
        _freeOldTiles: function() {
          this._oldTiles && (this._oldTiles.each(function(e) {
            e.destroy()
          }), this._oldTiles.removeAll(), this._oldTiles = null)
        },
        setTileZoom: function(e, t) {
          if (this._freeOldTiles(), this.tiles)
            if (this.tiles.events.remove("ready", this._onTilesReady, this), !this.options.get("tileTransparent") && this.getMap() && Math.abs(this.tiles.getTileZoom() - e) <= 3) {
              this._oldTiles = this.tiles;
              var i = [];
              this._oldTiles.each(function(e, t) {
                e.isReady() || (e.destroy(), i.push(t))
              });
              for (var s = 0, o = i.length; s < o; s++) this._oldTiles.remove(i[s]);
              this._drawTiles(this._oldTiles, this._element)
            } else this._freeTiles();
          t && (this._viewport = t), this.tiles = new l(e), this.tiles.events.add("ready", this._onTilesReady, this), this.getMap() && this._arrange(!0)
        },
        setViewport: function(e) {
          this._viewport = e, this.getMap() && this._arrange()
        },
        _arrange: function(e) {
          var t, i, l = this.tiles.getTileZoom(),
            o = this.tiles,
            n = this._getTilesDiff(o, this._getTileRange()),
            r = this._element;
          if (n.removed.length || n.added.length) {
            for (s.css(r, {
                visibility: "hidden"
              }), t = 0, i = n.removed.length; t < i; t++) {
              var h = o.get(n.removed[t]);
              h && (o.remove(n.removed[t]), h.destroy())
            }
            for (t = 0, i = n.added.length; t < i; t++) {
              var a = n.added[t],
                h = this.getTile(a, l, a[2]);
              this.tiles.add(a, h), h.renderAt(r, this._layer.numberToClientBounds(a, l), e)
            }
            s.css(r, {
              visibility: ""
            })
          }
        },
        redraw: function(e) {
          if (this.getMap()) {
            var t, i = this.tiles.getTileZoom(),
              s = !1,
              l = !1;
            if (e && (s = e.reload, l = !this.options.get("tileTransparent") && e.animate, t = e.updateBounds ? h.fromPoints(e.updateBounds) : null), this._oldTiles && this._drawTiles(this._oldTiles, this._element, l), this.tiles.each(function(e, o) {
                var n = !t || h.containsPoint(t, o);
                n && (s ? (this.tiles.remove(o), e.destroy()) : e.renderAt(this._element, this._layer.numberToClientBounds(o, i), l))
              }, this), s)
              for (var o = this._getTilesDiff(this.tiles, this._getTileRange()), n = 0, r = o.added.length; n < r; n++) {
                var a = o.added[n],
                  d = this.getTile(a, i, a[2]);
                this.tiles.add(a, d), d.renderAt(this._element, this._layer.numberToClientBounds(a, i), l)
              }
          }
        },
        _drawTiles: function(e, t, i) {
          var s = e.getTileZoom();
          e.each(function(e, l) {
            e.renderAt(t, this._layer.numberToClientBounds(l, s), i)
          }, this)
        },
        _getTileRange: function() {
          return [this._layer.clientPixelsToNumber(this._viewport[0], this.tiles.getTileZoom()), this._layer.clientPixelsToNumber(this._viewport[1], this.tiles.getTileZoom())]
        },
        _getTilesDiff: function(e, t) {
          var i, s, l = {
              added: [],
              removed: []
            },
            o = t[0],
            n = t[1],
            r = n[0] - o[0],
            h = n[1] - o[1],
            a = r + h,
            d = a / r,
            u = a / h,
            _ = Math.round(o[0] + r / 2),
            f = Math.round(o[1] + h / 2);
          for (i = o[0]; i <= n[0]; i++)
            for (s = o[1]; s <= n[1]; s++) e.get([i, s]) || l.added.push([i, s, a - Math.max(d * Math.abs(_ - i), u * Math.abs(f - s))]);
          return e.each(function(e, t) {
            (t[0] < o[0] || t[0] > n[0] || t[1] < o[1] || t[1] > n[1]) && l.removed.push(t)
          }), l
        }
      }), r.add("default#dom", d), e(d)
    });
  }],
  ['.b', function(ym) {
    ym.modules.define("layer.tileContainer.storage", ["util.AsyncStorage"], function(e, n) {
      e(new n)
    });
  }],
  ['.c', function(ym) {
    ym.modules.define("layer.tileContainer.WebGLContainer", ["layer.tileContainer.storage"], function(e, n) {
      n.define("default#webgl", function(e) {
        ym.supports.graphics.hasWebGl() ? ym.modules.require("layer.tileContainer.WebGLContainerImplementation", function(n) {
          e(n)
        }) : e(null, "unsupported")
      }), e("default#webgl")
    });
  }],
  ['5D', function(ym) {
    ym.modules.define("LayerCollection", ["Collection", "layer.storage", "util.defineClass", "util.bind", "vow", "component.ProviderObserver", "component.ZoomRangeObserver"], function(e, t, n, s, r, i, o, h) {
      var g = function(e) {
        g.superclass.constructor.call(this, e), this._zoomRangeObserver = new h(r(this._onZoomRangeProvidersChange, this)), this._copyrightsObserver = new o({
          changeEventType: "copyrightschange",
          changeCallback: r(function() {
            this.events.fire("copyrightschange")
          }, this),
          makeRequest: function(e, t) {
            return e.getCopyrights(t.center, t.zoom)
          }
        }), this._brightness = .5, this._keyLayers = {}
      };
      s(g, t, {
        add: function(e) {
          var t;
          if ("string" == typeof e) {
            var s = n.get(e);
            if (!s && ym.env.debug) throw new Error('LayerCollection.add: layer "' + e + '" does not exist');
            if (this._keyLayers.hasOwnProperty(e)) {
              if (ym.env.debug) throw new Error('LayerCollection.add: layer "' + e + '" is already in collection');
              return this
            }
            t = this._keyLayers[e] = new s
          } else t = e;
          return g.superclass.add.call(this, t), "function" == typeof t.getZoomRange && this._zoomRangeObserver.addProvider(t), "function" == typeof t.getCopyrights && this._copyrightsObserver.addProvider(t), "function" == typeof t.getBrightness && (t.events.add("brightnesschange", this._onChildBrightnessChange, this), this._onChildBrightnessChange()), this
        },
        remove: function(e) {
          var t;
          if ("string" == typeof e) {
            if (this._keyLayers.hasOwnProperty(e)) t = this._keyLayers[e], delete this._keyLayers[e];
            else if (ym.env.debug) throw new Error('LayerCollection.remove: layer "' + e + '" does not exist')
          } else t = e;
          return g.superclass.remove.call(this, t), "function" == typeof t.getZoomRange && this._zoomRangeObserver.removeProvider(t), "function" == typeof t.getCopyrights && this._copyrightsObserver.removeProvider(t), "function" == typeof t.getBrightness && (t.events.remove("brightnesschange", this._onChildBrightnessChange, this), this._onChildBrightnessChange()), this
        },
        _onZoomRangeProvidersChange: function() {
          this.events.fire("zoomrangechange")
        },
        getCopyrights: function() {
          var e = i.defer();
          return this._copyrightsObserver.get({
            center: arguments[0] || this.getMap().getCenter(),
            zoom: arguments[1] || this.getMap().getZoom()
          }).then(function(t) {
            e.resolve([].concat.apply([], t.resolved))
          }, function() {
            e.resolve([])
          }), e.promise()
        },
        getZoomRange: function(e) {
          return this._zoomRangeObserver.get(e || this.getMap().getCenter())
        },
        getBrightness: function() {
          return this._brightness
        },
        _onChildBrightnessChange: function() {
          var e = this._brightness,
            t = this._calculateBrightness();
          e != t && (this._brightness = t, this.events.fire("brightnesschange", {
            newBrightness: t,
            oldBrightness: e
          }))
        },
        _calculateBrightness: function() {
          var e = 0,
            t = 0;
          return this.each(function(n) {
            "function" == typeof n.getBrightness && (e += n.getBrightness(), t++)
          }), t ? e / t : .5
        }
      }), e(g)
    });
  }],
  ['.h', function(ym) {
    ym.modules.define("layout.Base", ["util.defineClass", "Event", "event.Manager", "domEvent.manager", "constants.mapDomEvents"], function(e, t, n, i, s, r) {
      function a(e, t) {
        this._parameters = t || {}, this._data = e, this._parentElement = null, this.events = new i({
          context: this
        });
        var n = !1;
        this.events.addController({
          onBeforeEventFiring: function(e, t) {
            if ("mouseenter" == t) {
              if (n) return !1;
              n = !0
            } else if ("mouseleave" == t) {
              if (!n) return !1;
              n = !1
            }
          }
        })
      }
      t(a, {
        isEmpty: function() {
          return !0
        },
        setData: function(e) {
          this._data = e, this.rebuild()
        },
        getData: function() {
          return this._data
        },
        getParameters: function() {
          return this._parameters
        },
        setParameters: function(e) {
          this._parameters != e && (this.clear(), this._parameters = e, this.build())
        },
        setParentElement: function(e) {
          if (this._parentElement != e) {
            var t = this._parentElement;
            t && this.clear(), this._parentElement = e, this._parentElement && this.build(), this.events.fire("parentelementchange")
          }
        },
        getParentElement: function() {
          return this._parentElement
        },
        build: function() {
          this._parameters.disableDomEventListening || s.add(this._parentElement, r, this.onDomEvent, this)
        },
        clear: function() {
          this._parameters.disableDomEventListening || s.remove(this._parentElement, r, this.onDomEvent, this)
        },
        rebuild: function() {
          this._parentElement && (this.clear(), this.build())
        },
        destroy: function() {},
        onDomEvent: function(e) {
          var t = e.get("type"),
            i = e.get("propagatedData");
          i.firedAs || (i.firedAs = {}), i.firedAs[t] || ("mouseenter" != t && "mouseleave" != t && (i.firedAs[t] = !0), this.events.fire(t, new n({
            type: t,
            target: this,
            domEvent: e
          }, e)))
        }
      }), e(a)
    });
  }],
  ['5O', function(ym) {
    ym.modules.define("layout.define", ["layout.storage"], function(e, n) {
      e(function(e, i, f) {
        function o(e) {
          ym.modules.require(f, function(n) {
            e(n)
          })
        }
        n.isDefined(e) || ("string" == typeof i ? (f = i, n.define(e, o)) : n.define(e, i, o))
      })
    });
  }],
  ['5T', function(ym) {
    var images = ym.modules.importImages({
      defaultImage: {
        src: "defaultImage.png"
      }
    });
    ym.modules.define("layout.Image", ["util.hd", "util.dom.style", "util.dom.element", "domEvent.manager", "Monitor", "templateLayoutFactory", "layout.storage", "shape.Rectangle", "geometry.pixel.Rectangle", "util.shapeFactory", "util.imageLoader", "util.css"], function(e, t, i, a, s, o, r, n, g, h, l, p, d) {
      var m = ym.env.browser.oldIE,
        u = images.get("defaultImage"),
        c = r.createClass('<ymaps class="' + d.addPrefix("image") + '" style="position: absolute;left: {{ options.imageOffset.0|default:-11|raw }}px;top: {{ options.imageOffset.1|default:-38|raw }}px;width: {{ options.imageSize.0|default:34|raw }}px;height: {{ options.imageSize.1|default:41|raw }}px;opacity: {{ options.opacity|default:1|raw }};"></ymaps>', {
          getShape: function() {
            return this._shape && !this._shapeOptionsChanged() || (this._shape = this._createShape()), this._shape
          },
          build: function() {
            c.superclass.build.call(this), this._monitor = new o(this.getData().options).add(["imageClipRect", "imageSize", "imageHref"], this._setupBackground, this, {
              defaultValues: {
                imageHref: u,
                imageSize: [34, 41]
              }
            }), m && (this._badIENode = a.create({
              css: {
                zIndex: -1,
                width: "100%",
                height: "100%",
                overflow: "hidden",
                position: "absolute",
                top: 0,
                left: 0
              }
            }), a.create({
              css: {
                position: "absolute"
              },
              parentNode: this._badIENode
            }), this.getElement().firstChild.appendChild(this._badIENode)), this._setupBackground()
          },
          clear: function() {
            c.superclass.clear.call(this), this._imageHref && p.cancel(this._imageHref, null, this), this._monitor.destroy(), this._imageSrc = this._imageHref = null
          },
          _createShape: function() {
            var e = this.getData().options,
              t = e.get("imageShape") || e.get("shape");
            if (t) return t.type && t.coordinates ? l.create(t) : t;
            var i = e.get("imageOffset", [-11, -38]),
              a = e.get("imageSize", [34, 41]);
            return new g(new h([
              [i[0], i[1]],
              [i[0] + a[0], i[1] + a[1]]
            ]))
          },
          _shapeOptionsChanged: function() {
            var e = ["imageOffset", "imageSize", "shape", "imageShape"],
              t = !1;
            if (this._previousShapeOptions) {
              for (var i = 0, a = e.length; i < a; i++) {
                var s = this.getData().options.get(e[i]);
                this._previousShapeOptions[e[i]] != s && (this._previousShapeOptions[e[i]] = s, t = !0)
              }
              return t
            }
            this._previousShapeOptions = {};
            for (var i = 0, a = e.length; i < a; i++) this._previousShapeOptions[e[i]] = this.getData().options.get(e[i]);
            return !0
          },
          _setupBackground: function(e) {
            var i = e ? t.selectValue(e.imageHref) : t.selectValue(this._monitor.get("imageHref")),
              a = e && e.imageClipRect || this._monitor.get("imageClipRect"),
              s = e && e.imageSize || this._monitor.get("imageSize");
            i !== this._imageHref ? (this._imageHref && p.cancel(this._imageHref, null, this), this._imageHref = i, p.load(i, function(e) {
              this._imageSrc = e, this._onBackgroundImageLoaded(e, i, a, s)
            }, this)) : this._imageSrc && this._onBackgroundImageLoaded(this._imageSrc, i, a, s)
          },
          _onBackgroundImageLoaded: function(e, t, a, s) {
            var o = [e.width, e.height];
            a = a || [
              [0, 0], o
            ];
            var r = [(s || o)[0] / (a[1][0] - a[0][0]), (s || o)[1] / (a[1][1] - a[0][1])],
              n = [o[0] * r[0], o[1] * r[1]],
              g = [-a[0][0] * r[0], -a[0][1] * r[1]];
            if (m) {
              var h = this._badIENode.firstChild;
              i.setSize(h, n), i.setPosition(h, g), i.scaledBackgroundImage(h, t)
            } else i.css(this.getElement().firstChild, {
              backgroundImage: 'url("' + t + '")',
              backgroundSize: n[0] + "px " + n[1] + "px",
              backgroundPosition: g[0] + "px " + g[1] + "px"
            }), s || i.setSize(this.getElement().firstChild, o)
          }
        });
      n.add("default#image", c), e(c)
    });
  }],
  ['5V', function(ym) {
    ym.modules.define("layout.ImageWithContent", ["util.defineClass", "Template", "layout.Image", "layout.templateBased.Base", "layout.storage", "util.css"], function(t, e, a, o, i, n, s) {
      function l(t) {
        i.call(this, t)
      }
      var p, f = '<ymaps class="' + s.addPrefix("image-with-content") + '" style="position: absolute;left: {{ options.imageOffset.0|default:0|raw }}px;top: {{ options.imageOffset.1|default:0|raw }}px;width: {{ options.imageSize.0|default:30|raw }}px;height: {{ options.imageSize.1|default:30|raw }}px;opacity: {{ options.opacity|default:1|raw }};"><ymaps class="' + s.addPrefix("image-with-content-content") + '" style="font: 13px Arial,sans-serif;position: absolute;text-align: center;left: {{ options.contentOffset.0|default:0|raw }}px;top: {{ options.contentOffset.1|default:0|raw }}px;width: {{ options.contentSize.0|default:10|raw }}px;height: {{ options.contentSize.1|default:10|raw }}px;">{% include options.contentLayout %}</ymaps></ymaps>';
      e(l, o, {}, {
        getTemplate: function() {
          return p || (p = new a(f)), p
        }
      }), n.add("default#imageWithContent", l), t(l)
    });
  }],
  ['51', function(ym) {
    ym.modules.define("layout.storage", ["util.AsyncStorage"], function(e, o) {
      e(new o("layout"))
    });
  }],
  ['5N', function(ym) {
    ym.modules.define("layout.SubLayoutEventMappingTable", ["util.defineClass", "constants.mapDomEvents", "Event", "util.array"], function(t, e, n, a, i) {
      function s(t) {
        this._parentLayout = t, i.each(n, function(t) {
          "mousenter" == t || "mouseleave" == t ? this[t] = !1 : this[t] = this._defaultMapping
        }, this), this.parentelementchange = !1, this.emptinesschange = !1, this.shapechange = !1, this["*"] = this._defaultMapping
      }
      e(s, {
        _defaultMapping: function(t) {
          return new a({
            type: t.get("type"),
            target: t.get("target"),
            currentTarget: this._parentLayout
          }, t)
        }
      }), t(s)
    });
  }],
  ['.x', function(ym) {
    ym.modules.define("layout.svgIcon.canvasFactory", ["util.defineClass", "util.dom.svgIconBuilder", "Monitor", "event.Mapper", "event.Manager", "canvasLayout.storage"], function(t, e, n, i, s, a, o) {
      var r = n.isSvgToCanvasSupported();
      (!ym.supports.graphics.hasCanvas() || "MobileSafari" == ym.env.browser.name && parseInt(ym.env.browser.version) < 7) && (r = !1), t({
        hasSupport: function() {
          return r
        },
        defineClass: function(t, e, n) {
          var i = this.createClass(e, n);
          return i && o.add(t, i), i
        },
        createClass: function(t, s) {
          function o(t) {
            this._data = t, this._pictureMonitor = null, this._stateListener = null, this._opacityMonitor = null, this.events = new a({
              context: this
            })
          }
          if (!r) return null;
          var u = t.options || {};
          return u.printable = ym.supports.printPatchNeeded, u.size = u.size || t.size, e(o, {
            build: function() {
              this._setupIcon(), t.hasContent && this._setupContent()
            },
            destroy: function() {
              this.clear()
            },
            clear: function() {
              this._clearIcon()
            },
            getData: function() {
              return this._data
            },
            getOffset: function() {
              return t.offset || [0, 0]
            },
            getShape: function() {
              return t.shape
            },
            getSize: function() {
              return [t.size[0], t.size[1]]
            },
            getTemplate: function() {
              return this.getData().options.get("template")
            },
            isEmpty: function() {
              return !0
            },
            renderLayout: function(e) {
              var n = this._picture.getImage();
              if (n && n.status && n.img.width && e.canvasContext.drawImage(n.img, 0, 0, n.img.width, n.img.height, 0, 0, t.size[0], t.size[1]), t.hasContent) {
                var i = this.getData().properties || {},
                  s = i.get ? i.get("iconContent") : i.iconContent,
                  a = t.contentOffset,
                  o = t.contentSize;
                s && (e.canvasContext.fillStyle = t.textColor || "#000", e.canvasContext.textAlign = "center", e.canvasContext.textBaseline = "middle", e.canvasContext.font = t.font || "13px Arial,sans-serif", e.canvasContext.fillText(s, Math.round(a[0] + o[0] / 2), Math.round(a[1] + o[1] / 2)))
              }
              this._picture.freeImage()
            },
            _setupIcon: function() {
              var t = this.getData().options;
              this._picture = n.getTemplateData(t, this.getTemplate(), null, u), this._pictureMonitor = new i(t).add(["template"].concat(this._picture.usedValues), this._onPictureChange, this), this.getData().properties && "undefined" != typeof this.getData().properties.get && (this._stateListener = new i(this.getData().properties).add(["iconContent"].concat(this._picture.usedValues), this._onContentChange, this)), this._picture.alloc(), this._picture.getImage(this._onContentChange, this)
            },
            _clearIcon: function() {
              this._pictureMonitor.removeAll(), this._stateListener && this._stateListener.removeAll(), this._picture.freeImage(), this._picture.free()
            },
            _onPictureChange: function() {
              this._clearIcon(), this._setupIcon(), this.events.fire("update")
            },
            _onContentChange: function() {
              this.events.fire("update")
            },
            _setupContent: function() {},
            _clearContent: function() {},
            _onContentLayoutChange: function() {
              this._clearContent(), this._setupContent()
            }
          }, s || {}), o
        }
      })
    });
  }],
  ['.y', function(ym) {
    ym.modules.define("layout.svgIcon.factory", ["util.defineClass", "layout.Base", "layout.storage", "util.dom.svgIconBuilder", "Monitor", "util.dom.style", "util.dom.element", "util.dom.className", "event.Mapper", "layout.SubLayoutEventMappingTable", "util.css", "util.cancelableCallback"], function(t, e, n, s, i, a, o, c, l, u, r, h, p) {
      var _ = h.addPrefix("patched-for-print");
      t({
        createClass: function(t, m) {
          function y(t, e) {
            y.superclass.constructor.call(this, t, e), this._contentLayout = null, this._iconElement = null, this._pictureMonitor = null, this._stateListener = null, this._opacityMonitor = null, this._picture = null, this._pictureSeq = 0
          }
          var d = t.hasContent ? ['<ymaps class="' + h.addPrefix("svg-icon-content") + '" style="font: 13px Arial, sans-serif; position: absolute; text-align: center;', "left: ", t.contentOffset[0], "px;", "top: ", t.contentOffset[1], "px;", "width: ", t.contentSize[0], "px;", "height: ", t.contentSize[1], "px;", '"></ymaps>'].join("") : "",
            f = t.options || {};
          return f.printable = ym.supports.printPatchNeeded, f.size = f.size || t.size, e(y, n, {
            build: function() {
              y.superclass.build.call(this), this._iconElement = c.create({
                className: h.addPrefix("svg-icon"),
                position: t.offset,
                size: t.size,
                css: {
                  position: "absolute"
                },
                html: d,
                parentNode: this.getParentElement()
              }), f.className && l.add(this._iconElement, f.className), this._setupIcon(), t.hasContent && this._setupContent(), this._setupOpacityMonitor(), this._setupOpacity()
            },
            clear: function() {
              this._clearOpacityMonitor(), this._clearIcon(), t.hasContent && this._clearContent(), c.remove(this._iconElement), this._lastClassName = null, this._iconElement = null, y.superclass.clear.call(this)
            },
            getShape: function() {
              return t.shape
            },
            getTemplate: function() {
              return this.getData().options.get("template", "islands#icon")
            },
            _setupIcon: function() {
              var t = this.getData().options;
              this._picture = i.getTemplateData(t, this.getTemplate(), null, f), this._pictureMonitor = new a(t).add(["template"].concat(this._picture.usedValues), this._onPictureChange, this), this._pictureSeq && this._pictureSeq.cancel(), this._pictureSeq = p.create(this._onClassSetCallback, this), this._picture.alloc(this._pictureSeq, this)
            },
            _onClassSetCallback: function() {
              var t = this._picture;
              this._pictureSeq = 0, t.className != this._lastClassName && (this._lastClassName && l.remove(this._iconElement, this._lastClassName), l.add(this._iconElement, t.className), ym.supports.printPatchNeeded && l.add(this._iconElement, _), this._lastClassName = t.className)
            },
            _clearIcon: function() {
              this._pictureMonitor.removeAll(), this._pictureSeq && (this._pictureSeq.cancel(), this._pictureSeq = 0), this._picture.free()
            },
            _onPictureChange: function() {
              this._clearIcon(), this._setupIcon()
            },
            _setupContent: function() {
              var t = this.getData().options,
                e = t.get("contentLayout", "islands#geoObjectIconContent");
              "string" == typeof e && (e = s.get(e)), e && (this._contentLayout = new e(this.getData(), this.getParameters()), this._contentLayout.events.setParent(new u(this.events, new r(this))), this._contentLayout.setParentElement(c.findByPrefixedClass(this.getParentElement(), "svg-icon-content"))), this._stateListener = new a(t), this._stateListener.add("contentLayout", this._onContentLayoutChange, this)
            },
            _clearContent: function() {
              this._stateListener.removeAll(), this._contentLayout && (this._contentLayout.setParentElement(null), this._contentLayout.events.setParent(null), this._contentLayout.destroy(), this._contentLayout = null)
            },
            _onContentLayoutChange: function() {
              this._clearContent(), this._setupContent()
            },
            _setupOpacityMonitor: function() {
              this._opacityMonitor = new a(this.getData().options), this._opacityMonitor.add("opacity", this._setupOpacity, this)
            },
            _clearOpacityMonitor: function() {
              this._opacityMonitor.removeAll()
            },
            _setupOpacity: function() {
              var t = this.getData().options.get("opacity");
              "undefined" != typeof t && o.css(this._iconElement, {
                opacity: t
              })
            }
          }, m || {}), y
        }
      })
    });
  }],
  [':p', function(ym) {
    ym.modules.define("layout.templateBased.Base", ["util.defineClass", "layout.Base", "util.dom.element", "util.dom.style", "util.extend", "util.array", "util.bind", "Event", "util.ContentSizeObserver", "event.Manager", "data.Manager", "data.Aggregator", "Monitor", "constants.mapDomEvents", "layout.storage", "event.Mapper", "layout.SubLayoutEventMappingTable", "localization.common.current", "util.shapeFactory", "util.cancelableCallback"], function(e, t, a, s, n, i, r, o, u, l, h, c, p, _, m, g, d, y, b, f, v) {
      function S(e, t) {
        S.superclass.constructor.call(this, e, t), this._renderedTemplate = null, this._sublayouts = null, this._oldShape = null, this._setupTemplateDataManager(e), this._sublayoutsEmptiness = this.calculateSublayoutsEmptiness(), this._emptiness = this.calculateEmptiness(), this.init()
      }

      function M(e) {
        this._layout = e, this._monitors = {}
      }

      function E(e) {
        this._layout = e, this._observers = {}, this._csoListeners = {}, this._layoutChangeListeners = {}
      }
      t(S, a, {
        init: function() {},
        setData: function(e) {
          this._clearTemplateDataManager(), this._setupTemplateDataManager(e), S.superclass.setData.call(this, e)
        },
        getTemplate: function() {},
        createTemplateDataManager: function(e) {
          return new p(i({
            localization: new c(b)
          }, e))
        },
        destroyTemplateDataManager: function(e) {
          e.destroy()
        },
        getSublayout: function(e) {
          for (var t = this._getSublayouts(), a = 0, s = t.length; a < s; a++)
            if (t[a].name == e) return t[a].instance;
          return null
        },
        getElement: function() {
          return this._element
        },
        build: function() {
          this._element = s.create({
            html: this._getRenderedTemplate().text,
            parentNode: this.getParentElement()
          }), this._appendSubnodes(), this._appendSublayouts(), S.superclass.build.call(this)
        },
        clear: function() {
          S.superclass.clear.call(this), this._clearSublayoutsParamsMonitorsManager(), this._clearSublayoutsSizeObserveManager(), this._clearSublayouts(), s.destroy(this._element), this._element = null
        },
        rebuild: function() {
          this._freezeTemplateDataManager(), this.getParentElement() && this.clear(), this._destroySublayouts(), this._render(), this._createSublayouts(), this._updateEmptiness(), this.getParentElement() && this.build(), this._initSublayoutsSizeObserveManager(), this._fireChange(), this.testShapeChange(), this._unfreezeTemplateDataManager()
        },
        isEmpty: function() {
          return this._emptiness
        },
        areSublayoutsEmpty: function() {
          return this._sublayoutsEmptiness
        },
        calculateEmptiness: function() {
          return this.isTemplateEmpty() && this.areSublayoutsEmpty()
        },
        isTemplateEmpty: function() {
          return this._getRenderedTemplate().empty
        },
        calculateSublayoutsEmptiness: function() {
          for (var e = this._getSublayouts(), t = 0, a = e.length; t < a; t++) {
            var s = e[t];
            if (s.isLoaded && !s.instance.isEmpty()) return !1
          }
          return !0
        },
        _updateEmptiness: function() {
          var e = this._emptiness;
          this._emptiness = this.calculateEmptiness(), e != this._emptiness && (this.onEmptinessChange(), this.events.fire("emptinesschange"))
        },
        onEmptinessChange: function() {},
        _updateSublayoutsEmptiness: function() {
          var e = this._sublayoutsEmptiness;
          this._sublayoutsEmptiness = this.calculateSublayoutsEmptiness(), e != this._sublayoutsEmptiness && (this.onSublayoutsEmptinessChange(), this._updateEmptiness())
        },
        onSublayoutsEmptinessChange: function() {},
        getShape: function() {
          return this._shape && !this._shapeOptionsChanged() || (this._shape = this._createShape()), this._shape
        },
        _shapeOptionsChanged: function() {
          var e = this.getData().options.get("shape");
          return this._previousShapeOption != e && (this._previousShapeOption = e, !0)
        },
        _createShape: function() {
          if (this.getData() && this.getData().options) {
            var e = this.getData().options.get("shape");
            if (e) return e.type && e.coordinates ? f.create(e) : e
          }
          return null
        },
        onDataChange: function() {
          this._testValuesChanges() ? this.rebuild() : this._sublayouts && this._testSublayoutChanges()
        },
        _fireChange: function() {
          this.events.fire("change")
        },
        onSublayoutSizeChange: function(e, t) {
          n.css(e.instance.getParentElement(), {
            display: "block",
            width: Math.max(t.width, e.params.minWidth || 0) + "px",
            height: Math.max(t.height, e.params.minHeight || 0) + "px",
            overflowX: t.scrollX ? "auto" : "hidden",
            overflowY: t.scrollY ? "auto" : "hidden"
          }), this.testShapeChange()
        },
        destroy: function() {
          this.getParentElement() && this.clear(), this._destroySublayouts(), this._clearTemplateDataManager()
        },
        setParentElement: function(e) {
          this._renderedTemplate || (this._render(), this._createSublayouts()), this._freezeTemplateDataManager();
          var t = this._parentElement != e;
          S.superclass.setParentElement.call(this, e), t && (this._initSublayoutsSizeObserveManager(), this.testShapeChange()), this._unfreezeTemplateDataManager()
        },
        testShapeChange: function() {
          var e = this._oldShape,
            t = this.getShape();
          (!!e != !!t || e && t && !e.equals(t)) && (this._oldShape = t, this.events.fire("shapechange"))
        },
        _clearSublayouts: function() {
          for (var e = this._getSublayouts(), t = 0, a = e.length; t < a; t++) {
            var s = e[t];
            if (s.isLoaded) {
              var n = e[t].instance;
              n.getParentElement() && n.setParentElement(null)
            }
          }
        },
        _render: function() {
          this._renderedTemplate = this.getTemplate().build(this._templateDataManager)
        },
        _createSublayouts: function() {
          var e = this._getRenderedTemplate().sublayouts;
          this._sublayouts = [];
          for (var t = 0, a = e.length; t < a; t++) {
            var s = e[t],
              n = s.value,
              i = g.get(n, this.getData()),
              r = "undefined" != typeof i,
              o = {
                isLoaded: r,
                storageKey: n,
                key: s.key,
                id: s.id,
                name: s.name || s.id,
                params: s
              };
            r ? (o.instance = this._createSublayoutInstance(i), o.value = i) : this._createSublayoutRequest(o), this._sublayouts.push(o)
          }
        },
        _createSublayoutRequest: function(e) {
          var t = v.create(function(t) {
            e.isLoaded = !0, e.instance = this._createSublayoutInstance(t), e.value = t, this._element && this._appendSublayout(e), this._updateSublayoutsEmptiness(), this._initSublayoutsSizeObserveManager(), this.testShapeChange(), this._fireChange()
          }, this);
          g.require({
            keys: [e.storageKey],
            data: this.getData()
          }).spread(t).done(), e.onLoadCallback = t
        },
        _destroySublayouts: function() {
          if (this._sublayouts) {
            for (var e = 0, t = this._sublayouts.length; e < t; e++) {
              var a = this._sublayouts[e];
              a.isLoaded ? this._destroySublayoutInstance(a.instance) : a.onLoadCallback.cancel()
            }
            this._sublayouts = null
          }
        },
        _createSublayoutInstance: function(e) {
          if (ym.env.debug && "function" != typeof e) throw new Error("layout.templateBased.Base._createSublayoutInstance: Не удалось получить класс вложенного макета.");
          var t = new e(this.getData(), this.getParameters());
          return t.events.setParent(new d(this.events, this.createSubLayoutEventMappingTable())).add("emptinesschange", this.onSublayoutEmptinessChange, this).add("shapechange", this.testShapeChange, this), t
        },
        _destroySublayoutInstance: function(e) {
          e.events.remove("emptinesschange", this.onSublayoutEmptinessChange, this).remove("shapechange", this.testShapeChange, this).setParent(null), e.destroy()
        },
        createSubLayoutEventMappingTable: function() {
          return new y(this)
        },
        onSublayoutEmptinessChange: function() {
          this._updateSublayoutsEmptiness()
        },
        _appendSubnodes: function() {
          for (var e = this._getRenderedTemplate().subnodes, t = 0, a = e.length; t < a; t++) {
            var s = e[t],
              n = document.getElementById(s.parentId);
            n.appendChild(s.element)
          }
        },
        _appendSublayouts: function() {
          for (var e = this._getSublayouts(), t = 0, a = e.length; t < a; t++) {
            var s = e[t];
            s.isLoaded && this._appendSublayout(s)
          }
        },
        _appendSublayout: function(e) {
          e.instance.setParentElement(document.getElementById(e.id)), e.params.monitorValues.length && (this._pmManager || this._setupSublayoutsParamsMonitorsManager(), this._pmManager.add(e)), e.params.observeSize && (this._ssoManager || this._setupSublayoutsSizeObserveManager(), this._ssoManager.add(e))
        },
        _clearSublayout: function(e) {
          this._ssoManager && this._ssoManager.remove(e.name), this._pmManager && this._pmManager.remove(e.name), e.instance.setParentElement(null)
        },
        _removeSublayout: function(e) {
          this._clearSublayout(e), this._destroySublayoutInstance(e.instance)
        },
        _setupSublayoutsParamsMonitorsManager: function() {
          this._pmManager = new M(this)
        },
        _clearSublayoutsParamsMonitorsManager: function() {
          this._pmManager && (this._pmManager.destroy(), this._pmManager = null)
        },
        _setupSublayoutsSizeObserveManager: function() {
          this._ssoManager = new E(this)
        },
        _clearSublayoutsSizeObserveManager: function() {
          this._ssoManager && (this._ssoManager.destroy(), this._ssoManager = null)
        },
        _initSublayoutsSizeObserveManager: function() {
          this._ssoManager && this._ssoManager.init()
        },
        _setupTemplateDataManager: function(e) {
          this._templateDataManager = this.createTemplateDataManager(e), this._templateDataManager.events.add("change", this.onDataChange, this)
        },
        _clearTemplateDataManager: function() {
          this._templateDataManager.events.remove("change", this.onDataChange, this), this.destroyTemplateDataManager(this._templateDataManager)
        },
        _freezeTemplateDataManager: function() {
          this._templateDataManager && this._templateDataManager.freeze()
        },
        _unfreezeTemplateDataManager: function() {
          this._templateDataManager && this._templateDataManager.unfreeze()
        },
        _testValuesChanges: function() {
          if (!this._renderedTemplate) return !1;
          var e = this._renderedTemplate.renderedValues,
            t = this._templateDataManager;
          for (var a in e)
            if (e.hasOwnProperty(a) && e[a].value !== t.get(a)) return !0;
          return !1
        },
        _testSublayoutChanges: function() {
          for (var e, t, a = !1, s = this._getSublayouts(), n = 0, i = s.length; n < i; n++) {
            e = s[n];
            var r = this._templateDataManager.get(e.key);
            "undefined" != typeof r && (t = g.get(r, this.getData()), t ? t !== e.value && (e.isLoaded ? this._removeSublayout(e) : (e.onLoadCallback.cancel(), delete e.onLoadCallback), e.isLoaded = !0, e.value = t, e.instance = this._createSublayoutInstance(e.value), this._appendSublayout(e), a = !0) : (e.instance && this._removeSublayout(e), delete e.instance, delete e.value, e.isLoaded || e.onLoadCallback.cancel(), a = !0, e.isLoaded = !1, e.storageKey = r, this._createSublayoutRequest(e)))
          }
          a && this._fireChange()
        },
        _getRenderedTemplate: function() {
          return this._renderedTemplate || this._render(), this._renderedTemplate
        },
        _getSublayouts: function() {
          return this._sublayouts || this._createSublayouts(), this._sublayouts
        }
      }), M.prototype = {
        add: function(e) {
          this.remove(e.name), this._monitors[e.name] = new _(this._layout._templateDataManager).add(e.params.monitorValues, this._layout.rebuild, this._layout)
        },
        remove: function(e) {
          this._monitors[e] && this._monitors[e].removeAll()
        },
        destroy: function() {
          r.each(this._monitors, function(e, t) {
            this.remove(t)
          }, this)
        }
      }, E.prototype = {
        init: function() {
          for (var e in this._observers) this._observers.hasOwnProperty(e) && this.observe(e)
        },
        add: function(e) {
          function t(e, t) {
            return e = "undefined" != typeof e ? e : t, isNaN(e) ? t : e
          }
          var a = e.name,
            s = e.params;
          this.remove(a), this._observers[a] = new l(e.instance.getParentElement(), {
            maxWidth: t(s.maxWidth, 1 / 0),
            maxHeight: t(s.maxHeight, 1 / 0),
            scrollX: "undefined" == typeof s.scrollX || s.scrollX,
            scrollY: "undefined" == typeof s.scrollY || s.scrollY
          }), this._csoListeners[a] = this._observers[a].events.group().add("sizechange", function(t) {
            this._layout.onSublayoutSizeChange(e, t.get("sizeByContent"))
          }, this), this._layoutChangeListeners[a] = e.instance.events.group().add("change", function() {
            this.observe(a)
          }, this)
        },
        remove: function(e) {
          this._observers[e] && this._observers[e].destroy(), this._csoListeners[e] && this._csoListeners[e].removeAll(), this._layoutChangeListeners[e] && this._layoutChangeListeners[e].removeAll()
        },
        observe: function(e) {
          this._observers[e] && this._observers[e].observe()
        },
        destroy: function() {
          r.each(this._observers, function(e, t) {
            this.remove(t)
          }, this)
        }
      }, e(S)
    });
  }],
  ['!K', function(ym) {
    ym.modules.define("LoadingObjectManager", ["util.defineClass", "event.Manager", "BaseObjectManager", "objectManager.component.OnceLoadingDataController", "objectManager.component.View", "objectManager.ObjectCollection", "objectManager.ClusterCollection", "component.child.MapChild", "objectManager.component.ObjectControllerAddon", "objectManager.component.TileSource", "util.extend", "Event", "yandex.counter"], function(e, t, n, o, a, s, r, l, i, d, c, h, u, g) {
      var C = function(e, t) {
        this._urlTemplate = e, this.events = new n({
          context: this
        }), this._mapChildComponent = new i({
          onMapChange: {
            callback: this._onMapChange,
            context: this
          },
          onParentChange: {
            callback: this._onParentChange,
            context: this
          }
        }), this._objectsEditingEventManager = new n, this._clustersEditingEventManager = new n, this.objects = new r(this, this._objectsEditingEventManager), this.clusters = new l(this, this._clustersEditingEventManager), this._tileSource = new c(this), C.superclass.constructor.call(this, t, {
          objects: this.objects,
          clusters: this.clusters,
          events: this.events,
          addDisplayedObjects: {
            callback: this._addObjects,
            context: this
          },
          removeDisplayedObjects: {
            callback: this._removeObjects,
            context: this
          },
          removeAll: {
            callback: this._removeAllObjects,
            context: this
          }
        }), this._view = null, this._dataLoadController = null, this._dataLoadControllerListener = null, this._objectControllerAddon = new d(this), g.countByKey("modulesUsage", "loadingObjectManager.create")
      };
      t(C, o, {
        setUrlTemplate: function(e) {
          this._urlTemplate = e
        },
        getUrlTemplate: function() {
          return this._urlTemplate
        },
        getTileUrl: function(e) {
          return this._tileSource.getTileUrl(e)
        },
        getPadding: function(e) {
          return this._tileSource.getPadding(e)
        },
        getMap: function() {
          return this._mapChildComponent.getMap()
        },
        getParent: function() {
          return this._mapChildComponent.getParent()
        },
        setParent: function(e) {
          return this._mapChildComponent.setParent(e), this
        },
        onAddToMap: function(e) {
          this._setupView(), this._objectControllerAddon.setMap(e), this._objectControllerAddon.events.add("statechange", this._onObjectControllerStateChange, this), this._setupDataLoadController(), C.superclass.onAddToMap.call(this, e)
        },
        onRemoveFromMap: function(e) {
          C.superclass.onRemoveFromMap.call(this, e), this._clearDataLoadController(), this._objectControllerAddon.events.remove("statechange", this._onObjectControllerStateChange, this), this._objectControllerAddon.setMap(null), this._clearView()
        },
        getObjectState: function(e) {
          var t = C.superclass.getObjectState.call(this, e),
            n = this._objectControllerAddon.getController(),
            o = n && n.getObjectState(e);
          return o && (t = h(t, o)), t
        },
        reloadData: function() {
          this._dataLoadController && this._dataLoadController.reloadData()
        },
        getBounds: function() {
          return this._dataLoadController && this.objects.getLength() ? this._dataLoadController.getBounds() : null
        },
        getPixelBounds: function() {
          return this._dataLoadController ? this._dataLoadController.getPixelBounds() : null
        },
        _setupDataLoadController: function() {
          this._dataLoadController = new a(this), this._dataLoadControllerListener = this._dataLoadController.events.group().add("statechange", this._onDataLoadControllerStateChange, this).add("pixelboundschange", this._onDataLoadControllerBoundsChange, this)
        },
        _clearDataLoadController: function() {
          this._dataLoadControllerListener.removeAll(), this._dataLoadController.destroy()
        },
        _onDataLoadControllerStateChange: function(e) {
          var t = e.get("removed"),
            n = e.get("added");
          t && this.objects.remove(t), n && this.objects.add(n)
        },
        _onDataLoadControllerBoundsChange: function() {
          this.events.fire("pixelboundschange")
        },
        _setupView: function() {
          this._view = new s(this, this._objectsEditingEventManager, this._clustersEditingEventManager)
        },
        _clearView: function() {
          this._view.destroy()
        },
        _onMapChange: function(e, t) {
          e && this.onRemoveFromMap(e), t && this.onAddToMap(t), this.events.fire("mapchange", {
            oldMap: e,
            newMap: t
          })
        },
        _onParentChange: function(e, t) {
          t && this.options.setParent(t.options), this.events.fire("parentchange", {
            oldParent: e,
            newParent: t
          }), t || this.options.setParent(null)
        },
        _addObjects: function(e) {
          this._objectControllerAddon.getController().add(e)
        },
        _removeObjects: function(e) {
          this._objectControllerAddon.getController().remove(e)
        },
        _removeAllObjects: function(e) {
          this._objectControllerAddon.getController().removeAll()
        },
        _onObjectControllerStateChange: function(e) {
          var t = e.get("removedClusters"),
            n = e.get("addedClusters");
          t && t.length && this._clustersEditingEventManager.fire("remove", new u({
            target: this,
            type: "remove",
            clusters: t
          })), n && n.length && this._clustersEditingEventManager.fire("add", new u({
            target: this,
            type: "add",
            clusters: n
          })), this._fireStateChange({
            added: e.get("added"),
            removed: e.get("removed"),
            addedClusters: e.get("addedClusters"),
            removedClusters: e.get("removedClusters"),
            update: e.get("update"),
            sync: e.get("sync")
          })
        },
        _fireStateChange: function(e) {
          this.events.fire("statechange", {
            added: e.added || [],
            removed: e.removed || [],
            addedClusters: e.addedClusters || [],
            removedClusters: e.removedClusters || [],
            update: e.update || [],
            sync: e.sync
          })
        }
      }), e(C)
    });
  }],
  ['.E', function(ym) {
    ym.modules.define("localization.common.current", function(n) {
      return ["localization.common." + n.env.lang.substr(0, 2)]
    }, function(n, o) {
      n(o || {})
    });
  }],
  ['.M', function(ym) {
    ym.modules.define("localization.common.ru", [], function(e) {
      e({
        Balloon: {
          close: "Закрыть"
        },
        Control: {
          ListBox: {
            Collapse: "Свернуть",
            Expand: "Развернуть"
          },
          MiniMap: {
            hide: "Скрыть обзорную карту",
            show: "Показать обзорную карту"
          },
          Ruler: {
            close: "Удалить путь",
            sure: "Удалить все отметки? \\n\\n(для удаления только одной отметки\\n дважды щелкните по ней)"
          },
          Search: {
            clear: "Очистить",
            correction: "В запросе исправлена опечатка.<br/>Результаты для «%s»",
            error: "Сервер не смог обработать запрос",
            found: ["Найден %d объект", "Найдено %d объекта", "Найдено %d объектов", "Найдено %d объектов"],
            loadMore: ["Ещё %d результат", "Ещё %d результата", "Ещё %d результатов", "Ещё %d результатов"],
            next: ["Следующий %d", "Следующие %d", "Следующие %d", "Следующие %d"],
            noname: "Без названия",
            notFound: "По запросу ничего не найдено",
            object: ["объект", "объекта", "объектов", "объектов"],
            of: "из",
            previous: ["Предыдущий %d", "Предыдущие %d", "Предыдущие %d", "Предыдущие %d"],
            search: "Найти",
            searchLegend: "Адрес или объект",
            wait: "Идет запрос к серверу"
          },
          ToolBar: {
            drag: "Переместить карту",
            geolocation: "Определить Ваше местоположение",
            geolocationError: "Не получается определить Ваше местоположение",
            geolocationSuccess: "Ваше месторасположение",
            info: "Получить информацию",
            magnifier: "Увеличить",
            ruler: "Измерение расстояний на карте"
          },
          TypeControl: {
            layers: "Слои",
            mapType: "Тип карты",
            more: "Ещё"
          },
          Zoom: {
            city: "город",
            country: "страна",
            house: "дом",
            street: "улица",
            world: "мир"
          }
        },
        Copyrights: {
          agreement: "Условия использования",
          agreementCompact: "Условия",
          agreementLink: "http://yandex.ru/legal/maps_termsofuse/",
          edit: '<a href="http://n.maps.yandex.ru" style="font-weight: bold !important;" target="_blank">Редактировать Народную карту</a>',
          editCompact: '<a href="http://n.maps.yandex.ru" style="font-weight: bold !important;" target="_blank">Народная карта</a>',
          feedback: "",
          feedbackTemplate: "",
          logoLang: "ru",
          logoLink: "http://maps.yandex.ru",
          osm: '© Участники <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>',
          yandex: '© <a href="http://maps.yandex.ru">Яндекс</a>'
        },
        DaysOfWeek: {
          fri: "пт",
          friday: "пятница",
          mon: "пн",
          monday: "понедельник",
          onFri: "в пт",
          onMon: "в пн",
          onSat: "в сб",
          onSun: "в вс",
          onThu: "в чт",
          onTue: "во вт",
          onWed: "в ср",
          sat: "сб",
          saturday: "суббота",
          sun: "вс",
          sunday: "воскресенье",
          thu: "чт",
          thursday: "четверг",
          tue: "вт",
          tuesday: "вторник",
          wed: "ср",
          wednesday: "среда"
        },
        Editor: {
          addInterior: "Добавить внутренний контур",
          removeInterior: "Удалить контур",
          removeVertex: "Удалить",
          startDrawing: "Продолжить",
          stopDrawing: "Завершить"
        },
        MapType: {
          hybrid: "Гибрид",
          map: "Схема",
          peoplesHybrid: "Народная + спутник",
          peoplesMap: "Народная карта",
          satellite: "Спутник"
        },
        PeopleMap: {
          house: "Здание",
          hydro: "Водоем, участок реки",
          locality: "Населённый пункт",
          noname: "Без названия",
          other: "Другое",
          phybrid: "Гибрид",
          pmap: "Схема",
          railway: "Участок железной дороги",
          street: "Участок дороги",
          vegetation: "Лес, парк"
        },
        Traffic: {
          address: "Адрес",
          archiveDataText: "На основе статистики Яндекс.Пробок",
          archiveProvider: "обычно",
          brownJam: "Движение перекрыто",
          chooseCity: "Выберите город ",
          description: "Описание",
          eventType0: "Дорожные работы",
          eventType1: "ДТП",
          eventType2: "Развод моста",
          eventType3: "Перекрытие движения",
          eventType4: "Камера",
          eventType5: "Прочее",
          expectedOn: "ожидается в %t",
          forTheNearFuture: "На ближайшее время",
          forecast: "Прогноз",
          forecastData: "На основе прогноза пробок",
          forecastDataText: "На основе прогноза Яндекс.Пробок",
          greenJam: "Свободно",
          inAnHour: "через час",
          infoLayer: "Дорожные события",
          jams: "Пробки",
          later: "потом",
          length: "Длина",
          level0: "На дорогах свободно",
          level1: "На дорогах свободно",
          level10: "Пешком быстрее",
          level2: "Дороги почти свободны",
          level3: "Местами затруднения",
          level4: "Местами затруднения",
          level5: "Движение плотное",
          level6: "Движение затруднено",
          level7: "Серьёзные пробки",
          level8: "Многокилометровые пробки",
          level9: "Город стоит",
          noData: "Данные о пробках недоступны",
          noForecastHere: "На этой территории нет прогноза пробок.",
          noRegion: "Нет данных о пробках в этом регионе",
          noStatisticsHere: "На этой территории нет статистики пробок.",
          noTimeZone: "Данные о пробках отсутствуют",
          now: "сейчас",
          nowOn: "сейчас, в %t",
          onOtherDays: "На другие дни",
          points: ["%d балл", "%d балла", "%d баллов", "%d баллов"],
          redJam: "Пробка",
          seeCurrentTrafficJams: "Посмотреть текущие пробки.",
          source: "Источник",
          statistics: "Статистика",
          statisticsData: "На основе статистики пробок",
          statisticsHint: "Статистика основана на информации о пробках за последние два месяца",
          time: "Дата",
          times: "Сроки",
          today: "Сегодня",
          trafficBlocked: "движение перекрыто",
          usuallyOn: "обычно в %s, %t",
          yellowJam: "Движение затруднено",
          zoomToWatch: '<a href="javascript:void(0)">Увеличьте масштаб</a>, чтобы увидеть пробки'
        },
        Unit: {
          centimetreAbbr: "см.",
          dayAbbr: ["д.", "дн.", "дн.", "дн."],
          hourAbbr: "ч.",
          kilometreAbbr: "км.",
          kmh: "км/ч",
          metreAbbr: "м",
          minuteAbbr: "мин.",
          secondAbbr: "с"
        },
        distribution: {
          badgeUpdateBrowserInfoMessage: '<a href="https://tech.yandex.ru/maps/doc/jsapi/updating-browsers/index-docpage/?from=$[from]" target="_blank">[?]</a>',
          badgeUpdateBrowserMessage: "Обновите браузер",
          badgeYaBrowserLink: '<a href="https://browser.yandex.ru/?from=link_maps___&banerid=0408000000" target="_blank">$[messages.message]</a>',
          badgeYaBrowserMobileAndroidCounter: "http://appmetrika.yandex.ru/serve/7778453801303976883?action=click&app_id=com.yandex.browser",
          badgeYaBrowserMobileAndroidLink: '<a href="market://details?id=com.yandex.browser" target="_blank">$[messages.message]</a>',
          badgeYaBrowserMobileIOsLink: '<a href="https://itunes.apple.com/ru/app/andeks.brauzer/id574939428?mt=8" target="_blank">$[messages.message]</a>',
          badgeYaBrowserTabletAndroidCounter: "http://appmetrika.yandex.ru/serve/3382077458904646597?action=click&app_id=com.yandex.browser",
          badgeYaBrowserTabletAndroidLink: '<a href="market://details?id=com.yandex.browser" target="_blank">$[messages.message]</a>',
          bandMessage: 'Ваш браузер устарел. Пожалуйста, обновите браузер (<a href="https://tech.yandex.ru/maps/doc/jsapi/updating-browsers/index-docpage/?from=$[from]" target="_blank">подробнее</a>) или установите',
          openRoute: "Открыть маршрут",
          panoramas: 'К сожалению, нам не удалось запустить Яндекс.Панорамы на вашем устройстве (<a href="https://tech.yandex.ru/maps/doc/jsapi/updating-browsers/index-docpage/?from=$[from]" target="_blank">подробнее</a>).',
          routeOpenInMaps: "Подробнее",
          searchInYandex: "Поискать в",
          unavailable: 'Здесь должна быть карта.<br/>К сожалению, мы не можем отобразить её в вашем браузере.<br/>Но вы можете попытаться просмотреть её<br/>в <a href="{{ href }}" target="_blank">Мобильных Яндекс.Картах</a>.',
          yaBrowser: '<a class="ya-distrib-browser"  target="_blank" href="https://browser.yandex.ru/?from=link_maps___&banerid=0408000000">Яндекс.Браузер</a>',
          yaBrowserMobileAndroid: '<a href="market://details?id=com.yandex.browser" data-counter="http://appmetrika.yandex.ru/serve/7778453801303976883?action=click&app_id=com.yandex.browser" class="ya-distrib-browser" target="_blank">Я.Браузер</a>',
          yaBrowserMobileIOs: '<a href="https://itunes.apple.com/ru/app/andeks.brauzer/id574939428?mt=8" class="ya-distrib-browser" >Я.Браузер</a>',
          yaBrowserTabletAndroid: '<a href="market://details?id=com.yandex.browser" data-counter="http://appmetrika.yandex.ru/serve/3382077458904646597?action=click&app_id=com.yandex.browser" class="ya-distrib-browser" target="_blank">Я.Браузер</a>',
          yaMapsAndroidLink: "intent://maps.yandex.ru/{parameters}#Intent;scheme=http;package=ru.yandex.yandexmaps;S.browser_fallback_url={fallback_url};end",
          yaMapsIOsLink: "yandexmaps://maps.yandex.ru/",
          yaMapsIOsRouteLink: "yandexmaps://build_route_on_map/",
          yaMapsIOsServiceLink: "http://go.onelink.me/id313877526?pid=api-maps&c=text&af_dp={url-scheme}",
          yaOpenInMaps: "Открыть в Яндекс.Картах",
          yandexLink: "https://yandex.ru/search?text={text}&from=mapsapi"
        },
        geoXml: {
          Latitude: "Широта",
          Longitude: "Долгота",
          Time: "Время",
          Velocity: "Скорость"
        },
        geocode: {
          area: "",
          country: "",
          district: "",
          house: "",
          locality: "",
          metro: "",
          province: "",
          street: ""
        },
        jsonp: {
          scriptError: "Ошибка при загрузке скрипта",
          timeoutExceeded: "Превышен интервал ожидания ответа от сервера"
        },
        layer: {
          tileNotFound: "Для этого участка местности нет данных.<br/>Попробуйте перейти на масштаб выше<br/>или выбрать другое место на карте."
        },
        masstransit: {
          "human-duration": '<i18n:dynamic>\n    <i18n:xsl>\n        <xsl:param name="duration" select="0"/>\n        <xsl:variable name="days" select="floor($duration div 86400)"/>\n        <xsl:variable name="hours" select="floor($duration mod 86400 div 3600)"/>\n        <xsl:variable name="minutes" select="ceiling($duration mod 3600 div 60)"/>\n        <xsl:if test="$days">\n            <xsl:value-of select="$days"/>\n            <xsl:choose>\n                <xsl:when test="$days = 1"> д. </xsl:when>\n                <xsl:otherwise> дн. </xsl:otherwise>\n            </xsl:choose>\n        </xsl:if>\n        <xsl:if test="$days &lt; 20 and $hours">\n            <xsl:value-of select="$hours"/>\n            <xsl:text> ч. </xsl:text>\n        </xsl:if>\n        <xsl:if test="$days = 0 and $hours &lt; 20 and $minutes">\n            <xsl:value-of select="$minutes"/>\n            <xsl:text> мин. </xsl:text>\n        </xsl:if>\n    </i18n:xsl>\n</i18n:dynamic>',
          quote: "<i18n:dynamic>\n    <i18n:xsl>\n        <xsl:param name=\"text\"/>\n        <xsl:value-of select=\"concat('«', re:replace($text, '&quot;([^&quot;]+)&quot;', 'g', '„$1“'), '»')\" xmlns:re=\"http://exslt.org/regular-expressions\"/>\n    </i18n:xsl>\n</i18n:dynamic>",
          "transport-aeroexpress": '<i18n:dynamic project="tanker" keyset="dynamic" key="gender">\n    <i18n:gender><i18n:param>gender</i18n:param></i18n:gender>\n    <i18n:masculine>Аэроэкспресс</i18n:masculine>\n    <i18n:plural>Аэроэкспрессы</i18n:plural>\n</i18n:dynamic>',
          "transport-bus": '<i18n:dynamic project="tanker" keyset="dynamic" key="gender">\n    <i18n:gender><i18n:param>gender</i18n:param></i18n:gender>\n    <i18n:masculine>Автобус</i18n:masculine>\n    <i18n:plural>Автобусы</i18n:plural>\n</i18n:dynamic>',
          "transport-cable": '<i18n:dynamic project="tanker" keyset="dynamic" key="gender">\n    <i18n:gender><i18n:param>gender</i18n:param></i18n:gender>\n    <i18n:masculine>Канатная дорога</i18n:masculine>\n    <i18n:plural>Канатные дороги</i18n:plural>\n</i18n:dynamic>',
          "transport-dolmus": '<i18n:dynamic project="tanker" keyset="dynamic" key="gender">\n    <i18n:gender><i18n:param>gender</i18n:param></i18n:gender>\n    <i18n:masculine>Долмуш</i18n:masculine>\n    <i18n:plural>Долмуш</i18n:plural>\n</i18n:dynamic>',
          "transport-ferry": '<i18n:dynamic project="tanker" keyset="dynamic" key="gender">\n    <i18n:gender><i18n:param>gender</i18n:param></i18n:gender>\n    <i18n:masculine>Паром</i18n:masculine>\n    <i18n:plural>Паромы</i18n:plural>\n</i18n:dynamic>',
          "transport-funicular": '<i18n:dynamic project="tanker" keyset="dynamic" key="gender">\n    <i18n:gender><i18n:param>gender</i18n:param></i18n:gender>\n    <i18n:masculine>Фуникулёр</i18n:masculine>\n    <i18n:plural>Фуникулёры</i18n:plural>\n</i18n:dynamic>',
          "transport-historic_tram": '<i18n:dynamic project="tanker" keyset="dynamic" key="gender">\n    <i18n:gender><i18n:param>gender</i18n:param></i18n:gender>\n    <i18n:masculine>Трамвай</i18n:masculine>\n    <i18n:plural>Трамваи</i18n:plural>\n</i18n:dynamic>',
          "transport-metrobus": '<i18n:dynamic project="tanker" keyset="dynamic" key="gender">\n    <i18n:gender><i18n:param>gender</i18n:param></i18n:gender>\n    <i18n:masculine>Метробус</i18n:masculine>\n    <i18n:plural>Метробусы</i18n:plural>\n</i18n:dynamic>',
          "transport-minibus": '<i18n:dynamic project="tanker" keyset="dynamic" key="gender">\n    <i18n:gender><i18n:param>gender</i18n:param></i18n:gender>\n    <i18n:masculine>Маршрутка</i18n:masculine>\n    <i18n:plural>Маршрутки</i18n:plural>\n</i18n:dynamic>',
          "transport-number": '<i18n:dynamic project="tanker" keyset="dynamic" key="gender">\n    <i18n:gender><i18n:param>gender</i18n:param></i18n:gender>\n    <i18n:masculine>№</i18n:masculine>\n    <i18n:plural>№№</i18n:plural>\n</i18n:dynamic>&#160;',
          "transport-railway": '<i18n:dynamic project="tanker" keyset="dynamic" key="gender">\n    <i18n:gender><i18n:param>gender</i18n:param></i18n:gender>\n    <i18n:masculine>Электричка</i18n:masculine>\n    <i18n:plural>Электрички</i18n:plural>\n</i18n:dynamic>',
          "transport-rapid_tram": '<i18n:dynamic project="tanker" keyset="dynamic" key="gender">\n    <i18n:gender><i18n:param>gender</i18n:param></i18n:gender>\n    <i18n:masculine>Скоростной трамвай</i18n:masculine>\n    <i18n:plural>Скоростные трамваи</i18n:plural>\n</i18n:dynamic>',
          "transport-suburban": '<i18n:dynamic project="tanker" keyset="dynamic" key="gender"> <i18n:gender><i18n:param>gender</i18n:param></i18n:gender> <i18n:masculine>Электричка</i18n:masculine> <i18n:plural>Электрички</i18n:plural> </i18n:dynamic>',
          "transport-train": '<i18n:dynamic project="tanker" keyset="dynamic" key="gender">\n    <i18n:gender><i18n:param>gender</i18n:param></i18n:gender>\n    <i18n:masculine>Электричка</i18n:masculine>\n    <i18n:plural>Электрички</i18n:plural>\n</i18n:dynamic>',
          "transport-tramway": '<i18n:dynamic project="tanker" keyset="dynamic" key="gender">\n    <i18n:gender><i18n:param>gender</i18n:param></i18n:gender>\n    <i18n:masculine>Трамвай</i18n:masculine>\n    <i18n:plural>Трамваи</i18n:plural>\n</i18n:dynamic>',
          "transport-trolleybus": '<i18n:dynamic project="tanker" keyset="dynamic" key="gender">\n    <i18n:gender><i18n:param>gender</i18n:param></i18n:gender>\n    <i18n:masculine>Троллейбус</i18n:masculine>\n    <i18n:plural>Троллейбусы</i18n:plural>\n</i18n:dynamic>',
          "transport-underground": '<i18n:dynamic project="tanker" keyset="dynamic" key="gender">\n    <i18n:gender><i18n:param>gender</i18n:param></i18n:gender>\n    <i18n:masculine>Метро</i18n:masculine>\n    <i18n:plural>Метро</i18n:plural>\n</i18n:dynamic>',
          "transport-water": '<i18n:dynamic project="tanker" keyset="dynamic" key="gender">\n    <i18n:gender><i18n:param>gender</i18n:param></i18n:gender>\n    <i18n:masculine>Водный транспорт</i18n:masculine>\n    <i18n:plural>Водный транспорт</i18n:plural>\n</i18n:dynamic>',
          "travel-distance": '<i18n:dynamic>\n    <i18n:xsl>\n        <xsl:param name="text"/>\n        <xsl:param name="value"/>\n        <xsl:choose>\n            <xsl:when test="$value = 0">Переcадка</xsl:when>\n            <xsl:when test="$value &lt; 100">Менее 100 м</xsl:when>\n            <xsl:otherwise><xsl:value-of select="$text"/></xsl:otherwise>\n        </xsl:choose>\n    </i18n:xsl>\n</i18n:dynamic>',
          "travel-time": 'около <i18n:dynamic project="maps_api" keyset="masstransit" key="human-duration">\n    <i18n:duration><i18n:param>value</i18n:param></i18n:duration>\n</i18n:dynamic><i18n:dynamic project="tanker" keyset="dynamic" key="toggle">\n    <i18n:condition><i18n:param>isMoving</i18n:param></i18n:condition>\n    <i18n:true> в пути.</i18n:true>\n    <i18n:false/>\n</i18n:dynamic>',
          "travel-to-berth": 'До причала <i18n:dynamic project="maps_api" keyset="masstransit" key="quote">\n    <i18n:text><i18n:param>name</i18n:param></i18n:text>\n</i18n:dynamic>',
          "travel-to-station": 'До станции <i18n:dynamic project="maps_api" keyset="masstransit" key="quote">\n    <i18n:text><i18n:param>name</i18n:param></i18n:text>\n</i18n:dynamic>',
          "travel-to-stop": 'До остановки <i18n:dynamic project="maps_api" keyset="masstransit" key="quote">\n    <i18n:text><i18n:param>name</i18n:param></i18n:text>\n</i18n:dynamic>',
          "travel-transfer": 'Переход на станцию <i18n:dynamic project="maps_api" keyset="masstransit" key="quote">\n    <i18n:text><i18n:param>station</i18n:param></i18n:text>\n</i18n:dynamic> (<i18n:param>line</i18n:param>)'
        },
        panorama: {
          close: "Закрыть",
          enterFullscreen: "В полноэкранный режим",
          error: "Что-то сломалось.<br>Но мы уже знаем об этом,<br>зайдите чуть позже.",
          leaveFullscreen: "В оконный режим",
          scale: "Масштаб",
          zoomIn: "Увеличить",
          zoomOut: "Уменьшить"
        },
        ppo: {
          Card: {
            addReview: "Оставить отзыв",
            addReviewLink: "{mapsHost}org/{organizationId}/?add-review&source=api-maps&utm_source=api-maps",
            advertLabel: "реклама",
            directUrl: "direct.yandex.ru",
            feedbackAdd: "Добавить организацию",
            feedbackCorrect: "Исправить неточность",
            feedbackEdit: "Редактировать",
            interaction: "Маршрут сюда",
            mapsUrl: "maps.yandex.ru",
            ratingRatings: ["оценка", "оценки", "оценок", "оценок"],
            ratingReviews: ["отзыв", "отзыва", "отзывов", "отзывов"],
            reviewsUrl: "maps.yandex.ru/org/",
            spravAddUrl: "{mapsHost}feedback/org/add/",
            spravEditUrl: "{mapsHost}feedback/org/{organization_id}/edit/?utm_source={utm_source}&utm_medium={utm_medium}",
            timeClosed: "Закрыто",
            timeClosedUntil: "Закрыто до %s",
            timeOpen: "Открыто",
            timeOpen24: "Круглосуточно",
            timeOpenUntil: "Открыто до %s"
          }
        },
        route: {
          back: "разворот",
          "board ferry": "паромная переправа",
          "enter roundabout": "круговое движение",
          exit: "съезд",
          "exit back": "разворот, съезд",
          "exit hard left": "съезд налево",
          "exit hard right": "съезд направо",
          "exit left": "съезд налево",
          "exit none": "съезд",
          "exit right": "съезд направо",
          "exit slight left": "левее на съезд",
          "exit slight right": "правее на съезд",
          "hard left": "резкий поворот налево",
          "hard right": "резкий поворот направо",
          "leave ferry": "Конец паромной переправы",
          "leave roundabout": "съезд с кругового движения",
          "leave roundabout 1": "1-й съезд",
          "leave roundabout 2": "2-й съезд",
          "leave roundabout 3": "3-й съезд",
          "leave roundabout 4": "4-й съезд",
          "leave roundabout 5": "5-й съезд",
          "leave roundabout 6": "6-й съезд",
          "leave roundabout 7": "7-й съезд",
          "leave roundabout 8": "8-й съезд",
          "leave roundabout 9": "9-й съезд",
          left: "налево",
          merge: "въезд",
          none: "прямо",
          right: "направо",
          roundabout: "круговое движение",
          "slight left": "левее",
          "slight right": "правее",
          straight: "прямо"
        },
        searchSuggest: {
          "01-restaurant": "Где поесть",
          "02-bar": "Бары",
          "03-atm": "Банкоматы",
          "04-cinema": "Кино",
          "05-barbershop": "Красота",
          "06-pharmacy": "Аптеки",
          "07-shop": "Продукты",
          "08-shopping-mall": "Торговые центры",
          "09-fitness": "Фитнес",
          "10-auto-repair": "Автосервис",
          "11-gasoline": "АЗС",
          "12-hotel": "Гостиницы"
        },
        "telegram-bot": {
          "cant-listen": "Я не слышу :( Пожалуйста, напишите мне!",
          "cant-look": "Я не вижу :( Пожалуйста, напишите мне!",
          "give-me-your-location": "Отправьте мне свою геопозицию, и я покажу.",
          "have-not-location": "Я бы поискал, но у меня нет ваших координат. Отправьте их мне и повторите запрос.",
          hello: "Привет!",
          "i-am-here": "Я в Яндексе! Москва, ул. Льва Толстого, 16а.",
          "language-enter-lang": "Выберите язык, на котором мы будем общаться.",
          "language-saved": "Язык успешно сохранен!",
          "not-found": "Ничего не нашел.",
          "route-destination-not-found": "Я не смог определить, куда хотите добраться.",
          "route-have-not-destination": "Укажите, куда строить маршрут. Например, /route Льва Толстого, 16а.",
          "route-have-not-location": "Пожалуйста, отправьте мне свою геопозицию для построения маршрута.",
          "search-without-parameters": "Напишите мне, что бы вы хотели найти, например, /search кафе.\\nЧтобы найти места рядом, отправьте мне своё местоположение и спросите что-нибудь.",
          "start-message": " Я умею находить интересные места на карте и сообщать о пробках.\\nОтправьте сообщение с /traffic Город, чтобы узнать пробки в вашем городе.\\nИли напишите мне что-нибудь чтобы найти это на карте. В групповых чатах для поиска можно использовать команду /search.\\nСообщите мне своё местоположение, чтобы получать самую точную информацию о пробках и ближайших местах.",
          "thank-you": "Да, неплохо получилось :) Обращайтесь!",
          "traffic-citys": '["Москва", "Санкт-Петербург", "Екатеринбург", "Новосибирск", "Краснодар"]',
          "traffic-enter-city": "Уточните город, для которого показать пробки. Например, /traffic Екатеринбург.",
          "traffic-fail": "Что-то пошло не так. Пожалуйста, повторите запрос.",
          "traffic-in": "Пробки в городе {{city}}",
          "traffic-level": "{city} {time}. \\n{level}. {hint}.",
          "traffic-not-found": "В вашем городе пробки не найдены.",
          "user-already-deleted": "Я и так ничего о вас не знаю.",
          "user-deleted": "Готово, все забыл.",
          "where-are-you": "А вы? Отправьте мне своё местоположение.",
          "yandex-maps": "Открыть в Яндекс.Картах",
          "yandex-place": "Я здесь живу и работаю. Заходите в гости как-нибудь!"
        }
      })
    });
  }],
  ['52', function(ym) {
    ym.modules.define("localization.lib", [], function(e) {
      function t(e, t) {
        this.value = e, this.name = t
      }

      function a(e) {
        for (var t = 0; t < e.length; ++t)
          if ("+" == e.charAt(t) || "-" == e.charAt(t) || "*" == e.charAt(t) || "/" == e.charAt(t)) return t;
        return e.length
      }

      function m(e, t) {
        if (0 === e.length) return t;
        if (e.charAt(0) >= "0" && e.charAt(0) < "9") return e;
        var s = a(e.substring(1, e.length)),
          r = e.substring(1, s + 1);
        return "+" == e.charAt(0) ? m(s == e.length ? "" : e.substring(s + 1, e.length), t + parseFloat(r)) : "-" == e.charAt(0) ? m(s == e.length ? "" : e.substring(s + 1, e.length), t - parseFloat(r)) : "*" == e.charAt(0) ? m(s == e.length ? "" : e.substring(s + 1, e.length), t * parseFloat(r)) : "/" == e.charAt(0) ? m(s == e.length ? "" : e.substring(s + 1, e.length), t / parseFloat(r)) : t
      }

      function s(e, a, s) {
        e.length > 8 && "-x-local" == e.substr(e.length - 8, e.length) && (e = e.substr(e, e.length - 8));
        var r = e.search("-"),
          n = e.search("_");
        if (-1 != r ? e = e.substr(r + 1, e.length) : -1 != n && (e = e.substr(n + 1, e.length)), "duration" == a) {
          var y = [],
            u = 0;
          return 0 !== Math.floor(s / 31536e3) && (y[u] = [], y[u].value = Math.floor(s / 31536e3), y[u].name = "years", ++u, s %= 31536e3), 0 !== Math.floor(s / 86400) && (y[u] = [], y[u].value = Math.floor(s / 86400), y[u].name = "days", ++u, s %= 86400), 0 !== Math.floor(s / 3600) && (y[u] = [], y[u].value = Math.floor(s / 3600), y[u].name = "hours", ++u, s %= 3600), 0 !== Math.floor(s / 60) && (y[u] = [], y[u].value = Math.floor(s / 60), y[u].name = "minutes", ++u, s %= 60), y
        }
        for (var l = "System" + o.ISO[e].system, i = o.Systems[l][a].num, d = new Array(i), u = 1; u <= i; ++u) {
          var c = o.Systems[l][a]["unit" + u].name,
            b = o.Systems[l][a]["unit" + u].factor;
          d[u - 1] = new t(m(b, s), c)
        }
        for (var u = i - 1; u >= 0; --u)
          if (Math.abs(d[u].value) < 1) return u != i - 1 && d[u + 1].value < 1e3 ? d[u + 1] : d[u];
        return d[0]
      }

      function r(e, t, a, m) {
        var s = e.split("\t", 11),
          n = [];
        n.w = s[0], n.m = s[1], n.d = s[2], n.H = s[3], n.I = s[4], n.M = s[5], n.p = s[6], n.S = s[7], n.T = s[8], n.y = s[9], n.Y = s[10];
        for (var y = "", u = 0; u < a.length; ++u) "%" == a.charAt(u) ? (++u, "a" == a.charAt(u) ? y += o.ISODateTime[t].dayAbbr[n.w] : "A" == a.charAt(u) ? y += o.ISODateTime[t].dayName[n.w] : "b" == a.charAt(u) ? y += o.ISODateTime[t].monthAbbr[n.m - 1] : "B" == a.charAt(u) ? y += o.ISODateTime[t].monthGenitive[n.m - 1] : "d" == a.charAt(u) ? y += n.d : "e" == a.charAt(u) ? y += n.d : "H" == a.charAt(u) ? y += n.H : "I" == a.charAt(u) ? y += n.I : "m" == a.charAt(u) ? y += n.m : "M" == a.charAt(u) ? y += n.M : "p" == a.charAt(u) ? y += n.p : "S" == a.charAt(u) ? y += n.S : "T" == a.charAt(u) ? y += n.T : "X" == a.charAt(u) ? m || (y += r(e, t, o.ISODateTime[t].timeFormat, 1)) : "y" == a.charAt(u) ? y += n.y : "Y" == a.charAt(u) ? y += n.Y : "Z" == a.charAt(u) || (y += "%" + a.charAt(u))) : y += a.charAt(u);
        return y
      }

      function n(e, t, a) {
        t.length > 8 && "-x-local" == t.substr(t.length - 8, t.length) && (t = t.substr(t, t.length - 8));
        var m = t.search("-"); - 1 != m && (t = t.replace(t.charAt(m), "_")), "full" == a ? a = o.ISODateTime[t].fullDateTimeFormat : "date" == a ? a = o.ISODateTime[t].dateFormat : "time" == a ? a = o.ISODateTime[t].timeFormat : "datetime" == a && (a = o.ISODateTime[t].fullDateFormat);
        var s = y(1e3 * e, "en-US", "%w\t%m\t%d\t%H\t%I\t%M\t%p\t%S\t%T\t%y\t%Y"),
          n = r(s, t, a, 0);
        return n
      }
      var y = function() {
          var e = {};
          return e.util = {}, e.util.xPad = function(e, t, a) {
              for ("undefined" == typeof a && (a = 10); parseInt(e, 10) < a && a > 1; a /= 10) e = t.toString() + e;
              return e.toString()
            }, e.locales = {}, e.locales.en = {
              a: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
              A: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
              b: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
              B: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
              c: "%a %d %b %Y %T %Z",
              p: ["AM", "PM"],
              P: ["am", "pm"],
              x: "%d/%m/%y",
              X: "%T"
            }, e.locales["en-US"] = e.locales.en, e.locales["en-US"].c = "%a %d %b %Y %r %Z", e.locales["en-US"].x = "%D", e.locales["en-US"].X = "%r", e.locales["en-GB"] = e.locales.en, e.locales["en-AU"] = e.locales["en-GB"], e.formats = {
              a: function(t) {
                return e.locales[t.locale].a[t.getUTCDay()]
              },
              A: function(t) {
                return e.locales[t.locale].A[t.getUTCDay()]
              },
              b: function(t) {
                return e.locales[t.locale].b[t.getUTCMonth()]
              },
              B: function(t) {
                return e.locales[t.locale].B[t.getUTCMonth()]
              },
              c: "toUTCString",
              C: function(t) {
                return e.util.xPad(parseInt(t.getUTCFullYear() / 100, 10), 0)
              },
              d: ["getUTCDate", "0"],
              e: ["getUTCDate", " "],
              g: function(t) {
                return e.util.xPad(parseInt(e.util.G(t) / 100, 10), 0)
              },
              G: function(t) {
                var a = t.getUTCFullYear(),
                  m = parseInt(e.formats.V(t), 10),
                  s = parseInt(e.formats.W(t), 10);
                return s > m ? a++ : 0 === s && m >= 52 && a--, a
              },
              H: ["getUTCHours", "0"],
              I: function(t) {
                var a = t.getUTCHours() % 12;
                return e.util.xPad(0 === a ? 12 : a, 0)
              },
              j: function(t) {
                var a = t - new Date("" + t.getUTCFullYear() + "/1/1 GMT");
                a += 6e4 * t.getTimezoneOffset();
                var m = parseInt(a / 6e4 / 60 / 24, 10) + 1;
                return e.util.xPad(m, 0, 100)
              },
              m: function(t) {
                return e.util.xPad(t.getUTCMonth() + 1, 0)
              },
              M: ["getUTCMinutes", "0"],
              p: function(t) {
                return e.locales[t.locale].p[t.getUTCHours() >= 12 ? 1 : 0]
              },
              P: function(t) {
                return e.locales[t.locale].P[t.getUTCHours() >= 12 ? 1 : 0]
              },
              S: ["getUTCSeconds", "0"],
              u: function(e) {
                var t = e.getUTCDay();
                return 0 === t ? 7 : t
              },
              U: function(t) {
                var a = parseInt(e.formats.j(t), 10),
                  m = 6 - t.getUTCDay(),
                  s = parseInt((a + m) / 7, 10);
                return e.util.xPad(s, 0)
              },
              V: function(t) {
                var a = parseInt(e.formats.W(t), 10),
                  m = new Date("" + t.getUTCFullYear() + "/1/1").getUTCDay(),
                  s = a + (m > 4 || m <= 1 ? 0 : 1);
                return 53 == s && new Date("" + t.getUTCFullYear() + "/12/31").getUTCDay() < 4 ? s = 1 : 0 === s && (s = e.formats.V(new Date("" + (t.getUTCFullYear() - 1) + "/12/31"))), e.util.xPad(s, 0)
              },
              w: "getUTCDay",
              W: function(t) {
                var a = parseInt(e.formats.j(t), 10),
                  m = 7 - e.formats.u(t),
                  s = parseInt((a + m) / 7, 10);
                return e.util.xPad(s, 0, 10)
              },
              y: function(t) {
                return e.util.xPad(t.getUTCFullYear() % 100, 0)
              },
              Y: "getUTCFullYear",
              z: function(t) {
                var a = t.getTimezoneOffset(),
                  m = e.util.xPad(parseInt(Math.abs(a / 60), 10), 0),
                  s = e.util.xPad(a % 60, 0);
                return (a > 0 ? "-" : "+") + m + s
              },
              Z: function(e) {
                return e.toString().replace(/^.*\(([^)]+)\)$/, "$1")
              },
              "%": function(e) {
                return "%"
              }
            }, e.aggregates = {
              c: "locale",
              D: "%m/%d/%y",
              h: "%b",
              n: "\n",
              r: "%I:%M:%S %p",
              R: "%H:%M",
              t: "\t",
              T: "%H:%M:%S",
              x: "locale",
              X: "locale"
            }, e.aggregates.z = e.formats.z(new Date), e.aggregates.Z = e.formats.Z(new Date), e.unsupported = {},
            function(t, a, m) {
              a = a || "", m = m || "";
              var s = new Date(t);
              s.locale = a, a in e.locales || (a = a.replace(/-[a-zA-Z]+$/, "") in e.locales ? a.replace(/-[a-zA-Z]+$/, "") : "en-GB");
              for (; m.match(/%[cDhnrRtTxXzZ]/);) m = m.replace(/%([cDhnrRtTxXzZ])/g, function(t, a) {
                var m = e.aggregates[a];
                return "locale" == m ? e.locales[s.locale][a] : m
              });
              var r = m.replace(/%([aAbBCdegGHIjmMpPSuUVwWyY%])/g, function(t, a) {
                var m = e.formats[a];
                return "string" == typeof m ? s[m]() : "function" == typeof m ? m.call(s, s) : "object" == typeof m && "string" == typeof m[0] ? e.util.xPad(s[m[0]](), m[1]) : a
              });
              return s = null, r
            }
        }(),
        o = {
          ISO: {
            AD: {
              system: 2
            },
            AE: {
              system: 2
            },
            AF: {
              system: 2
            },
            AG: {
              system: 2
            },
            AI: {
              system: 2
            },
            AL: {
              system: 2
            },
            AM: {
              system: 2
            },
            AO: {
              system: 2
            },
            AR: {
              system: 2
            },
            AT: {
              system: 2
            },
            AU: {
              system: 2
            },
            AW: {
              system: 2
            },
            AZ: {
              system: 2
            },
            BA: {
              system: 2
            },
            BB: {
              system: 2
            },
            BD: {
              system: 2
            },
            BE: {
              system: 2
            },
            BF: {
              system: 2
            },
            BG: {
              system: 2
            },
            BH: {
              system: 2
            },
            BI: {
              system: 2
            },
            BJ: {
              system: 2
            },
            BM: {
              system: 2
            },
            BN: {
              system: 2
            },
            BO: {
              system: 2
            },
            BR: {
              system: 2
            },
            BS: {
              system: 2
            },
            BT: {
              system: 2
            },
            BW: {
              system: 2
            },
            BY: {
              system: 2
            },
            BZ: {
              system: 2
            },
            CA: {
              system: 2
            },
            CC: {
              system: 2
            },
            CD: {
              system: 2
            },
            CF: {
              system: 2
            },
            CG: {
              system: 2
            },
            CH: {
              system: 2
            },
            CI: {
              system: 2
            },
            CK: {
              system: 2
            },
            CL: {
              system: 2
            },
            CM: {
              system: 2
            },
            CN: {
              system: 2
            },
            CO: {
              system: 2
            },
            CR: {
              system: 2
            },
            CU: {
              system: 2
            },
            CV: {
              system: 2
            },
            CY: {
              system: 2
            },
            CZ: {
              system: 2
            },
            DE: {
              system: 2
            },
            DJ: {
              system: 2
            },
            DK: {
              system: 2
            },
            DM: {
              system: 2
            },
            DO: {
              system: 2
            },
            DZ: {
              system: 2
            },
            EC: {
              system: 2
            },
            EE: {
              system: 2
            },
            EG: {
              system: 2
            },
            EH: {
              system: 2
            },
            ER: {
              system: 2
            },
            ES: {
              system: 2
            },
            ET: {
              system: 2
            },
            FI: {
              system: 2
            },
            FJ: {
              system: 2
            },
            FK: {
              system: 2
            },
            FM: {
              system: 2
            },
            FR: {
              system: 2
            },
            GA: {
              system: 2
            },
            GB: {
              system: 1
            },
            GD: {
              system: 2
            },
            GE: {
              system: 2
            },
            GF: {
              system: 2
            },
            GH: {
              system: 2
            },
            GI: {
              system: 2
            },
            GL: {
              system: 2
            },
            GM: {
              system: 2
            },
            GN: {
              system: 2
            },
            GP: {
              system: 2
            },
            GQ: {
              system: 2
            },
            GR: {
              system: 2
            },
            GT: {
              system: 2
            },
            GU: {
              system: 2
            },
            GW: {
              system: 2
            },
            GY: {
              system: 2
            },
            HK: {
              system: 2
            },
            HN: {
              system: 2
            },
            HR: {
              system: 2
            },
            HT: {
              system: 2
            },
            HU: {
              system: 2
            },
            ID: {
              system: 2
            },
            IE: {
              system: 2
            },
            IL: {
              system: 2
            },
            IN: {
              system: 2
            },
            IQ: {
              system: 2
            },
            IR: {
              system: 2
            },
            IS: {
              system: 2
            },
            IT: {
              system: 2
            },
            JM: {
              system: 2
            },
            JO: {
              system: 2
            },
            JP: {
              system: 2
            },
            KE: {
              system: 2
            },
            KG: {
              system: 2
            },
            KH: {
              system: 2
            },
            KI: {
              system: 2
            },
            KM: {
              system: 2
            },
            KN: {
              system: 2
            },
            KP: {
              system: 2
            },
            KR: {
              system: 2
            },
            KW: {
              system: 2
            },
            KY: {
              system: 2
            },
            KZ: {
              system: 2
            },
            LA: {
              system: 2
            },
            LB: {
              system: 2
            },
            LC: {
              system: 2
            },
            LI: {
              system: 2
            },
            LK: {
              system: 2
            },
            LR: {
              system: 1
            },
            LS: {
              system: 2
            },
            LT: {
              system: 2
            },
            LU: {
              system: 2
            },
            LV: {
              system: 2
            },
            LY: {
              system: 2
            },
            MA: {
              system: 2
            },
            MC: {
              system: 2
            },
            MD: {
              system: 2
            },
            ME: {
              system: 2
            },
            MG: {
              system: 2
            },
            MH: {
              system: 2
            },
            MK: {
              system: 2
            },
            ML: {
              system: 2
            },
            MM: {
              system: 1
            },
            MN: {
              system: 2
            },
            MQ: {
              system: 2
            },
            MR: {
              system: 2
            },
            MS: {
              system: 2
            },
            MT: {
              system: 2
            },
            MU: {
              system: 2
            },
            MV: {
              system: 2
            },
            MW: {
              system: 2
            },
            MX: {
              system: 2
            },
            MY: {
              system: 2
            },
            MZ: {
              system: 2
            },
            NA: {
              system: 2
            },
            NC: {
              system: 2
            },
            NE: {
              system: 2
            },
            NF: {
              system: 2
            },
            NG: {
              system: 2
            },
            NI: {
              system: 2
            },
            NL: {
              system: 2
            },
            NO: {
              system: 2
            },
            NP: {
              system: 2
            },
            NR: {
              system: 2
            },
            NU: {
              system: 2
            },
            NZ: {
              system: 2
            },
            OM: {
              system: 2
            },
            PA: {
              system: 2
            },
            PE: {
              system: 2
            },
            PF: {
              system: 2
            },
            PG: {
              system: 2
            },
            PH: {
              system: 2
            },
            PK: {
              system: 2
            },
            PL: {
              system: 2
            },
            PR: {
              system: 2
            },
            PS: {
              system: 2
            },
            PT: {
              system: 2
            },
            PW: {
              system: 2
            },
            PY: {
              system: 2
            },
            QA: {
              system: 2
            },
            RE: {
              system: 2
            },
            RO: {
              system: 2
            },
            RS: {
              system: 2
            },
            RU: {
              system: 2
            },
            RW: {
              system: 2
            },
            SA: {
              system: 2
            },
            SB: {
              system: 2
            },
            SC: {
              system: 2
            },
            SD: {
              system: 2
            },
            SE: {
              system: 2
            },
            SG: {
              system: 2
            },
            SI: {
              system: 2
            },
            SK: {
              system: 2
            },
            SL: {
              system: 2
            },
            SM: {
              system: 2
            },
            SN: {
              system: 2
            },
            SO: {
              system: 2
            },
            SR: {
              system: 2
            },
            ST: {
              system: 2
            },
            SV: {
              system: 2
            },
            SY: {
              system: 2
            },
            SZ: {
              system: 2
            },
            TC: {
              system: 2
            },
            TD: {
              system: 2
            },
            TG: {
              system: 2
            },
            TH: {
              system: 2
            },
            TJ: {
              system: 2
            },
            TL: {
              system: 2
            },
            TM: {
              system: 2
            },
            TN: {
              system: 2
            },
            TO: {
              system: 2
            },
            TR: {
              system: 2
            },
            TT: {
              system: 2
            },
            TV: {
              system: 2
            },
            TW: {
              system: 2
            },
            TZ: {
              system: 2
            },
            UA: {
              system: 2
            },
            UG: {
              system: 2
            },
            US: {
              system: 1
            },
            UY: {
              system: 2
            },
            UZ: {
              system: 2
            },
            VA: {
              system: 2
            },
            VC: {
              system: 2
            },
            VE: {
              system: 2
            },
            VG: {
              system: 2
            },
            VI: {
              system: 2
            },
            VN: {
              system: 2
            },
            VU: {
              system: 2
            },
            WS: {
              system: 2
            },
            YE: {
              system: 2
            },
            YT: {
              system: 2
            },
            ZA: {
              system: 2
            },
            ZM: {
              system: 2
            }
          },
          Systems: {
            System1: {
              distance: {
                unit1: {
                  name: "miles",
                  factor: "*0.00062"
                },
                unit2: {
                  name: "feet",
                  factor: "*3.281"
                },
                unit3: {
                  name: "inches",
                  factor: "*39.37"
                },
                num: 3
              },
              temperature: {
                unit1: {
                  name: "fahrenheits",
                  factor: "*1.8+32"
                },
                num: 1
              },
              velocity: {
                unit1: {
                  name: "miles per hour",
                  factor: "*2.237"
                },
                num: 1
              }
            },
            System2: {
              distance: {
                unit1: {
                  name: "kilometers",
                  factor: "*0.001"
                },
                unit2: {
                  name: "meters",
                  factor: "*1"
                },
                unit3: {
                  name: "centimeters",
                  factor: "*100"
                },
                num: 3
              },
              temperature: {
                unit1: {
                  name: "celsiuses",
                  factor: "*1"
                },
                num: 1
              },
              velocity: {
                unit1: {
                  name: "kilometers per hour",
                  factor: "*3.6"
                },
                num: 1
              }
            }
          },
          ISODateTime: {
            en_NZ: {
              monthAbbr: {
                0: "Jan",
                1: "Feb",
                2: "Mar",
                3: "Apr",
                4: "May",
                5: "Jun",
                6: "Jul",
                7: "Aug",
                8: "Sep",
                9: "Oct",
                10: "Nov",
                11: "Dec"
              },
              monthGenitive: {
                0: "January",
                1: "February",
                2: "March",
                3: "April",
                4: "May",
                5: "June",
                6: "July",
                7: "August",
                8: "September",
                9: "October",
                10: "November",
                11: "December"
              },
              dayAbbr: {
                0: "Sun",
                1: "Mon",
                2: "Tue",
                3: "Wed",
                4: "Thu",
                5: "Fri",
                6: "Sat"
              },
              dayName: {
                0: "Sunday",
                1: "Monday",
                2: "Tuesday",
                3: "Wednesday",
                4: "Thursday",
                5: "Friday",
                6: "Saturday"
              },
              timeFormat: "%H:%M:%S",
              dateFormat: "%d/%m/%Y",
              fullDateFormat: "%a %e %b %X %Y",
              amFormat: "am",
              pmFormat: "pm",
              fullDateTimeFormat: "%a %e %b %Y %X %Z",
              monthNominative: {
                0: "January",
                1: "February",
                2: "March",
                3: "April",
                4: "May",
                5: "June",
                6: "July",
                7: "August",
                8: "September",
                9: "October",
                10: "November",
                11: "December"
              },
              dmFormat: "dm",
              twelveTimeFormat: "%I:%M:%S %p"
            },
            tr_TR: {
              monthAbbr: {
                0: "Oca",
                1: "Şub",
                2: "Mar",
                3: "Nis",
                4: "May",
                5: "Haz",
                6: "Tem",
                7: "Ağu",
                8: "Eyl",
                9: "Eki",
                10: "Kas",
                11: "Ara"
              },
              monthGenitive: {
                0: "Ocak",
                1: "Şubat",
                2: "Mart",
                3: "Nisan",
                4: "Mayıs",
                5: "Haziran",
                6: "Temmuz",
                7: "Ağustos",
                8: "Eylül",
                9: "Ekim",
                10: "Kasım",
                11: "Aralık"
              },
              dayAbbr: {
                0: "Paz",
                1: "Pts",
                2: "Sal",
                3: "Çar",
                4: "Per",
                5: "Cum",
                6: "Cts"
              },
              dayName: {
                0: "Pazar",
                1: "Pazartesi",
                2: "Salı",
                3: "Çarşamba",
                4: "Perşembe",
                5: "Cuma",
                6: "Cumartesi"
              },
              timeFormat: "%H:%M:%S",
              dateFormat: "%d/%m/%Y",
              fullDateFormat: "%a %e %b %X %Y",
              amFormat: "AM",
              pmFormat: "PM",
              fullDateTimeFormat: "%e %b %Y %a %Z %X",
              monthNominative: {
                0: "Ocak",
                1: "Subat",
                2: "Mart",
                3: "Nisan",
                4: "Mayis",
                5: "Haziran",
                6: "Temmuz",
                7: "Agustos",
                8: "Eylul",
                9: "Ekim",
                10: "Kasim",
                11: "Aralik"
              },
              dmFormat: "dm",
              twelveTimeFormat: "%I:%M:%S %p"
            },
            uk_UA: {
              monthAbbr: {
                0: "січ",
                1: "лют",
                2: "бер",
                3: "кві",
                4: "тра",
                5: "чер",
                6: "лип",
                7: "сер",
                8: "вер",
                9: "жов",
                10: "лис",
                11: "гру"
              },
              monthGenitive: {
                0: "січня",
                1: "лютого",
                2: "березня",
                3: "квітня",
                4: "травня",
                5: "червня",
                6: "липня",
                7: "серпня",
                8: "вересня",
                9: "жовтня",
                10: "листопада",
                11: "грудня"
              },
              dayAbbr: {
                0: "нд",
                1: "пн",
                2: "вт",
                3: "ср",
                4: "чт",
                5: "пт",
                6: "сб"
              },
              dayName: {
                0: "неділя",
                1: "понеділок",
                2: "вівторок",
                3: "середа",
                4: "четвер",
                5: "п'ятниця",
                6: "субота"
              },
              timeFormat: "%H:%M:%S",
              dateFormat: "%d.%m.%Y",
              fullDateFormat: "%a %e %b %X %Y",
              amFormat: "",
              pmFormat: "",
              fullDateTimeFormat: "%a %e %b %Y %X %Z",
              monthNominative: {
                0: "січень",
                1: "лютий",
                2: "березень",
                3: "квітень",
                4: "травень",
                5: "червень",
                6: "липень",
                7: "серпень",
                8: "вересень",
                9: "жовтень",
                10: "листопад",
                11: "грудень"
              },
              dmFormat: "dm",
              twelveTimeFormat: ""
            },
            ru_UA: {
              monthAbbr: {
                0: "янв",
                1: "фев",
                2: "мар",
                3: "апр",
                4: "май",
                5: "июн",
                6: "июл",
                7: "авг",
                8: "сен",
                9: "окт",
                10: "ноя",
                11: "дек"
              },
              monthGenitive: {
                0: "января",
                1: "февраля",
                2: "марта",
                3: "апреля",
                4: "мая",
                5: "июня",
                6: "июля",
                7: "августа",
                8: "сентября",
                9: "октября",
                10: "ноября",
                11: "декабря"
              },
              dayAbbr: {
                0: "вс",
                1: "пн",
                2: "вт",
                3: "ср",
                4: "чт",
                5: "пт",
                6: "сб"
              },
              dayName: {
                0: "воскресенье",
                1: "понедельник",
                2: "вторник",
                3: "среда",
                4: "четверг",
                5: "пятница",
                6: "суббота"
              },
              timeFormat: "%H:%M:%S",
              dateFormat: "%d.%m.%Y",
              fullDateFormat: "%A, %e %B %Y г. %X",
              amFormat: "",
              pmFormat: "",
              fullDateTimeFormat: "%A, %e %B %Y г. %X (%Z)",
              monthNominative: {
                0: "январь",
                1: "февраль",
                2: "март",
                3: "апрель",
                4: "май",
                5: "июнь",
                6: "июль",
                7: "август",
                8: "сентябрь",
                9: "октябрь",
                10: "ноябрь",
                11: "декабрь"
              },
              dmFormat: "dm",
              twelveTimeFormat: ""
            },
            kk_KZ: {
              monthAbbr: {
                0: "қаң",
                1: "ақп",
                2: "нау",
                3: "сәу",
                4: "мам",
                5: "мау",
                6: "шіл",
                7: "там",
                8: "қыр",
                9: "қаз",
                10: "қар",
                11: "жел"
              },
              monthGenitive: {
                0: "қаңтар",
                1: "ақпан",
                2: "наурыз",
                3: "сәуір",
                4: "мамыр",
                5: "маусым",
                6: "шілде",
                7: "тамыз",
                8: "қыркүйек",
                9: "қазан",
                10: "қараша",
                11: "желтоқсан"
              },
              dayAbbr: {
                0: "жк",
                1: "дс",
                2: "сс",
                3: "ср",
                4: "бс",
                5: "жм",
                6: "сн"
              },
              dayName: {
                0: "жексенбі",
                1: "дүйсенбі",
                2: "сейсенбі",
                3: "сәрсенбі",
                4: "бейсенбі",
                5: "жұма",
                6: "сенбі"
              },
              timeFormat: "%H:%M:%S",
              dateFormat: "%d.%m.%Y",
              fullDateFormat: "%A, %e %B %Y ж. %X",
              amFormat: "",
              pmFormat: "",
              fullDateTimeFormat: "%A, %e %B %Y ж. %X (%Z)",
              monthNominative: {
                0: "қантар",
                1: "ақпан",
                2: "наурыз",
                3: "сәуір",
                4: "мамыр",
                5: "маусым",
                6: "шілде",
                7: "тамыз",
                8: "қыркүйек",
                9: "қазан",
                10: "қараша",
                11: "желтоқсан"
              },
              dmFormat: "dm",
              twelveTimeFormat: ""
            },
            uk_RU: {
              monthAbbr: {
                0: "січ",
                1: "лют",
                2: "бер",
                3: "кві",
                4: "тра",
                5: "чер",
                6: "лип",
                7: "сер",
                8: "вер",
                9: "жов",
                10: "лис",
                11: "гру"
              },
              monthGenitive: {
                0: "січня",
                1: "лютого",
                2: "березня",
                3: "квітня",
                4: "травня",
                5: "червня",
                6: "липня",
                7: "серпня",
                8: "вересня",
                9: "жовтня",
                10: "листопада",
                11: "грудня"
              },
              dayAbbr: {
                0: "нд",
                1: "пн",
                2: "вт",
                3: "ср",
                4: "чт",
                5: "пт",
                6: "сб"
              },
              dayName: {
                0: "неділя",
                1: "понеділок",
                2: "вівторок",
                3: "середа",
                4: "четвер",
                5: "п'ятниця",
                6: "субота"
              },
              timeFormat: "%H:%M:%S",
              dateFormat: "%d.%m.%Y",
              fullDateFormat: "%a %e %b %X %Y",
              amFormat: "",
              pmFormat: "",
              fullDateTimeFormat: "%a %e %b %Y %X %Z",
              monthNominative: {
                0: "січень",
                1: "лютий",
                2: "березень",
                3: "квітень",
                4: "травень",
                5: "червень",
                6: "липень",
                7: "серпень",
                8: "вересень",
                9: "жовтень",
                10: "листопад",
                11: "грудень"
              },
              dmFormat: "dm",
              twelveTimeFormat: ""
            },
            en_US: {
              monthAbbr: {
                0: "Jan",
                1: "Feb",
                2: "Mar",
                3: "Apr",
                4: "May",
                5: "Jun",
                6: "Jul",
                7: "Aug",
                8: "Sep",
                9: "Oct",
                10: "Nov",
                11: "Dec"
              },
              monthGenitive: {
                0: "January",
                1: "February",
                2: "March",
                3: "April",
                4: "May",
                5: "June",
                6: "July",
                7: "August",
                8: "September",
                9: "October",
                10: "November",
                11: "December"
              },
              dayAbbr: {
                0: "Sun",
                1: "Mon",
                2: "Tue",
                3: "Wed",
                4: "Thu",
                5: "Fri",
                6: "Sat"
              },
              dayName: {
                0: "Sunday",
                1: "Monday",
                2: "Tuesday",
                3: "Wednesday",
                4: "Thursday",
                5: "Friday",
                6: "Saturday"
              },
              timeFormat: "%H:%M:%S",
              dateFormat: "%m/%d/%Y",
              fullDateFormat: "%a %b %e %X %Y",
              amFormat: "AM",
              pmFormat: "PM",
              fullDateTimeFormat: "%a %b %e %X %Z %Y",
              monthNominative: {
                0: "January",
                1: "February",
                2: "March",
                3: "April",
                4: "May",
                5: "June",
                6: "July",
                7: "August",
                8: "September",
                9: "October",
                10: "November",
                11: "December"
              },
              dmFormat: "md",
              twelveTimeFormat: "%I:%M:%S %p"
            },
            be_BY: {
              monthAbbr: {
                0: "сту",
                1: "лют",
                2: "сак",
                3: "кра",
                4: "тра",
                5: "чэр",
                6: "ліп",
                7: "жні",
                8: "вер",
                9: "кас",
                10: "ліс",
                11: "сне"
              },
              monthGenitive: {
                0: "студзеня",
                1: "лютага",
                2: "сакавіка",
                3: "красавіка",
                4: "траўня",
                5: "чэрвеня",
                6: "ліпеня",
                7: "жніўня",
                8: "верасня",
                9: "кастрычніка",
                10: "лістапада",
                11: "снежня"
              },
              dayAbbr: {
                0: "нд ",
                1: "пн ",
                2: "аў ",
                3: "ср ",
                4: "чц ",
                5: "пт ",
                6: "сб "
              },
              dayName: {
                0: "нядзеля",
                1: "панядзелак",
                2: "аўторак",
                3: "серада",
                4: "чацвер",
                5: "пятніца",
                6: "субота"
              },
              timeFormat: "%H:%M:%S",
              dateFormat: "%d.%m.%y",
              fullDateFormat: "%a %e %b %X %Y",
              amFormat: "am",
              pmFormat: "pm",
              fullDateTimeFormat: "%a %e %b %Y %X %Z",
              monthNominative: {
                0: "студзень",
                1: "люты",
                2: "сакавік",
                3: "красавік",
                4: "травень",
                5: "чэрвень",
                6: "ліпень",
                7: "жнівень",
                8: "верасень",
                9: "кастрычнік",
                10: "лістапад",
                11: "снежань"
              },
              dmFormat: "dm",
              twelveTimeFormat: "%I:%M:%S %p"
            },
            tt_RU: {
              monthAbbr: {
                0: "гыйнв",
                1: "фев",
                2: "мар",
                3: "апр",
                4: "май",
                5: "июн",
                6: "июл",
                7: "авг",
                8: "сен",
                9: "окт",
                10: "ноя",
                11: "дек"
              },
              monthGenitive: {
                0: "гыйнвар",
                1: "февраль",
                2: "март",
                3: "апрель",
                4: "май",
                5: "июнь",
                6: "июль",
                7: "август",
                8: "сентябрь",
                9: "октябрь",
                10: "ноябрь",
                11: "декабрь"
              },
              dayAbbr: {
                0: "яб",
                1: "дб",
                2: "сб",
                3: "чб",
                4: "пб",
                5: "җ",
                6: "сб"
              },
              dayName: {
                0: "якшәмбе",
                1: "дүшәмбе",
                2: "сишәмбе",
                3: "чәршәмбе",
                4: "пәнҗешәмбе",
                5: "җомга",
                6: "шимбә"
              },
              timeFormat: "%H:%M:%S",
              dateFormat: "%d.%m.%Y",
              fullDateFormat: "%A, %e %B %Y г. %X",
              amFormat: "",
              pmFormat: "",
              fullDateTimeFormat: "%A, %e %B %Y г. %X (%Z)",
              monthNominative: {
                0: "гыйнвар",
                1: "февраль ",
                2: "март",
                3: "апрель",
                4: "май ",
                5: "июнь ",
                6: "июль ",
                7: "август",
                8: "сентябрь",
                9: "октябрь",
                10: "ноябрь ",
                11: "декабрь"
              },
              dmFormat: "dm",
              twelveTimeFormat: ""
            },
            ru_RU: {
              monthAbbr: {
                0: "янв",
                1: "фев",
                2: "мар",
                3: "апр",
                4: "май",
                5: "июн",
                6: "июл",
                7: "авг",
                8: "сен",
                9: "окт",
                10: "ноя",
                11: "дек"
              },
              monthGenitive: {
                0: "января",
                1: "февраля",
                2: "марта",
                3: "апреля",
                4: "мая",
                5: "июня",
                6: "июля",
                7: "августа",
                8: "сентября",
                9: "октября",
                10: "ноября",
                11: "декабря"
              },
              dayAbbr: {
                0: "вс",
                1: "пн",
                2: "вт",
                3: "ср",
                4: "чт",
                5: "пт",
                6: "сб"
              },
              dayName: {
                0: "воскресенье",
                1: "понедельник",
                2: "вторник",
                3: "среда",
                4: "четверг",
                5: "пятница",
                6: "суббота"
              },
              timeFormat: "%H:%M:%S",
              dateFormat: "%d.%m.%Y",
              fullDateFormat: "%A, %e %B %Y г. %X",
              amFormat: "",
              pmFormat: "",
              fullDateTimeFormat: "%A, %e %B %Y г. %X (%Z)",
              monthNominative: {
                0: "январь",
                1: "февраль",
                2: "март",
                3: "апрель",
                4: "май",
                5: "июнь",
                6: "июль",
                7: "август",
                8: "сентябрь",
                9: "октябрь",
                10: "ноябрь",
                11: "декабрь"
              },
              dmFormat: "dm",
              twelveTimeFormat: ""
            },
            en_CA: {
              monthAbbr: {
                0: "Jan",
                1: "Feb",
                2: "Mar",
                3: "Apr",
                4: "May",
                5: "Jun",
                6: "Jul",
                7: "Aug",
                8: "Sep",
                9: "Oct",
                10: "Nov",
                11: "Dec"
              },
              monthGenitive: {
                0: "January",
                1: "February",
                2: "March",
                3: "April",
                4: "May",
                5: "June",
                6: "July",
                7: "August",
                8: "September",
                9: "October",
                10: "November",
                11: "December"
              },
              dayAbbr: {
                0: "Sun",
                1: "Mon",
                2: "Tue",
                3: "Wed",
                4: "Thu",
                5: "Fri",
                6: "Sat"
              },
              dayName: {
                0: "Sunday",
                1: "Monday",
                2: "Tuesday",
                3: "Wednesday",
                4: "Thursday",
                5: "Friday",
                6: "Saturday"
              },
              timeFormat: "%H:%M:%S",
              dateFormat: "%d/%m/%Y",
              fullDateFormat: "%a %e %b %X %Y",
              amFormat: "am",
              pmFormat: "pm",
              fullDateTimeFormat: "%a %e %b %Y %X %Z",
              monthNominative: {
                0: "January",
                1: "February",
                2: "March",
                3: "April",
                4: "May",
                5: "June",
                6: "July",
                7: "August",
                8: "September",
                9: "October",
                10: "November",
                11: "December"
              },
              dmFormat: "dm",
              twelveTimeFormat: "%I:%M:%S %p"
            },
            en_GB: {
              monthAbbr: {
                0: "Jan",
                1: "Feb",
                2: "Mar",
                3: "Apr",
                4: "May",
                5: "Jun",
                6: "Jul",
                7: "Aug",
                8: "Sep",
                9: "Oct",
                10: "Nov",
                11: "Dec"
              },
              monthGenitive: {
                0: "January",
                1: "February",
                2: "March",
                3: "April",
                4: "May",
                5: "June",
                6: "July",
                7: "August",
                8: "September",
                9: "October",
                10: "November",
                11: "December"
              },
              dayAbbr: {
                0: "Sun",
                1: "Mon",
                2: "Tue",
                3: "Wed",
                4: "Thu",
                5: "Fri",
                6: "Sat"
              },
              dayName: {
                0: "Sunday",
                1: "Monday",
                2: "Tuesday",
                3: "Wednesday",
                4: "Thursday",
                5: "Friday",
                6: "Saturday"
              },
              timeFormat: "%H:%M:%S",
              dateFormat: "%d/%m/%Y",
              fullDateFormat: "%a %e %b %X %Y",
              amFormat: "am",
              pmFormat: "pm",
              fullDateTimeFormat: "%a %e %b %Y %X %Z",
              monthNominative: {
                0: "January",
                1: "February",
                2: "March",
                3: "April",
                4: "May",
                5: "June",
                6: "July",
                7: "August",
                8: "September",
                9: "October",
                10: "November",
                11: "December"
              },
              dmFormat: "dm",
              twelveTimeFormat: "%I:%M:%S %p"
            },
            en_IE: {
              monthAbbr: {
                0: "Jan",
                1: "Feb",
                2: "Mar",
                3: "Apr",
                4: "May",
                5: "Jun",
                6: "Jul",
                7: "Aug",
                8: "Sep",
                9: "Oct",
                10: "Nov",
                11: "Dec"
              },
              monthGenitive: {
                0: "January",
                1: "February",
                2: "March",
                3: "April",
                4: "May",
                5: "June",
                6: "July",
                7: "August",
                8: "September",
                9: "October",
                10: "November",
                11: "December"
              },
              dayAbbr: {
                0: "Sun",
                1: "Mon",
                2: "Tue",
                3: "Wed",
                4: "Thu",
                5: "Fri",
                6: "Sat"
              },
              dayName: {
                0: "Sunday",
                1: "Monday",
                2: "Tuesday",
                3: "Wednesday",
                4: "Thursday",
                5: "Friday",
                6: "Saturday"
              },
              timeFormat: "%H:%M:%S",
              dateFormat: "%d/%m/%Y",
              fullDateFormat: "%a %e %b %X %Y",
              amFormat: "am",
              pmFormat: "pm",
              fullDateTimeFormat: "%a %e %b %Y %X %Z",
              monthNominative: {
                0: "January",
                1: "February",
                2: "March",
                3: "April",
                4: "May",
                5: "June",
                6: "July",
                7: "August",
                8: "September",
                9: "October",
                10: "November",
                11: "December"
              },
              dmFormat: "dm",
              twelveTimeFormat: "%I:%M:%S %p"
            },
            en_AU: {
              monthAbbr: {
                0: "Jan",
                1: "Feb",
                2: "Mar",
                3: "Apr",
                4: "May",
                5: "Jun",
                6: "Jul",
                7: "Aug",
                8: "Sep",
                9: "Oct",
                10: "Nov",
                11: "Dec"
              },
              monthGenitive: {
                0: "January",
                1: "February",
                2: "March",
                3: "April",
                4: "May",
                5: "June",
                6: "July",
                7: "August",
                8: "September",
                9: "October",
                10: "November",
                11: "December"
              },
              dayAbbr: {
                0: "Sun",
                1: "Mon",
                2: "Tue",
                3: "Wed",
                4: "Thu",
                5: "Fri",
                6: "Sat"
              },
              dayName: {
                0: "Sunday",
                1: "Monday",
                2: "Tuesday",
                3: "Wednesday",
                4: "Thursday",
                5: "Friday",
                6: "Saturday"
              },
              timeFormat: "%H:%M:%S",
              dateFormat: "%d/%m/%Y",
              fullDateFormat: "%a %e %b %X %Y",
              amFormat: "am",
              pmFormat: "pm",
              fullDateTimeFormat: "%a %e %b %Y %X %Z",
              monthNominative: {
                0: "January",
                1: "February",
                2: "March",
                3: "April",
                4: "May",
                5: "June",
                6: "July",
                7: "August",
                8: "September",
                9: "October",
                10: "November",
                11: "December"
              },
              dmFormat: "dm",
              twelveTimeFormat: "%I:%M:%S %p"
            },
            cs_CZ: {
              monthAbbr: {
                0: "led",
                1: "úno",
                2: "bře",
                3: "dub",
                4: "kvě",
                5: "črv",
                6: "čvc",
                7: "srp",
                8: "zář",
                9: "říj",
                10: "lis",
                11: "pro"
              },
              monthGenitive: {
                0: "ledna",
                1: "února",
                2: "března",
                3: "dubna",
                4: "května",
                5: "června",
                6: "července",
                7: "srpna",
                8: "září",
                9: "října",
                10: "listopadu",
                11: "prosince"
              },
              dayAbbr: {
                0: "ne",
                1: "po",
                2: "út",
                3: "st",
                4: "čt",
                5: "pá",
                6: "so"
              },
              dayName: {
                0: "neděle",
                1: "pondělí",
                2: "úterý",
                3: "středa",
                4: "čtvrtek",
                5: "pátek",
                6: "sobota"
              },
              timeFormat: "%H:%M:%S",
              dateFormat: "%Y/%m/%d",
              fullDateFormat: "%a %e %b %X %Y",
              amFormat: "dp",
              pmFormat: "od",
              fullDateTimeFormat: "%a %e. %B %Y %X %Z",
              monthNominative: {
                0: "leden",
                1: "únor",
                2: "březen",
                3: "duben",
                4: "květen",
                5: "červen",
                6: "červenec",
                7: "srpen",
                8: "září",
                9: "říjen",
                10: "listopad",
                11: "prosinec"
              },
              dmFormat: "dm",
              twelveTimeFormat: "%I:%M:%S %p"
            }
          }
        };
      e({
        UnitsTransform: s,
        FormatDatetime: n
      })
    });
  }],
  ['.W', function(ym) {
    ym.modules.define("localization.units.current", function(n) {
      return ["localization.units." + n.env.lang.substr(0, 2)]
    }, function(n, i) {
      n(i || {})
    });
  }],
  ['.5', function(ym) {
    ym.modules.define("localization.units.ru", [], function(d) {
      d({
        distance: {
          centimeters: "%d&#160;см",
          "centimeters full": ["%d&#160;сантиметр", "%d&#160;сантиметра", "%d&#160;сантиметров", "%d&#160;сантиметров"],
          feet: ["%d&#160;фут", "%d&#160;фута", "%d&#160;футов", "%d&#160;футов"],
          "feet full": ["%d&#160;фут", "%d&#160;фута", "%d&#160;футов", "%d&#160;футов"],
          inches: ["%d&#160;дюйм", "%d&#160;дюйма", "%d&#160;дюймов", "%d&#160;дюймов"],
          "inches full": ["%d&#160;дюйм", "%d&#160;дюйма", "%d&#160;дюймов", "%d&#160;дюймов"],
          kilometers: "%d&#160;км",
          "kilometers full": ["%d&#160;километр", "%d&#160;километра", "%d&#160;километров", "%d&#160;километров"],
          meters: "%d&#160;м",
          "meters full": ["%d&#160;метр", "%d&#160;метра", "%d&#160;метров", "%d&#160;метров"],
          miles: ["%d&#160;миля", "%d&#160;мили", "%d&#160;миль", "%d&#160;миль"],
          "miles full": ["%d&#160;миля", "%d&#160;мили", "%d&#160;миль", "%d&#160;миль"]
        },
        duration: {
          days: "%d&#160;д",
          "days full": ["%d&#160;день", "%d&#160;дня", "%d&#160;дней", "%d&#160;дней"],
          hours: "%d&#160;ч",
          "hours full": ["%d&#160;час", "%d&#160;часа", "%d&#160;часов", "%d&#160;часов"],
          minutes: "%d&#160;мин",
          "minutes full": ["%d&#160;минута", "%d&#160;минуты", "%d&#160;минут", "%d&#160;минут"],
          seconds: "%d&#160;сек",
          "seconds full": ["%d&#160;секунда", "%d&#160;секунды", "%d&#160;секунд", "%d&#160;секунд"],
          years: ["%d&#160;год", "%d&#160;года", "%d&#160;лет", "%d&#160;лет"],
          "years full": ["%d&#160;год", "%d&#160;года", "%d&#160;лет", "%d&#160;лет"]
        },
        temperature: {
          celsiuses: "%d°C",
          fahrenheits: "%d°F"
        },
        velocity: {
          "kilometers per hour": "%d&#160;км/ч",
          "kilometers per hour full": ["%d&#160;километр в&#160;час", "%d&#160;километра в&#160;час", "%d&#160;километров в&#160;час", "%d&#160;километров в&#160;час"],
          "miles per hour": ["%d&#160;миля/ч", "%d&#160;мили/ч", "%d&#160;миль/ч", "%d&#160;миль/ч"],
          "miles per hour full": ["%d&#160;миля в&#160;час", "%d&#160;мили в&#160;час", "%d&#160;миль в&#160;час", "%d&#160;миль в&#160;час"]
        }
      })
    });
  }],
  ['1m', function(ym) {
    ym.modules.define("Map", ["util.defineClass", "map.Container", "map.Converter", "map.Copyrights", "map.ZoomRange", "map.metaOptions", "map.event.Manager", "map.behavior.Manager", "map.pane.Manager", "map.action.Manager", "map.layer.Manager", "pane.EventsPane", "data.Manager", "domEvent.manager", "constants.paneZIndex", "MapEvent", "event.Mapper", "event.globalize", "mapType.storage", "map.action.Single", "map.action.Sequence", "map.action.AreaRestrictionManager", "map.margin.Manager", "option.Manager", "map.optionMapper", "hotspot.Manager", "LayerCollection", "layer.storage", "constants.zIndex", "util.bounds", "util.requireCenterAndZoom", "util.coordinates.getClosestPixelPosition", "util.animation.getFlyingTicks", "util.math.areEqual", "util.dom.element", "vow", "getZoomRange", "map.GeoObjects", "util.id", "control.Manager", "yandex.state.component.Map", "yandex.state.component.MapGeoObjects", "yandex.counter", "yandex.counterStorage", "util.margin", "system.browser"], function(e, t, n, i, o, s, a, r, h, l, c, g, p, m, d, u, _, y, v, f, b, C, M, x, z, w, P, Z, S, j, G, T, A, E, k, R, O, B, F, L, I, N, q, D, H, K, J) {
      function Q(e, t, _) {
        if (ym.env.debug) {
          if (!e) throw new Error("Map.constructor: the map container is specified incorrectly");
          if (!t) throw new Error("Map.constructor: не переданы параметры")
        }
        this.options = new z(_, a, "map", w), this.options.events.add("change", this._onOptionsChange, this), this.events = new r({
          controllers: [U],
          context: this
        }), this.state = new m({
          margin: [0, 0, 0, 0]
        }), this.container = new n(e, this), this.container.events.setParent(new y(this.events, this.createEventMappingTable())), this.container.events.add("sizechange", this._onContainerSizeChange, this), this._containerSize = this.container.getSize(), this._containerEventListener = d.group(this.container.getElement()).add("mousedown", this._onContainerMouseDown, this, !0), this.converter = new i(this), this.margin = new x(this), this.margin.events.add("change", this._onMarginChange, this);
        var v, f, b, C = this.options.get("avoidFractionalZoom", !1),
          Z = this.options.get("minZoom"),
          S = this.options.get("maxZoom");
        t.bounds && (b = G.getCenterAndZoom(t.bounds, this.container.getSize(), this.options.get("projection"), {
          preciseZoom: C,
          inscribe: !0
        })), b ? (v = b.zoom, f = b.center) : (v = t.zoom, f = t.center), this._zoom = Math.max(Math.min(Number(v), S), Z), C && (this._zoom = Math.round(this._zoom)), this._type = "undefined" != typeof t.type ? t.type : this.options.get("defaultMapType"), this._projection = this.options.get("projection"), this._globalPixelCenter = this._projection.toGlobalPixels(f, this._zoom), this._bounds = this.getBounds(), this.panes = new l(this);
        var j = new p(this, {
          zIndex: u.events
        });
        this.panes.append("events", j), this._hotspotManager = new P(j), this.cursors = j.cursors, this.action = new c(this), this.action.events.add("statechange", this._onActionChange, this).add(["begin", "tick", "tickcomplete", "break", "end", "render"], this._onAction, this), this.layers = new g(this), this._type && this._addType(), this.zoomRange = new s(this, ["undefined" == typeof Z ? 0 : Z, "undefined" == typeof S ? 23 : S]), this.zoomRange.addProvider(this.layers), this.copyrights = new o(this), this.copyrights.addProvider(this.layers), this.behaviors = new h(this, t.behaviors || "default"), this._restrictMapArea = new M(this), this.zoomRange.addProvider(this._restrictMapArea, !0), this.action.setupRestrictArea(this._restrictMapArea), this.geoObjects = new F(this), this.controls = new I(this, t && t.controls || this.options.get("defaultControls"), {
          states: ["small", "medium", "large"],
          margin: 10
        }), this._yandexState = new N(this), this._yandexStateGeoObjects = new q(this.geoObjects), D.countByKey("map", [J.platform, D.versionPrefix].join(".")), this.events.fire("create", {
          map: this,
          state: t
        })
      }
      var U;
      Q.TypeNotChangedError = function() {
        return new Error("Type has not changed")
      }, U = v(Q), t(Q, {
        getCenter: function(e) {
          return this._projection.fromGlobalPixels(this.getGlobalPixelCenter(e), this._zoom)
        },
        setCenter: function(e, t, n) {
          n = n || {};
          var i = "undefined" == typeof t ? this._zoom : Number(t),
            o = this._projection.toGlobalPixels(e, i);
          return this.setGlobalPixelCenter(o, i, n)
        },
        panTo: function(e, t) {
          t = t || {};
          for (var n = O.defer(), i = e[0].length ? e : [e], o = [], s = this.container.getSize(), a = [2 * s[0], 2 * s[1]], r = "undefined" == typeof t.flying || t.flying, h = "undefined" == typeof t.safe || t.safe, l = 0, c = i.length; l < c; l++) o.push({
            center: i[l],
            delay: l > 0 ? "undefined" == typeof t.delay ? 1e3 : t.delay : 0,
            zoom: this._zoom,
            duration: "undefined" == typeof t.duration ? 500 : t.duration,
            checkZoomRange: t.checkZoomRange,
            useMapMargin: t.useMapMargin,
            timingFunction: t.timingFunction || "ease-in-out"
          });
          for (var g = this._globalPixelCenter, l = 0, c = o.length; l < c; l++) {
            var p = o[l],
              m = this._projection.toGlobalPixels(p.center, this._zoom);
            if (p.globalPixelCenter = A(g, m, this._zoom, this._projection), !r && h) {
              var d = [Math.abs(p.globalPixelCenter[0] - g[0]), Math.abs(p.globalPixelCenter[1] - g[1])];
              (d[0] > a[0] || d[1] > a[1]) && (p.duration = 0)
            }
            g = p.globalPixelCenter
          }
          r && (o = E(o, this));
          var u = new C(o, {
            callback: this._createActionEndCallback(n)
          });
          return u.begin(this.action), n.promise()
        },
        getBounds: function(e) {
          var t = this.getGlobalPixelCenter(e),
            n = this.container.getSize();
          if (e && e.useMapMargin) {
            var i = this.margin.getMargin();
            n = [n[0] - (i[1] + i[3]), n[1] - (i[0] + i[2])]
          }
          var o = [
            [t[0] - .5 * n[0], t[1] - .5 * n[1]],
            [t[0] + .5 * n[0], t[1] + .5 * n[1]]
          ];
          return G.fromGlobalPixelBounds(o, this.getZoom(), this._projection)
        },
        setBounds: function(e, t) {
          if (t = t || {}, t.zoomMargin && (t.margin = t.zoomMargin, this.options.get("avoidFractionalZoom", !1) && (t.preciseZoom = !1)), t.useMapMargin && (t.margin = K.sum([t.margin || 0, this.margin.getMargin()]), t.useMapMargin = !1), t.projection = this._projection, t.checkZoomRange) {
            var n = O.defer();
            return T(this.zoomRange, e, this.container.getSize(), t).then(function(e) {
              n.resolve(this.setCenter(e.center, e.zoom, t))
            }, function(e) {
              n.reject(e)
            }, this), n.promise()
          }
          var i = G.getCenterAndZoom(e, this.container.getSize(), this._projection, t);
          return this.setCenter(i.center, i.zoom, t)
        },
        getGlobalPixelCenter: function(e) {
          var t = this._globalPixelCenter.slice();
          if (e && e.useMapMargin) {
            var n = this.margin.getMargin();
            t[0] += (n[3] - n[1]) / 2, t[1] += (n[0] - n[2]) / 2
          }
          return t
        },
        setGlobalPixelCenter: function(e, t, n) {
          n = n || {};
          var i = O.defer();
          return this.action.execute(new b({
            globalPixelCenter: e.slice(),
            zoom: "undefined" != typeof t ? t : this._zoom,
            duration: n.duration || 0,
            callback: this._createActionEndCallback(i),
            checkZoomRange: n.checkZoomRange,
            useMapMargin: n.useMapMargin,
            timingFunction: n.timingFunction
          })), i.promise()
        },
        getZoom: function() {
          return this._zoom
        },
        setZoom: function(e, t) {
          e = Math.min(Math.max(e, this.options.get("minZoom", 0)), this.options.get("maxZoom", 23));
          var n = this.getGlobalPixelCenter(t),
            i = Math.pow(2, e - this.getZoom());
          return n = [n[0] * i, n[1] * i], this.setGlobalPixelCenter(n, e, t)
        },
        _onContainerSizeChange: function(e) {
          var t = this._bounds,
            n = e.get("oldOffset"),
            i = e.get("oldSize");
          this._containerSize = this.container.getSize(), this.events.fire("sizechange", {
            map: this,
            oldSize: i,
            newSize: e.get("newSize")
          });
          var o = this._zoom,
            s = this.getCenter(),
            a = this._globalPixelCenter;
          if (e.get("preservePixelPosition")) {
            this.action.stop(), a = this._globalPixelCenter;
            var r = [n[0] + i[0] / 2, n[1] + i[1] / 2],
              h = this.converter.globalToPage(this._globalPixelCenter),
              l = r[0] - h[0],
              c = r[1] - h[1];
            this.setGlobalPixelCenter([a[0] - l, a[1] - c])
          } else {
            this._bounds = this.getBounds();
            var g = this.getCenter(),
              p = this._globalPixelCenter;
            this.events.fire("boundschange", {
              map: this,
              oldZoom: o,
              newZoom: o,
              oldCenter: s,
              newCenter: g,
              oldGlobalPixelCenter: a,
              newGlobalPixelCenter: p,
              oldBounds: t,
              newBounds: this._bounds
            })
          }
        },
        getType: function() {
          return this._type
        },
        setType: function(e, t) {
          var n = this._type;
          if (n == e) return O.reject(Q.TypeNotChangedError());
          var i = t && t.checkZoomRange,
            o = O.defer();
          return i ? B(e, this.getCenter(), this.layers).then(function(t) {
            var n = this.getZoom();
            this._setMapType(e, t[0] > n ? t[0] : t[1] < n ? t[1] : n), o.resolve()
          }, this) : (this._setMapType(e), o.resolve()), o.promise()
        },
        _setMapType: function(e, t) {
          "undefined" != typeof t && this.getZoom() != t && this.setZoom(t);
          var n = this._type;
          n && this._removeType(), this._type = e, e && this._addType(), this.events.fire("typechange", {
            map: this
          })
        },
        _addType: function() {
          for (var e = "string" == typeof this._type ? f.get(this._type) : this._type, t = new Z({
              zIndex: j.mapTypeLayer,
              tilesRoundingMethod: this.options.get("tilesRoundingMethod")
            }), n = e.getLayers(), i = 0, o = n.length; i < o; i++) {
            var s = "string" == typeof n[i] ? S.get(n[i]) : n[i],
              a = new s;
            t.add(a)
          }
          this._layerCollection = t, this.layers.add(t)
        },
        _removeType: function() {
          this._layerCollection && (this._layerCollection.removeAll(), this.layers.remove(this._layerCollection), this._layerCollection = null)
        },
        _onOptionsChange: function() {
          this.events.fire("optionschange")
        },
        _onAction: function(e) {
          var t = "action" + e.get("type");
          this.events.fire(t, {
            map: this,
            action: e.get("action"),
            tick: e.get("tick")
          })
        },
        _onActionChange: function(e) {
          var t, n = this.getCenter(),
            i = this._bounds,
            o = this._zoom,
            s = this._containerSize,
            a = this.container.getSize(),
            r = this._globalPixelCenter,
            h = e.get("globalPixelCenter"),
            l = e.get("zoom"),
            c = Math.pow(2, l - this.options.get("maxZoom"));
          o == l && k(s, a) && k(r, h, c) || (this._globalPixelCenter = h, this._zoom = l, this._bounds = this.getBounds(), this._containerSize = a, t = this.getCenter(), this.events.fire("boundschange", {
            map: this,
            oldCenter: n,
            newCenter: t,
            oldGlobalPixelCenter: r,
            newGlobalPixelCenter: this._globalPixelCenter,
            oldZoom: o,
            newZoom: this._zoom,
            oldBounds: i,
            newBounds: this._bounds
          }))
        },
        _createActionEndCallback: function(e) {
          return function(t) {
            t ? e.reject(t) : e.resolve()
          }
        },
        createEventMappingTable: function() {
          return {
            _map: this,
            "*": function(e) {
              var t = null;
              return e.isMapEventAllowed() && (t = new _({
                type: e.get("type"),
                target: this._map,
                map: this._map
              }, e)), t
            },
            sizechange: !1
          }
        },
        destroy: function() {
          this._containerEventListener.removeAll(), this._type && this._removeType(), this._restrictMapArea.destroy(), this.action.events.remove("statechange", this._onActionChange, this).remove(["begin", "tick", "tickcomplete", "break", "end"], this._onAction, this), this._hotspotManager.destroy(), this.panes.destroy(), this.margin.events.remove("change", this._onMarginChange, this), this.margin.destroy(), this.container.events.setParent(null), this.container.events.remove("sizechange", this._onContainerSizeChange, this), this.container.destroy(), this.options.events.remove("change", this._onOptionsChange, this), this._yandexState && this._yandexState.destroy(), this._yandexStateGeoObjects && this._yandexStateGeoObjects.destroy(), this._yandexState = null, this._yandexStateGeoObjects = null, this.events.fire("destroy", {
            map: this
          }), this.options.setParent(null)
        },
        _onContainerMouseDown: function(e) {
          if (this.options.get("mapAutoFocus", !0)) {
            var t = document.activeElement;
            e.get("target") != t && (t != document.body && R.isHTMLElement(t) && t.blur(), J.isIE && window.focus())
          }
        },
        _onMarginChange: function(e) {
          this.events.fire("marginchange")
        }
      }), e(Q)
    });
  }],
  ['_.', function(ym) {
    ym.modules.define('map-copyrights-promo', ['system.provideCss'], function(provide, provideCss) {
      provideCss("@media print{.ymaps-2-1-42-map-copyrights-promo{visibility:hidden}}", provide);
    });
  }],
  ['_)', function(ym) {
    ym.modules.define('map-css', ['system.provideCss'], function(provide, provideCss) {
      provideCss(".ymaps-2-1-42-map{position:relative;z-index:0;display:block;margin:0!important;padding:0!important;text-align:left!important;font-weight:400!important;line-height:normal;-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-print-color-adjust:exact;-webkit-transform:translate3d(0,0,0)}.ymaps-2-1-42-map ymaps,.ymaps-2-1-42-map ymaps:after,.ymaps-2-1-42-map ymaps:before{-moz-box-sizing:content-box;box-sizing:content-box}.ymaps-2-1-42-map,a .ymaps-2-1-42-map{text-decoration:none!important;color:#000;font-style:normal!important}.ymaps-2-1-42-fullscreen{overflow:hidden!important}.ymaps-2-1-42-touch-action-none{-ms-touch-action:none;touch-action:none}.ymaps-2-1-42-user-selection-none,.ymaps-2-1-42-user-selection-none *{-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;-o-user-select:none;user-select:none}.ymaps-2-1-42-display-none{display:none!important}ymaps,ymaps canvas,ymaps i,ymaps input{max-width:none;max-height:none}.ymaps-2-1-42-areas-pane,.ymaps-2-1-42-balloon-pane,.ymaps-2-1-42-controls-pane,.ymaps-2-1-42-controls__bottom,.ymaps-2-1-42-controls__toolbar,.ymaps-2-1-42-events-pane,.ymaps-2-1-42-ground-pane,.ymaps-2-1-42-map-copyrights-promo,.ymaps-2-1-42-panel-pane,.ymaps-2-1-42-places-pane,.ymaps-2-1-42-ruler-balloon-pane,.ymaps-2-1-42-ruler-line-pane,.ymaps-2-1-42-searchpanel-pane{left:0}.ymaps-2-1-42-controls-pane *,.ymaps-2-1-42-searchpanel-pane *{text-align:left}@media print{.ymaps-2-1-42-patched-for-print{background:0 0!important;display:list-item!important;list-style-position:inside!important}}.ymaps-2-1-42-patched-for-print-preload .ymaps-2-1-42-patched-for-print{background:0 0!important;display:list-item!important;list-style-position:inside!important}", provide);
    });
  }],
  ['_J', function(ym) {
    ym.modules.define('map-pane-manager', ['system.provideCss'], function(provide, provideCss) {
      provideCss(".ymaps-2-1-42-inner-panes,.ymaps-2-1-42-outer-panes{display:block;position:absolute;padding:0!important;margin:0!important}.ymaps-2-1-42-inner-panes{overflow:hidden;width:100%;height:100%}.ymaps-2-1-42-outer-panes{width:0;height:0}", provide);
    });
  }],
  ['3*', function(ym) {
    ym.modules.define("map-ru-css", function(n) {
      return [this.name + (n.env.browser.oldIE ? ".ie8" : ".standards")]
    }, function(n) {
      n({})
    });
  }],
  ['.e', function(ym) {
    ym.modules.define('map-ru-css.standards', ['system.provideCss'], function(provide, provideCss) {
      provideCss(".ymaps-2-1-42-map-bg-ru{background:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAzIiBoZWlnaHQ9IjgxIiB2aWV3Qm94PSIwIDAgMjAzIDgxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Ik0zMy41OS4xMkgyMi44M0MxMi4yOC4xMiAzLjMyIDguMTYgMy4zMiAyMy43N2MwIDkuMzcgNC4zNCAxNi4yNyAxMi4wNyAxOS42OEwuOTYgNjkuNTVjLS40Ny44NSAwIDEuNTEuNzUgMS41MWg2LjdjLjU2IDAgLjk0LS4xOCAxLjEzLS42NmwxMy4xLTI1LjYzaDQuNzJWNzAuNGMwIC4yOS4yOS42Ni42Ni42Nmg1Ljg1Yy41NyAwIC43NS0uMjguNzUtLjc1VjEuMDdjMC0uNjYtLjM3LS45NS0xLjAzLS45NXptLTYuMjMgMzguNkgyMy40Yy02LjIyIDAtMTIuMjYtNC41NS0xMi4yNi0xNS45QzExLjE0IDExIDE2LjggNi4xOCAyMi41NSA2LjE4aDQuODF2MzIuNTR6bTAgMCIgZmlsbD0iI0ZGNEM0QyIvPjxwYXRoIGQ9Ik02OS4wMyAyMy42NGgtNS44NWMtLjQ3IDAtLjc1LjM4LS43NS42NnYxOC4wN0g1MS41OFYyNC4zYzAtLjQ3LS4xOC0uNjYtLjY2LS42NmgtNS44NGMtLjQ3IDAtLjc2LjI4LS43Ni42NnY0NS45N2MwIC40OC4yLjc2LjY2Ljc2aDUuOTRjLjM4IDAgLjY2LS4yOS42Ni0uNzZWNDguMzNoMTAuODV2MjEuOTRjMCAuNDguMjguNzYuNzUuNzZoNS44NWMuNDcgMCAuNjYtLjM4LjY2LS43NlYyNC4zYS42NC42NCAwIDAgMC0uNjYtLjY2ek0yMDIuNSA2OGwtLjc1LTMuMjFjLS4xLS4yOS0uMTktLjM4LS40Ny0uMzgtLjQ3IDAtMy4wMiAxLjA0LTYuNyAxLjA0LTcuMTYgMC0xMC42NS02LjktMTAuNjUtMTcuODggMC05LjY1IDIuOTItMTkuMiA3LjgzLTE5LjIgMS4zMiAwIDIuOTIuMzggNS40NiAyLjc0LjI5LjI5LjQ4LjM4Ljc2LjM4cy41Ni0uMTkuODUtLjY2bDIuNTQtNC4xNmMuMi0uMjkuMjktLjU3LjI5LS44NiAwLS4zOC0uMzgtLjY2LS45NS0uOTQtMy44Ni0xLjk5LTYuNS0yLjM3LTguNzctMi4zNy04Ljg2IDAtMTUuNzUgMTAuNi0xNS43NSAyNy4xNSAwIDE0LjI4IDYuNiAyMi41MSAxNi4wNCAyMi41MSAzLjk2IDAgOC4yLTEuODkgOS45LTMuMTIuMzctLjI4LjQ3LS42Ni4zNy0xLjA0em0tNDAuOTgtMjIuOThsMTEuMzItMjAuNzJjLjE5LS4yOC4wOS0uNjYtLjI5LS42NkgxNjdjLTEuNiAwLTIuMTcuNTctMi43MyAxLjhsLTguNSAxNy42OWMtLjQ2IDEuMDQtLjkzIDEuNy0xLjQgMS45OFYyNC4zYzAtLjM4LS4yLS42Ni0uNTctLjY2aC02LjEzYy0uMjggMC0uNTYuMjgtLjU2LjY2djQ2LjA3YzAgLjI4LjE4LjY2LjU2LjY2aDYuMTNjLjM4IDAgLjU3LS4yOC41Ny0uNjZWNDYuNjJjLjI4LjIuNDcuNDguNjYuODZsMTAuNzUgMjIuMTNjLjU2IDEuMTMgMS40MSAxLjQyIDIuNjQgMS40Mmg2LjAzYy4zOCAwIC40Ny0uMzguMjgtLjY2TDE2MS41MyA0NXpNMTA3LjUgNjUuMDZoLTEuMTNjLTEuNDIgMC0xLjgtLjU3LTEuOC0xLjdWMjQuM2MwLS40Ny0uMTgtLjY2LS41Ni0uNjZIODUuMTVjLS40NyAwLS43NS4yOC0uNzUuNjZ2My40YzAgMTEuNDUtLjY2IDI2LjItNi43IDM3LjM3aC0yLjA3Yy0uNTcgMC0uNzYuMjgtLjc2Ljc2djEzLjhjMCAuNDguMzguNjcuNjYuNjdoNC41M2MxLjAzIDAgMS40MS0uNzYgMS40MS0xLjQydi03Ljg1aDIwLjE4djguNmMwIC4zOC4yOC42Ny42Ni42N2g0LjgxYy41NyAwIDEuMTMtLjQ3IDEuMTMtMS40MlY2NS44M2MwLS40Ny0uMjgtLjc2LS43NS0uNzZ6bS0xMC4xOCAwSDgzLjY0YzQuODEtOC4yMyA2LjctMTcuNSA3LjM2LTI4Ljg1LjE5LTIuNDYuMjgtNS4wMS4yOC02LjYyaDYuMDR2MzUuNDd6bTI5LjQyLTQyLjU2Yy0xMC4xOSAwLTE0LjcxIDEyLjg2LTE0LjcxIDI2Ljg2IDAgMTQuMjggNi40IDIyLjggMTUuODQgMjIuOCA0LjYyIDAgOC42Ny0xLjggMTAuNzUtMy4xMy4zOC0uMTkuNDctLjQ3LjM4LS44NWwtLjc2LTMuMjFjLS4xLS4zOC0uMjgtLjU3LS43NS0uNTctLjM4IDAtMy4xMSAxLjA0LTYuOTggMS4wNC03LjI2IDAtMTAuNjYtNi4zNC0xMC42Ni0xNC42NnYtMi4yNHMzLjY4LjQ0IDUuODUuNDRoMTMuNzd2LTMuOTdjMC0xNC42Ni01LjItMjIuNTEtMTIuNzMtMjIuNTF6bS0xLjA0IDIwLjUyYy0yLjE3IDAtNS41Ni4zOC01LjU2LjM4czAtMS40Mi4xOS0yLjkzYy44NC04LjA0IDIuODItMTIuMSA2LjEyLTEyLjEgMy4wMiAwIDQuOSA0LjE1IDUuMzggMTEuNDQuMSAxLjUuMSAzLjIxLjEgMy4yMWgtNi4yM3ptMCAwIiBmaWxsPSIjNTk1OTU5Ii8+PC9zdmc+) #fafafa center no-repeat}", provide);
    });
  }],
  ['.$', function(ym) {
    ym.modules.define("map.action.AreaRestrictionManager", ["util.defineClass", "event.Manager", "map.action.Single", "util.bounds", "util.array", "Monitor", "vow"], function(t, i, e, o, n, s, r, a) {
      var c = function(t) {
        this._map = t, this.events = new e, this._restrictBounds = null, this._minZoom = null, this._calculate(), this._setupListeners()
      };
      i(c, {
        getArea: function() {
          return this._restrictBounds
        },
        getZoomRange: function() {
          var t = this._map.options,
            i = t.get("minZoom", 0);
          return i = Math.max(i, this._minZoom), a.resolve([i, t.get("maxZoom")])
        },
        correctTick: function(t) {
          if (this._restrictBounds) {
            var i = this._map.container.getSize(),
              e = n.toGlobalPixelBounds(this._restrictBounds, t.zoom, this._map.options.get("projection")),
              o = [i[0] / 2, i[1] / 2],
              s = [
                [t.globalPixelCenter[0] - o[0], t.globalPixelCenter[1] - o[1]],
                [t.globalPixelCenter[0] + o[0], t.globalPixelCenter[1] + o[1]]
              ],
              r = [0, 0];
            e[0][0] > s[0][0] ? r[0] = e[0][0] - s[0][0] : e[1][0] < s[1][0] && (r[0] = e[1][0] - s[1][0]), e[0][1] > s[0][1] ? r[1] = e[0][1] - s[0][1] : e[1][1] < s[1][1] && (r[1] = e[1][1] - s[1][1]), (r[0] || r[1]) && (t.globalPixelCenter[0] += r[0], t.globalPixelCenter[1] += r[1])
          }
        },
        fixZoom: function(t) {
          if (this._restrictBounds) {
            var i = this._map.options,
              e = n.getCenterAndZoom(this._restrictBounds, this._map.container.getSize(), i.get("projection"), {
                inscribe: !1,
                preciseZoom: !0
              });
            i.get("avoidFractionalZoom") && (e.zoom = Math.ceil(e.zoom)), t < e.zoom && (t = e.zoom);
            var o = Math.ceil(e.zoom);
            this._minZoom != o && (this._minZoom = o)
          }
          return t
        },
        destroy: function() {
          this._clearListeners(), this._restrictBounds = null, this._minZoom = null
        },
        _setupListeners: function() {
          this._mapOptionsMonitor = new r(this._map.options).add("restrictMapArea", this._onRestrictOptionsChange, this), this._mapListeners = this._map.events.group().add(["sizechange", "create"], this._runAction, this)
        },
        _clearListeners: function() {
          this._mapOptionsMonitor.destroy(), this._mapListeners.removeAll()
        },
        _calculate: function() {
          var t = this._map.options.get("restrictMapArea", !1);
          if (t) {
            if (s.isArray(t)) this._restrictBounds = t;
            else if (!this._restrictBounds) {
              var i = this._map.getBounds();
              this._restrictBounds = [
                [i[0][0] - 1e-6, i[0][1] - 1e-6],
                [i[1][0] + 1e-6, i[1][1] + 1e-6]
              ]
            }
          } else this._restrictBounds = null, this._minZoom = this._map.options.get("minZoom", 0)
        },
        _runAction: function() {
          this._restrictBounds && this._map.action.execute(new o({
            globalPixelCenter: this._map.getGlobalPixelCenter(),
            zoom: this._map.getZoom()
          }))
        },
        _onRestrictOptionsChange: function() {
          this._calculate(), this._restrictBounds && this._runAction()
        }
      }), t(c)
    });
  }],
  [':r', function(ym) {
    ym.modules.define("map.action.Base", ["event.Manager"], function(e, n) {
      function t() {
        this.events = new n({
          context: this
        }), this._actionManager = null
      }
      t.prototype = {
        isActive: function() {
          return !!this._actionManager
        },
        begin: function(e) {
          this._actionManager = e, this.events.fire("begin")
        },
        end: function() {
          this._actionManager = null, this.events.fire("end")
        },
        getActionManager: function() {
          return this._actionManager
        },
        fixTick: function(e, n) {
          var t = n.getCurrentState(),
            i = t.zoom,
            o = "undefined" == typeof e.zoom ? i : Number(e.zoom),
            a = e.globalPixelCenter;
          if (!a)
            if (!e.pixelOffset && e.center) a = n.getMap().options.get("projection").toGlobalPixels(e.center, o);
            else {
              var r = t.globalPixelCenter.slice(),
                l = Math.pow(2, o - i);
              if (e.pixelOffset) {
                var c = e.pixelOffset;
                a = r, a[0] -= c[0], a[1] -= c[1]
              } else a = r;
              a[0] *= l, a[1] *= l
            }
          return {
            zoom: o,
            globalPixelCenter: a,
            duration: Number(e.duration) || 0,
            timingFunction: e.timingFunction || "linear"
          }
        }
      }, e(t)
    });
  }],
  ['._', function(ym) {
    ym.modules.define("map.action.Continuous", ["util.defineClass", "map.action.Base", "Event"], function(i, t, n, e) {
      function s() {
        s.superclass.constructor.call(this)
      }
      t(s, n, {
        begin: function(i) {
          return s.superclass.begin.call(this, i), this
        },
        tick: function(i) {
          return this._fireTick(this.fixTick(i, this.getActionManager())), this
        },
        end: function() {
          return s.superclass.end.call(this), this
        },
        _fireTick: function(i) {
          this.events.fire("tick", new e({
            type: "tick",
            target: this,
            tick: i
          }))
        }
      }), i(s)
    });
  }],
  ['..', function(ym) {
    ym.modules.define("map.action.Manager", ["util.defineClass", "event.Manager", "Event", "util.bind", "util.extend", "util.coordinates.scaleInvert", "util.math.cubicBezier", "util.scheduler.timescheduler", "util.scheduler.manager", "util.scheduler.world"], function(t, i, e, o, n, s, r, a, c, h, l) {
      var _ = function(t) {
        this.events = new e({
          context: this
        }), this._map = t, this._globalPixelCenter = t.getGlobalPixelCenter(), this._zoom = t.getZoom(), this._userCorrection = null, this._restrictMapArea = null, this._action = null, this._actionTick = null, this._actionListeners = null, this._delayedActionsQueue = [], this._mapListener = this._map.events.group().add("destroy", this._onDestroy, this)
      };
      i(_, {
        execute: function(t) {
          this._actionEnds ? this._delayedActionsQueue.push(t) : (this.stop(), l.smoothMode(!0), this._action = t, this._actionListeners = t.events.group().add("tick", this._onActionTick, this).add("end", this._onActionEnd, this).add("break", this.breakTick, this), this.events.fire("begin", new o({
            type: "begin",
            target: this,
            action: t
          })), t.begin(this))
        },
        stop: function() {
          this._action && (this._actionListeners.removeAll(), this._action.end(), this._onActionEnd())
        },
        breakTick: function() {
          this._actionTick && this._stopTick()
        },
        _onActionTick: function(t) {
          var i = t.get("target"),
            e = t.get("tick"),
            s = this._getCorrectedTick(e);
          (this._actionTick || i != this._action) && this._stopTick();
          var r = Math.abs(s.duration) < 1e-7;
          r ? (this._globalPixelCenter = s.globalPixelCenter, this._zoom = s.zoom) : this._actionTick = {
            startTime: c.getSelfTime(),
            timeout: window.setTimeout(n(function() {
              this._actionTick = null, this._globalPixelCenter = s.globalPixelCenter, this._zoom = s.zoom, this.events.fire("tickcomplete", {
                action: this._action,
                tick: s
              })
            }, this), s.duration),
            shedulerProcess: h.schedule("processing", function() {}, this, {
              duration: s.duration
            }),
            data: s
          }, this.events.fire("tick", new o({
            type: "tick",
            target: this,
            action: this._action,
            tick: s
          })), this._renderTick(), r && this.events.fire("tickcomplete", new o({
            type: "tickcomplete",
            target: this,
            action: this._action,
            tick: s
          }))
        },
        getMap: function() {
          return this._map
        },
        setupRestrictArea: function(t) {
          this._restrictMapArea = t
        },
        getCurrentState: function() {
          var t = this._getCurrentTick();
          return {
            isTicking: !!this._actionTick,
            tickProgress: t.tickProgress,
            zoom: t.zoom,
            globalPixelCenter: t.globalPixelCenter
          }
        },
        _onActionEnd: function() {
          if (this._action) {
            this._actionEnds = !0;
            var t = this._action;
            if (this._actionListeners.removeAll(), this._stopTick(), this._map.options.get("avoidFractionalZoom") && this._roundZoom(), this._action = null, this._applyBounds(), this.events.fire("end", new o({
                type: "end",
                target: this,
                action: t
              })), l.smoothMode(!1), this._renderTick(), this._actionEnds = !1, this._delayedActionsQueue.length)
              for (var i; i = this._delayedActionsQueue.shift();) this.execute(i), this._delayedActionsQueue.length && this.stop()
          }
        },
        _stopTick: function(t) {
          if (this._actionTick) {
            var i = this._getCurrentTick();
            this._globalPixelCenter = i.globalPixelCenter, this._zoom = i.zoom, window.clearTimeout(this._actionTick.timeout), this._actionTick.shedulerProcess.stop(), this._actionTick = null
          }
        },
        _renderTick: function() {
          this.events.fire("render", new o({
            type: "render",
            target: this
          }))
        },
        _getCurrentTick: function() {
          if ("undefined" == typeof this._zoom && (this._zoom = this._map.getZoom()), !this._actionTick) return {
            tickProgress: null,
            zoom: this._zoom,
            globalPixelCenter: this._globalPixelCenter
          };
          var t, i = this._actionTick,
            e = i.data,
            o = a(e.timingFunction).getValue(Math.min(Math.max(c.getSelfTime() - i.startTime, 0) / e.duration, 1)),
            n = this._zoom,
            s = this._globalPixelCenter,
            h = e.zoom,
            l = e.globalPixelCenter,
            _ = h - n,
            u = n + o * _;
          if (Math.abs(_) > 1e-7) {
            var m = Math.pow(2, _),
              d = Math.pow(2, u - n),
              g = [l[0] / m, l[1] / m],
              p = r.centerToFixed(s, g, m),
              f = [p[0] / m, p[1] / m];
            t = r.fixedToCenter(s, f, d)
          } else t = [s[0] + o * (l[0] - s[0]), s[1] + o * (l[1] - s[1])];
          return {
            tickProgress: o,
            zoom: u,
            globalPixelCenter: t
          }
        },
        _applyBounds: function() {
          this.events.fire("statechange", new o({
            type: "statechange",
            target: this,
            globalPixelCenter: this._globalPixelCenter,
            zoom: this._zoom
          }))
        },
        _roundZoom: function() {
          var t = Math.round(this._zoom);
          if (this._zoom != t) {
            var i = Math.pow(2, t - this._zoom),
              e = [this._globalPixelCenter[0] * i, this._globalPixelCenter[1] * i];
            this._globalPixelCenter = e, this._zoom = t
          }
        },
        setCorrection: function(t) {
          this._userCorrection = t
        },
        _zoomAndDelayCorrection: function(t) {
          var i = t.zoom,
            e = this._map.options,
            o = e.get("maxZoom", 23),
            n = e.get("minZoom", 0),
            s = Math.max(Math.min(i, o), n),
            r = e.get("maxAnimationZoomDifference", 5),
            a = Math.abs(s - this._map.getZoom()) < r ? t.duration : 0;
          if (this._restrictMapArea && (s = this._restrictMapArea.fixZoom(s)), Math.abs(t.zoom - s) > 1e-7 || a != t.duration) {
            var c = Math.pow(2, s - i);
            t.globalPixelCenter = [t.globalPixelCenter[0] * c, t.globalPixelCenter[1] * c], t.zoom = s, t.duration = a
          }
        },
        _getCorrectedTick: function(t) {
          var i = s({}, t);
          return this._zoomAndDelayCorrection(i), this._restrictMapArea && this._restrictMapArea.correctTick(i), this._userCorrection && (i = this._userCorrection(s({}, i))), i
        },
        _onDestroy: function() {
          this._mapListener.removeAll()
        }
      }), t(_)
    });
  }],
  ['.!', function(ym) {
    ym.modules.define("map.action.Sequence", ["util.extend", "map.action.Single", "util.bind"], function(t, i, n, c) {
      function e(t, i) {
        this.options = i || {}, this._ticks = t, this._active = !1, this._actionManager = null
      }
      e.prototype = {
        begin: function(t) {
          return this._actionManager = t, this._active = !0, this._executeAction(0), this
        },
        end: function() {
          this._clearCurrentAction(), this._end()
        },
        isActive: function() {
          return this._active
        },
        _clearCurrentAction: function() {
          this._currentAction && (this._currentAction.end(), this._currentAction = null)
        },
        _executeAction: function(t) {
          this._currentAction = new n(i({}, this._ticks[t], {
            callback: this._getCallback(t, t == this._ticks.length - 1)
          })), this._currentAction.end = c(function() {
            this._currentAction && (n.prototype.end.call(this._currentAction), this._currentAction = null, this._end())
          }, this), this._actionManager.execute(this._currentAction)
        },
        _getCallback: function(t, i) {
          return c(function(n) {
            if (this._active)
              if (this._currentAction = null, n) this.options.callback && this.options.callback(n);
              else if (this._ticks[t].callback && this._ticks[t].callback.call(n), i) this._end();
            else {
              var c = this._ticks[t];
              if (!c.globalPixelCenter) {
                var e = this._actionManager.getMap().options.get("projection");
                c.globalPixelCenter = e.toGlobalPixels(c.center, c.zoom)
              }
              this._executeAction(t + 1)
            }
          }, this)
        },
        _end: function() {
          this._active && (this._active = !1, this.options.callback && this.options.callback(null))
        }
      }, t(e)
    });
  }],
  ['.(', function(ym) {
    ym.modules.define("map.action.Single", ["util.bind", "util.defineClass", "map.action.Base", "Event"], function(i, t, e, o, c) {
      function n(i) {
        n.superclass.constructor.call(this), this._originalTick = i, this._activeTick = null, this._tickDelayTimeoutID = 0, this._zoomRangeChecking = !1, this._tickFiring = !1
      }
      e(n, o, {
        begin: function(i) {
          n.superclass.begin.call(this, i);
          var e = this._originalTick;
          if (e.checkZoomRange) {
            this._zoomRangeChecking = !0;
            var o = this._getActiveTick(),
              c = i.getMap();
            c.zoomRange.get(c.options.get("projection").fromGlobalPixels(o.globalPixelCenter, o.zoom)).then(this._zoomRangeGetCallback, this)
          } else e.useMapMargin && this._applyMargin();
          return "number" == typeof e.delay && (this._tickDelayTimeoutID = window.setTimeout(t(this._onTickDelayTimeout, this), e.delay)), this._fireTick(), this
        },
        end: function() {
          return this._tickDelayTimeoutID && (window.clearTimeout(this._tickDelayTimeoutID), this._tickDelayTimeoutID = 0), this._completeTick(), this
        },
        _getActiveTick: function() {
          return this._activeTick || (this._activeTick = this.fixTick(this._originalTick, this.getActionManager()))
        },
        _zoomRangeGetCallback: function(i) {
          this._zoomRangeChecking = !1, this.isActive() && (this._correctZoom(i[0], i[1]), this._originalTick.useMapMargin && this._applyMargin(), this._fireTick())
        },
        _onTickDelayTimeout: function() {
          this._tickDelayTimeoutID = 0, this._fireTick()
        },
        _fireTick: function() {
          this._zoomRangeChecking || this._tickDelayTimeoutID || (this.getActionManager().events.add("tickcomplete", this._onTickComplete, this), this._tickFiring = !0, this.events.fire("tick", new c({
            type: "tick",
            target: this,
            tick: this._getActiveTick()
          })))
        },
        _onTickComplete: function(i) {
          i.get("action") == this && this._completeTick()
        },
        _completeTick: function() {
          this._tickFiring && (this._tickFiring = !1, this.getActionManager().events.remove("tickcomplete", this._onTickComplete, this)), this._activeTick = null, n.superclass.end.call(this), this._originalTick.callback && this._originalTick.callback(null)
        },
        _correctZoom: function(i, t) {
          var e = this._getActiveTick(),
            o = Math.min(t, Math.max(i, e.zoom));
          if (o != e.zoom) {
            var c = Math.pow(2, o - e.zoom);
            e.globalPixelCenter[0] *= c, e.globalPixelCenter[1] *= c, e.zoom = o
          }
        },
        _applyMargin: function() {
          var i = this.getActionManager().getMap(),
            t = i.margin.getMargin(),
            e = this._getActiveTick();
          this._correctZoom(i.options.get("minZoom", 0), i.options.get("maxZoom", 23)), e.globalPixelCenter[0] -= (t[3] - t[1]) / 2, e.globalPixelCenter[1] -= (t[0] - t[2]) / 2
        }
      }), i(n)
    });
  }],
  ['.)', function(ym) {
    ym.modules.define("map.addon.balloon", ["Map", "popup.addonBuilder", "map.Balloon"], function(a, e, n, o) {
      a(n.build({
        type: "balloon",
        metaEventManager: e.getMetaEventManager()
      }))
    });
  }],
  ['.:', function(ym) {
    ym.modules.define("map.addon.hint", ["Map", "popup.addonBuilder", "map.Hint"], function(e, n, a, t) {
      e(a.build({
        type: "hint",
        metaEventManager: n.getMetaEventManager()
      }))
    });
  }],
  ['.;', function(ym) {
    ym.modules.define("map.associate.serviceGeoObjects", ["util.Associate", "map.GeoObjects"], function(e, t, n) {
      var o = new t(function(e) {
        return new n(e)
      });
      e({
        get: function(e) {
          if (ym.env.debug && !e) throw new Error("map.associate.serviceGeoObjects: передан пустой указатель на карту");
          return o.get(e)
        }
      })
    });
  }],
  ['.q', function(ym) {
    ym.modules.define("map.associate.serviceLayers", ["util.Associate", "map.layer.Manager"], function(e, r, a) {
      var n = new r(function(e) {
        return new a(e)
      });
      e({
        get: function(e) {
          if (ym.env.debug && !e) throw new Error("map.associate.serviceLayers: передан пустой указатель на карту");
          return n.get(e)
        }
      })
    });
  }],
  ['54', function(ym) {
    ym.modules.define("map.Balloon", ["util.defineClass", "Balloon", "component.sharedEntity.manager.Popup", "sharedEntity.proxy.Balloon", "event.Manager", "map.optionMapper", "option.Manager", "option.Router", "util.component", "vow", "popup.managerStorage"], function(t, n, e, o, i, s, r, a, p, h, u, l) {
      function f(t) {
        this._map = t, this.events = new s({
          context: this
        }), this._balloon = new e(t), this._balloon.options.setParent(this._map.options), this._sharingManager = new o(this, this._balloon, this._map, i), this._forkOptions = new a
      }
      n(f, h.createProxyMethods(function() {
        return this._sharingManager
      }, ["capture", "open", "close", "isOpen", "getOverlay", "getOverlaySync", "autoPan", "getOwner", "setPosition", "getPosition", "setData", "getData", "setOptions", "getOptions"]), {
        destroy: function() {
          this.capture(null), this._balloon.destroy()
        },
        capture: function(t) {
          var n = this._sharingManager.capture(t);
          return n.then(this._reset, this), n
        },
        open: function(t, n, e) {
          t = t || this._map.getCenter();
          var o = u.defer(),
            i = function(t) {
              o.reject(t)
            };
          return this._sharingManager.perform("open", [t, n, e], this, function(t) {
            u.resolve(!t[2] || this.setOptions(t[2])).then(function() {
              o.resolve(this._sharingManager.getEntity().open(t[0], t[1]))
            }, i, this)
          }, i), o.promise()
        },
        setOptions: function(t) {
          var n = u.defer();
          return this._sharingManager.perform("setOptions", [t], this, function(t) {
            this._addForkOptions(), this._forkOptions.freeze().unsetAll().set(t[0]).unfreeze(), n.resolve()
          }, function(t) {
            n.reject(t)
          }), n.promise()
        },
        getOptions: function() {
          return this._sharingManager.perform("getOptions", null, this, function() {
            return this._addForkOptions(), this._forkOptions
          })
        },
        autoPan: function() {
          return this._sharingManager.perform("autoPan")
        },
        _addForkOptions: function() {
          var t = this._balloon.options.getParent();
          t && "function" == typeof t.spliceParents ? t.indexOfParent(this._forkOptions) == -1 && t.spliceParents(0, 0, this._forkOptions) : this._balloon.options.setParent(new p(this._forkOptions, t))
        },
        _reset: function() {
          this.getOwner() == this._map && this._balloon.options.setParent(this._map.options), this._forkOptions.unsetAll()
        }
      }), l.add("map#balloon", f), t(f)
    });
  }],
  ['.j', function(ym) {
    ym.modules.define("map.behavior.Manager", ["util.defineClass", "behavior.storage", "map.behavior.optionMapper", "map.GeneralCollection", "component.collection.ParentCollection", "error", "map.behavior.metaOptions"], function(e, o, t, i, r, n, a) {
      var s = function(e, o, t) {
        s.superclass.constructor.call(this, e, t, "behaviors", i), this._parentCollection = new n(this, {
          onAdd: {
            callback: this._onAdd,
            context: this
          },
          onRemove: {
            callback: this._onRemove,
            context: this
          }
        }), this._behaviors = {};
        for (var r = [].concat(o), a = 0, h = r.length; a < h; a++)
          for (var l = this._resolveBehaviors(r[a]), v = 0, c = l.length; v < c; v++) l[v].enable()
      };
      o(s, r, {
        enable: function(e) {
          "string" == typeof e && (e = [e]);
          for (var o = 0, t = e.length; o < t; o++) {
            var i = this._resolveBehavior(e[o]);
            i && i.enable()
          }
          return this
        },
        disable: function(e) {
          "string" == typeof e && (e = [e]);
          for (var o = 0, t = e.length; o < t; o++) {
            var i = this._resolveBehavior(e[o]);
            i && i.disable()
          }
          return this
        },
        isEnabled: function(e) {
          var o = this._resolveBehavior(e);
          return o && o.isEnabled()
        },
        get: function(e) {
          return this._resolveBehavior(e)
        },
        _resolveBehaviors: function(e) {
          var o, t = [];
          if ("default" == e)
            for (var i = this.getMap().options.get("defaultBehaviors") || [], r = 0, n = i.length; r < n; r++) o = this._resolveBehavior(i[r]), o && t.push(o);
          else o = this._resolveBehavior(e), o && t.push(o);
          return t
        },
        _resolveBehavior: function(e) {
          var o = this._behaviors[e];
          if (!o) {
            var i = t.get(e);
            i ? (o = this._behaviors[e] = new i, this._parentCollection.add(o)) : a.warn("Warning", 'map.Behaviors: behavior "' + e + '" does not exist')
          }
          return o
        },
        _onAdd: function(e) {
          this.events.fire("add", {
            child: e
          })
        },
        _onRemove: function(e) {
          this.events.fire("remove", {
            child: e
          })
        }
      }), e(s)
    });
  }],
  ['.i', function(ym) {
    ym.modules.define("map.behavior.metaOptions", ["map.metaOptions", "behavior.DblClickZoom", "behavior.Drag", "behavior.LeftMouseButtonMagnifier", "behavior.MultiTouch", "behavior.RightMouseButtonMagnifier", "behavior.ScrollZoom"], function(o, i) {
      i.set({
        defaultBehaviors: ["drag", "rightMouseButtonMagnifier", "dblClickZoom", "multiTouch", "scrollZoom"],
        dragCursor: "grab",
        dragActionCursor: "grabbing"
      }), o(!0)
    });
  }],
  ['.Q', function(ym) {
    ym.modules.define("map.behavior.optionMapper", ["option.Mapper"], function(e, o) {
      e(new o)
    });
  }],
  ['56', function(ym) {
    ym.modules.define("map.Container", function(e) {
      var t = e.env.lang.slice(0, 2);
      return ["util.defineClass", "event.Manager", "domEvent.manager", "Monitor", "util.bind", "util.math.areEqual", "util.fireWithBeforeEvent", "util.dom.style", "util.dom.element", "util.dom.viewport", "util.dom.className", "util.css", "util.hd", "system.browser", "meta", "yandex.counter", "util.scheduler.strategy.Asap", "map.css", "ru" == t || "uk" == t ? "map.ru.css" : "map.en.css"]
    }, function(e, t, i, s, n, o, l, r, u, h, a, c, d, _, f, m, p, g) {
      function F(e, t) {
        if ("string" == typeof e && (e = document.getElementById(e)), ym.env.debug && (!e || 1 != e.nodeType)) throw new Error("map.Container.constructor: Не удалось получить HTML-элемент контейнера.");
        this._parentElement = e, this._map = t, this._mapOptionsMonitor = new n(t.options), this.events = new i({
          context: this
        });
        var o = this._mapOptionsMonitor;
        o.add("autoFitToViewport", this._onAutoFitModeChange, this).add("autoFitToViewportDelay", this._onAutoFitDelayChange, this).add("backgroundVisible", this._onBackgroundVisibleChange, this, {
          defaultValue: !0
        }), this._size = u.getSize(e);
        var l = [d.addPrefix("map"), d.addPrefix("i-ua_js_yes")];
        if (o.get("backgroundVisible") && l.push(x), "pointer" == f.eventMapper && l.push(d.addPrefix("touch-action-none")), l.push(d.addPrefix("islets_map-lang-" + y)), this._element = h.create({
            parentNode: e,
            className: l.join(" "),
            size: this._size
          }), this._offset = u.getOffset(this._element, !0), this._isFullscreen = !1, this._fullscreenElement = null, this._sizeBeforeFullscreen = null, this._setupAutoFit(), this._oldWindowSize = a.getSize(), f.oldIE && (this._oldWindowScroll = a.hasScroll()), this._windowListeners = s.group(window), this._documentListeners = s.group(document), this._windowListeners.add("resize", this._onWindowResize, this), ym.supports.printPatchNeeded) {
          var r = d.addPrefix("patched-for-print-preload");
          this._windowListeners.add("beforeprint", function() {
            c.add(this._element, r), new g(function() {
              c.remove(this._element, r)
            }, this).start()
          }, this)
        }
        p.countByKey("modulesUsage", ["mapDpr", Math.round(_.getPixelRatio()), f.platform, p.versionPrefix].join("."))
      }

      function v(e, t) {
        e.appendChild(t)
      }

      function w(e) {
        e.parentNode.removeChild(e)
      }

      function z(e) {
        return e.toString().replace(/\./g, "_")
      }
      var y = m.languageCode,
        S = "ru" == y || "uk" == y ? "ru" : "en",
        x = d.addPrefix("map-bg-") + S;
      t(F, {
        getElement: function() {
          return this._element
        },
        getSize: function() {
          return this._size
        },
        getOffset: function() {
          return this._offset = u.getOffset(this._element, !0), this._offset
        },
        fitToViewport: function(e) {
          var t = this._size,
            i = this._offset,
            s = u.getSize(this._element.parentNode),
            n = u.getOffset(this._element, !0);
          l(t, s) || (this._isNullSize && (this._isNullSize = !1, this._logSize()), u.setSize(this._element, s), this._size = s, this._offset = n, this.events.fire("sizechange", {
            oldSize: t,
            newSize: s,
            oldOffset: i,
            newOffset: n,
            preservePixelPosition: e
          }))
        },
        enterFullscreen: function() {
          this._isFullscreen || (this._moveContainerToFullscreen(), this._isFullscreen = !0, this.events.fire("fullscreenenter"), this.fitToViewport(), p.countByKey("modulesUsage", "fullscreen.enter"))
        },
        exitFullscreen: function() {
          this._isFullscreen && r(this.events, {
            type: "fullscreenexit",
            target: this
          }, {
            successCallback: this._onFullScreenExitSuccess,
            context: this
          })
        },
        isFullscreen: function() {
          return this._isFullscreen
        },
        destroy: function() {
          this._windowListeners.removeAll(), this._documentListeners.removeAll(), this._isFullscreen && this._moveContainerFromFullscreen(), h.remove(this._element), this._mapOptionsMonitor.destroy(), this._clearAutoFit()
        },
        _onFullScreenExitSuccess: function(e) {
          this._moveContainerFromFullscreen(), this._isFullscreen = !1, this.fitToViewport(), ym.env.browser.oldIE && (this._element.className += ""), this.events.fire(e.type, e)
        },
        _fullscreenReposition: function() {
          var e = this._map.options.get("fullscreenMargin", [
              [0, 0],
              [0, 0]
            ]),
            t = this._fullscreenElement,
            i = this,
            s = a.getScrollOffsets(),
            n = a.getSize();
          u.css(t, {
            left: s[0] + e[0][0] + "px",
            top: s[1] + e[0][1] + "px",
            width: n[0] - e[1][0] - e[0][0] + "px",
            height: n[1] - e[1][1] - e[1][1] + "px"
          }), i.fitToViewport()
        },
        _moveContainerToFullscreen: function() {
          this._sizeBeforeFullscreen = this._size, this._fullscreenElement = h.create({
            css: {
              position: "absolute",
              left: 0,
              top: 0,
              width: 0,
              height: 0,
              zIndex: this._map.options.get("fullscreenZIndex")
            }
          }), c.add(document.body, d.addPrefix("fullscreen")), v(document.body, this._fullscreenElement), v(this._fullscreenElement, this._element), c.add(this._element, d.addPrefix("fullscreen-mode")), this._fullscreenReposition(), this._windowListeners.add(["resize", "scroll", "orientationchange"], this._fullscreenReposition, this), this._map.options.get("exitFullscreenByEsc") && this._documentListeners.add("keyup", this._onKeyUp, this)
        },
        _moveContainerFromFullscreen: function() {
          u.setSize(this._element, this._sizeBeforeFullscreen), v(this._parentElement, this._element), w(this._fullscreenElement), c.remove(document.body, d.addPrefix("fullscreen")), c.remove(this._element, d.addPrefix("fullscreen-mode")), this._documentListeners.remove("keyup", this._onKeyUp, this), this._windowListeners.remove(["resize", "scroll", "orientationchange"], this._fullscreenReposition, this)
        },
        _onKeyUp: function(e) {
          "27" != e.get("charCode") && "27" != e.get("keyCode") || this.exitFullscreen()
        },
        _setupAutoFit: function() {
          var e = this._mapOptionsMonitor.get("autoFitToViewport"),
            t = this.getSize(),
            i = l(t, [0, 0]);
          i && (this._isNullSize = !0), this._logSize(), (i && "ifNull" == e || "always" == e) && (this._autoFitIntervalID = setInterval(o(function() {
            this._checkAutoFit()
          }, this), this._mapOptionsMonitor.get("autoFitToViewportDelay")))
        },
        _onAutoFitModeChange: function(e) {
          this._clearAutoFit(), "none" != e && this._setupAutoFit()
        },
        _onAutoFitDelayChange: function() {
          this._clearAutoFit(), this._setupAutoFit()
        },
        _clearAutoFit: function() {
          this._autoFitIntervalID && (clearInterval(this._autoFitIntervalID), this._autoFitIntervalID = null)
        },
        _checkAutoFit: function() {
          this.fitToViewport(), l(this.getSize(), [0, 0]) || "ifNull" != this._mapOptionsMonitor.get("autoFitToViewport") || this._clearAutoFit()
        },
        _onWindowResize: function() {
          var e = a.getSize();
          if (f.oldIE) {
            var t = a.hasScroll(),
              i = !l(t, this._oldWindowScroll);
            if (this._oldWindowScroll = t, i) return
          }
          l(e, this._oldWindowSize) || (this._oldWindowSize = e, this.fitToViewport())
        },
        _onBackgroundVisibleChange: function(e) {
          e ? c.add(this._element, x) : c.remove(this._element, x)
        },
        _logSize: function() {
          p.countByKey("modulesUsage", ["mapSize", z(this._size[0]) + "x" + z(this._size[1]), f.platform, p.versionPrefix].join("."))
        }
      }), e(F)
    });
  }],
  ['57', function(ym) {
    ym.modules.define("map.Converter", [], function(t) {
      var e = function(t) {
        this._map = t, this._listeners = t.events.group().add("destroy", this._onDestroy, this)
      };
      e.prototype = {
        _onDestroy: function() {
          this._listeners.removeAll()
        },
        pageToGlobal: function(t) {
          var e = this._map.container.getOffset(),
            n = this._map.container.getSize(),
            i = [n[0] / 2, n[1] / 2],
            o = this._map.action.getCurrentState().globalPixelCenter;
          return [o[0] + t[0] - e[0] - i[0], o[1] + t[1] - e[1] - i[1]]
        },
        globalToPage: function(t) {
          var e = this._map.container.getOffset(),
            n = this._map.container.getSize(),
            i = [n[0] / 2, n[1] / 2],
            o = this._map.action.getCurrentState().globalPixelCenter;
          return [t[0] - o[0] + e[0] + i[0], t[1] - o[1] + e[1] + i[1]]
        }
      }, t(e)
    });
  }],
  ['59', function(ym) {
    ym.modules.define("map.Copyrights", ["component.ProviderObserver", "map.copyrights.StaticProvider", "map.copyrights.Layout", "map.copyrights.Promo", "event.Manager", "data.Manager", "projection.wgs84Mercator", "projection.sphericalMercator", "vow", "util.bind", "util.dom.element", "util.math.differ", "Monitor", "util.defineClass"], function(t, e, i, s, o, n, r, a, h, p, g, u, c, l, _) {
      var d = .499999,
        y = 400,
        m = function(t) {
          this._map = t, this.events = new n({
            context: this
          }), this._copyrightsObserver = new e({
            changeEventType: "copyrightschange",
            changeCallback: g(this._updateCopyrights, this),
            makeRequest: function(t, e) {
              return t.getCopyrights(e.center, e.zoom)
            }
          });
          var i = t.options;
          this._dataSet = new r({
            copyrights: [],
            bright: t.layers.getBrightness() > d,
            "float": i.get("copyrightFloat", "right"),
            logo: this._isLogoVisible()
          }), this._state = new r({
            size: t.container.getSize()[0] > y ? "large" : "small",
            copyrightsWidth: null
          }), this._layout = null, this._actualRequest = null, this._mapListeners = null, this._mapLayerListeners = null, this._mapOptionsMonitor = null, this._stateMonitor = null, this._promoBlock = null, this._setupLayout(), this._setupPromo(), this._setupListeners(), this.get()
        };
      _(m, {
        addProvider: function(t) {
          if (ym.env.debug && "function" != typeof t.getCopyrights) throw new Error("map.Copyrights.addProvider: parameter doesn't implement ICopyrightsProvider interface");
          return this._copyrightsObserver.addProvider(t), this
        },
        removeProvider: function(t) {
          return this._copyrightsObserver.removeProvider(t), this
        },
        add: function(t) {
          var e = new i(t, this);
          return this.addProvider(e), e
        },
        get: function(t, e) {
          var i = p.defer(),
            s = this._map;
          return this._copyrightsObserver.get({
            center: t || s.getCenter({
              useMapMargin: s.options.get("coverageUseMapMargin", !1)
            }),
            zoom: "undefined" == typeof e ? s.getZoom() : e
          }).then(function(t) {
            i.resolve([].concat.apply([], t.resolved))
          }, function() {
            i.resolve([])
          }), i.promise()
        },
        getMap: function() {
          return this._map
        },
        getState: function() {
          return this._state
        },
        getPromoLink: function() {
          return this._promoBlock.getLink()
        },
        _setupListeners: function() {
          var t = this._map;
          this._mapListeners = t.events.group().add("boundschange", this._onBoundsChange, this).add("destroy", this._onMapDestroy, this).add("sizechange", this._onMapSizeChange, this), this._mapLayerListeners = t.layers.events.group().add("brightnesschange", this._onBrightnessChange, this), this._mapOptionsMonitor = new l(t.options).add("copyrightFloat", this._onCopyrightsFloatChange, this).add(["copyrightLogoVisible", "suppressMapOpenBlock"], this._setCopyrightsLogoVisibleState, this)
        },
        _clearListeners: function() {
          this._mapLayerListeners.removeAll(), this._mapListeners.removeAll(), this._mapOptionsMonitor.destroy()
        },
        _setupPromo: function() {
          var t = this._layout.getParentElement();
          this._promoBlock = new o(t, this)
        },
        _clearPromo: function() {
          this._promoBlock.destroy(), this._promoBlock = null
        },
        _onMapDestroy: function() {
          this._clearPromo(), this._clearListeners(), this._clearLayout(), this._actualRequest = null, this._copyrightsObserver.destroy()
        },
        _onMapSizeChange: function(t) {
          var e = t.get("newSize")[0] > y ? "large" : "small";
          this._state.set("size", e)
        },
        _setupLayout: function() {
          var t = this._map;
          this._layout = new s({
            data: this._dataSet,
            state: this._state,
            map: t
          }), this._layout.setParentElement(t.panes.get("copyrights").getElement())
        },
        _clearLayout: function() {
          this._layout.destroy()
        },
        _updateCopyrights: function() {
          var t = this._actualRequest = this.get();
          t.then(function(e) {
            t == this._actualRequest && this._onCopyrightsReady(t, e)
          }, this)
        },
        _onCopyrightsReady: function(t, e) {
          var i = this._dataSet.get("copyrights"),
            s = c(e, i);
          s && this._onCurrentCopyrightsChange(i, e)
        },
        _onCurrentCopyrightsChange: function(t, e) {
          this._dataSet.set("copyrights", e), this.events.fire("change", {
            oldCopyrights: t.slice(),
            newCopyrights: e.slice()
          })
        },
        _onBoundsChange: function() {
          this._updateCopyrights()
        },
        _onBrightnessChange: function() {
          this._dataSet.set("bright", this._map.layers.getBrightness() > d)
        },
        _onCopyrightsFloatChange: function(t) {
          this._dataSet.set("float", t)
        },
        _setCopyrightsLogoVisibleState: function() {
          this._dataSet.set("logo", this._isLogoVisible())
        },
        _isLogoVisible: function() {
          var t = this._map.options,
            e = t.get("copyrightLogoVisible", !0),
            i = t.get("suppressMapOpenBlock", !1),
            s = t.get("projection"),
            o = !i && (s == a || s == h);
          return e && !o
        }
      }), t(m)
    });
  }],
  ['.J', function(ym) {
    ym.modules.define("map.copyrights.counter", ["util.id"], function(e, t) {
      var r = {},
        n = {};
      e({
        create: function(e, t) {
          var o, c = !!n[e];
          if (n[e] = t, c)
            for (var i in r) r.hasOwnProperty(i) && (o = r[i][e], o && o.copyrights.setCopyrights(t))
        },
        increment: function(e, o, c) {
          var i, u = t.get(o);
          c = c || 1, r[u] = r[u] || {}, i = r[u], i[e] ? i[e].counter += c : i[e] = {
            counter: c,
            copyrights: o.copyrights.add(n[e])
          }
        },
        decrement: function(e, n, o) {
          var c, i = t.get(n),
            u = r[i];
          o = o || 1, u && u[e] && (c = u[e], c.counter -= o, c.counter <= 0 && (c.copyrights.remove(), delete r[i][e]))
        }
      })
    });
  }],
  ['.Z', function(ym) {
    ym.modules.define("map.copyrights.Layout", ["templateLayoutFactory", "copyright.layout.html", "Monitor", "domEvent.manager", "localization.common.current", "util.array", "util.nodeSize", "util.dom.element", "util.dom.className", "util.dom.style", "util.css", "meta", "yandex.state.associate"], function(t, i, e, s, o, a, n, r, h, l, d, _, g, p) {
      function u(t, i, e) {
        i ? l.add(t, e) : l.remove(t, e)
      }
      var c = {
          FOG: _.addPrefix("copyright_fog_yes"),
          WHITE_THEME: _.addPrefix("copyright_color_white"),
          EN_LOGO: _.addPrefix("copyright__logo_lang_en"),
          POSITION_LEFT: _.addPrefix("copyright_float_left"),
          VISIBLE_NO: _.addPrefix("copyright_logo_no"),
          PROVIDES_VISIBLE_NO: _.addPrefix("copyright_providers_no"),
          UA_VISIBLE_NO: _.addPrefix("copyright_ua_no")
        },
        m = i.createClass(e, {
          build: function() {
            m.superclass.build.call(this);
            var t = this.getParentElement(),
              i = this.getData(),
              e = g.languageCode;
            this._copyrightsElement = h.findByPrefixedClass(t, "copyright"), this._logoLinkElement = h.findByPrefixedClass(t, "copyright__logo"), this._legendElement = h.findByPrefixedClass(t, "copyright__text"), this._yandexState = p.get(i.map), this._update(), "ru" != e && "uk" != e && l.add(this._logoLinkElement, c.EN_LOGO), d.patch(this._logoLinkElement, {
              printBackground: d.value(this._logoLinkElement, "backgroundImage", !0).replace(/^\s*url\(['"]?/, "").replace(/['"]?\)$/, "")
            }), this._setupListeners()
          },
          clear: function() {
            this._clearListeners(), m.superclass.clear.call(this)
          },
          _setupListeners: function() {
            var t = this.getData(),
              i = t.data,
              e = t.map;
            this._monitor = new s(i).add("copyrights", this._updateCopyrights, this).add("bright", this._updateColor, this).add("logo", this._updateLogoVisible, this).add("float", this._updatePosition, this), this._mapListener = e.events.group().add("sizechange", this._updateView, this), this._mapOptionsMonitor = new s(e.options).add("copyrightProvidersVisible", this._updateProvidersVisible, this).add("copyrightUaVisible", this._updateUaVisible, this), this._logoLinkListeners = o.group(this._logoLinkElement).add(["mouseenter", "click"], this._setLogoLink, this)
          },
          _clearListeners: function() {
            this._monitor.destroy(), this._mapOptionsMonitor.destroy(), this._mapListener.removeAll(), this._logoLinkListeners.removeAll()
          },
          _update: function() {
            var t = this.getData(),
              i = t.data,
              e = t.map.options;
            this._updateCopyrights(i.get("copyrights")), this._updateColor(i.get("bright")), this._updatePosition(i.get("float")), this._updateLogoVisible(i.get("logo")), this._updateProvidersVisible(e.get("copyrightProvidersVisible", !0)), this._updateUaVisible(e.get("copyrightUaVisible", !0))
          },
          _updateCopyrights: function(t) {
            var i = "";
            n.isArray(t) ? t.length > 0 && (i = t.join(", ")) : "string" == typeof t && (i = t), h.html(this._legendElement, i), this._updateView()
          },
          _updateLogoVisible: function(t) {
            u(this._copyrightsElement, !t, c.VISIBLE_NO)
          },
          _updateProvidersVisible: function(t) {
            u(this._copyrightsElement, !t, c.PROVIDES_VISIBLE_NO)
          },
          _updateUaVisible: function(t) {
            u(this._copyrightsElement, !t, c.UA_VISIBLE_NO)
          },
          _updateColor: function(t) {
            u(this._copyrightsElement, !t, c.WHITE_THEME)
          },
          _updatePosition: function(t) {
            u(this._copyrightsElement, "left" == t, c.POSITION_LEFT)
          },
          _updateView: function(t) {
            d.css(this._copyrightsElement, {
              width: null
            });
            var i = this._copyrightsElement,
              e = r.computeByContent(i),
              s = e.width,
              o = s,
              a = this._getParentOffset(),
              n = "undefined" == typeof t ? this.getData().map.container.getSize()[0] : t.get("newSize")[0];
            s >= n && (o = Math.max(0, n - a), d.css(i, {
              width: o + "px"
            })), u(i, s >= n, c.FOG), this.getData().state.set("copyrightsWidth", o)
          },
          _getParentOffset: function() {
            var t = this.getParentElement(),
              i = d.values(t, ["left", "right"]),
              e = 0;
            if ("auto" != i.left || "auto" != t.right)
              for (var s in i)
                if (i.hasOwnProperty(s)) {
                  var o = parseInt(i[s], 10);
                  isNaN(o) || (e += o)
                }
            return e
          },
          _setLogoLink: function() {
            this._logoLinkElement.href = this._yandexState.buildLink()
          }
        });
      t(m)
    });
  }],
  ['!a', function(ym) {
    ym.modules.define("map.copyrights.Promo", ["data.Manager", "Monitor", "Inception", "projection.wgs84Mercator", "projection.sphericalMercator", "yandex.state.associate", "util.defineClass", "util.dom.element", "util.css", "error", "vow", "map.copyrights.promo.css"], function(t, i, e, n, s, a, o, h, r, p) {
      function _(t, i) {
        this._parentElement = t, this._copyrightsManager = i, this._map = i.getMap(), this._inception = null, this._copyrightsStateMonitor = null, this._mapContainerListeners = null, this._setupData(), this._setupListeners(), this._setupPromoBlock(), this._lastLink = null
      }
      var c = 20,
        l = "suppressMapOpenBlock",
        u = "copyrightsVisible",
        g = "copyrightsPosition",
        d = "copyrightsFloat";
      h(_, {
        destroy: function() {
          this._clearPromoBlock(), this._clearListeners(), this._clearData(), this._map = null, this._parentElement = null, this._inception = null
        },
        getLink: function() {
          return this._lastLink
        },
        _getElement: function() {
          return this._element || (this._element = r.create({
            className: p.addPrefix("map-copyrights-promo"),
            css: {
              position: "absolute",
              bottom: "-4px"
            },
            parentNode: this._parentElement
          }))
        },
        _setupData: function() {
          this._yandexState = o.get(this._map), this._data = new i({
            mapState: this._yandexState.getAll()
          }), this._yandexState.events.add("change", this._onMapStateChange, this)
        },
        _clearData: function() {
          this._data.destroy(), this._data = null, this._yandexState.events.remove("change", this._onMapStateChange, this), this._yandexState = null
        },
        _onMapStateChange: function() {
          this._data.set("mapState", this._yandexState.getAll())
        },
        _setupListeners: function() {
          this._mapOptionsMonitor = new e(this._map.options).add([u, g, d], this._updateVisible, this, {
            defaultValue: !1
          }).add(l, this._onMapBlockSuppressOptionsChange, this)
        },
        _clearListeners: function() {
          this._mapOptionsMonitor.destroy()
        },
        _onMapBlockSuppressOptionsChange: function() {
          this._clearPromoBlock(), this._setupPromoBlock()
        },
        _setupPromoBlock: function() {
          var t = this._map.options.get(l, !1),
            i = this._map.options.get("projection");
          t || i != s && i != a || (this._setupSizeChangeListeners(), this._setAvailWidth(), this._inception = new n("/map", this._data), this._inception.setParentElement(this._getElement()), this._inception.events.add("linkchange", this._onLinkChange, this))
        },
        _clearPromoBlock: function() {
          this._inception && (this._inception.events.remove("linkchange", this._onLinkChange, this), this._inception.destroy(), this._inception = null, this._clearSizeChangeListeners())
        },
        _onLinkChange: function(t) {
          this._lastLink = t.get("link")
        },
        _setupSizeChangeListeners: function() {
          this._mapContainerListeners = this._map.container.events.group().add("sizechange", this._setAvailWidth, this), this._copyrightsStateMonitor = new e(this._copyrightsManager.getState()).add("copyrightsWidth", this._setAvailWidth, this)
        },
        _clearSizeChangeListeners: function() {
          this._mapContainerListeners.removeAll(), this._copyrightsStateMonitor.destroy()
        },
        _updateVisible: function() {
          var t = this._mapOptionsMonitor;
          t.get(u) || t.get(g) || t.get(d) ? this._inception && this._clearPromoBlock() : this._inception || this._setupPromoBlock()
        },
        _getAvailWidth: function() {
          return this._map.container.getSize()[0] - (this._copyrightsStateMonitor.get("copyrightsWidth") + c)
        },
        _setAvailWidth: function() {
          this._data.set("availWidth", this._getAvailWidth())
        }
      }), t(_)
    });
  }],
  ['0y', function(ym) {
    ym.modules.define("map.copyrights.promo.css", ["map-copyrights-promo"], function(o) {
      o({})
    });
  }],
  ['!c', function(ym) {
    ym.modules.define("map.copyrights.StaticProvider", ["util.defineClass", "event.Manager", "util.math.differ", "vow"], function(t, e, i, n, r) {
      var s = function(t, e) {
        this._copyrights = [].concat(t), this._manager = e, this.events = new i({
          context: this
        })
      };
      e(s, {
        getCopyrights: function() {
          return r.resolve(this._copyrights)
        },
        setCopyrights: function(t) {
          var e = [].concat(t);
          n(e, t) && (this._copyrights = e, this.events.fire("copyrightschange"))
        },
        remove: function() {
          this._manager.removeProvider(this)
        }
      }), t(s)
    });
  }],
  ['0F', function(ym) {
    ym.modules.define("map.css", ["map-css"], function(s) {
      s({})
    });
  }],
  ['5_', function(ym) {
    ym.modules.define("map.event.Manager", ["util.defineClass", "event.Manager", "MapEvent", "util.extend"], function(e, t, n, a, c) {
      function r(e) {
        r.superclass.constructor.call(this, e)
      }
      t(r, n, {
        createEventObject: function(e, t, n) {
          return new a(c({
            type: e,
            target: n,
            map: n
          }, t))
        }
      }), e(r)
    });
  }],
  ['5-', function(ym) {
    ym.modules.define("map.GeneralCollection", ["util.defineClass", "option.Manager", "event.Manager"], function(t, e, n, s) {
      function i(t, e, i, o) {
        this.events = new s({
          context: this
        }), this.options = new n(e || {}, t.options, i, o), this._map = t, this._map.events.add("destroy", this.onMapDestroy, this)
      }
      e(i, {
        getMap: function() {
          return this._map
        },
        onMapDestroy: function() {
          this._map.events.remove("destroy", this.onMapDestroy, this), this.events.fire("mapchange", {
            oldMap: this._map,
            newMap: null
          }), this.options.setParent(null)
        }
      }), t(i)
    });
  }],
  ['5!', function(ym) {
    ym.modules.define("map.GeoObjects", ["util.defineClass", "map.GeneralCollection", "geoObject.component.BoundsAggregator", "GeoObjectCollection", "map.optionMapper", "geoObject.optionMapper", "component.array.ParentArray", "event.Mapper", "geoObject.EventMappingTable", "Event", "option.Mapper", "error"], function(e, t, n, r, o, i, a, s, c, h, u, l, d) {
      function p(e, t) {
        p.superclass.constructor.call(this, e, t, "geoObject", a), this._parentArray = new s([], this, {
          onAdd: {
            callback: this._onAdd,
            context: this
          },
          onRemove: {
            callback: this._onRemove,
            context: this
          },
          onSet: {
            callback: this._onSet,
            context: this
          }
        }, new c(this.events, new h(this))), this._boundsAggregator = new r(this, {
          onPixelBoundsChange: {
            callback: this._pixelBoundsChangeCallback,
            context: this
          },
          onGeoBoundsChange: {
            callback: this._geoBoundsChangeCallback,
            context: this
          }
        })
      }

      function g(e, t) {
        return 0 == e.indexOf("editor") ? l.addOptionalPrefix(e, t) : l.addOptionalPrefixForBalloonHint(e, t)
      }
      t(p, n, {
        get: function(e) {
          return this._parentArray.get(e)
        },
        set: function(e, t) {
          return this._parentArray.set(e, t), this
        },
        add: function(e, t) {
          return this._parentArray.add(e, t), this
        },
        remove: function(e) {
          return this._parentArray.indexOf(e) == -1 ? d.warn("OveruseWarning", "map.GeoObjects.remove: удаляемый объект не найден") : this._parentArray.remove(e), this
        },
        removeAll: function() {
          return this._parentArray.removeAll(), this
        },
        splice: function(e, t) {
          return new o({
            children: this._parentArray.splice.apply(this._parentArray, arguments)
          })
        },
        getLength: function() {
          return this._parentArray.getLength()
        },
        each: function(e, t) {
          return this._parentArray.each(e, t), this
        },
        getIterator: function() {
          return this._parentArray.getIterator()
        },
        indexOf: function(e) {
          return this._parentArray.indexOf(e)
        },
        getPixelBounds: function() {
          return this._boundsAggregator.getPixelBounds()
        },
        getBounds: function() {
          return this._boundsAggregator.getBounds()
        },
        onMapDestroy: function(e) {
          this._boundsAggregator.destroy(), p.superclass.onMapDestroy.call(this, e)
        },
        _pixelBoundsChangeCallback: function() {
          this.events.fire("pixelboundschange")
        },
        _geoBoundsChangeCallback: function() {
          this.events.fire("boundschange")
        },
        _onAdd: function(e, t) {
          this.events.fire("add", new u({
            index: e,
            child: t,
            type: "add",
            target: this
          }))
        },
        _onRemove: function(e, t) {
          this.events.fire("remove", new u({
            index: e,
            child: t,
            type: "remove",
            target: this
          }))
        },
        _onSet: function(e, t, n) {
          this.events.fire("set", new u({
            index: e,
            prevChild: t,
            child: n,
            type: "set",
            target: this
          }))
        }
      }), i.setRule({
        name: "geoObject",
        rule: g
      }), i.setRule({
        name: "geoObject",
        key: ["projection"],
        rule: "plain"
      }), e(p)
    });
  }],
  ['5(', function(ym) {
    ym.modules.define("map.Hint", ["util.defineClass", "Hint", "component.sharedEntity.manager.Popup", "event.Manager", "map.optionMapper", "option.Manager", "option.Router", "util.component", "vow", "popup.managerStorage"], function(t, n, i, e, s, o, r, a, h, p, u) {
      function c(t) {
        this._map = t, this.events = new s({
          context: this
        }), this._hint = new i(t), this._hint.options.setParent(this._map.options), this._sharingManager = new e(this, this._hint, this._map), this._forkOptions = new r, this._setupListeners()
      }
      n(c, h.createProxyMethods(function() {
        return this._sharingManager
      }, ["capture", "open", "close", "isOpen", "getOverlay", "getOverlaySync", "getOwner", "setPosition", "getPosition", "setData", "getData", "setOptions", "getOptions"]), {
        destroy: function() {
          this._clearListeners(), this.capture(null), this._hint.destroy()
        },
        capture: function(t) {
          var n = this._sharingManager.capture(t);
          return n.then(this._reset, this), n
        },
        open: function(t, n, i) {
          t = t || this._map.getCenter();
          var e = p.defer(),
            s = function(t) {
              e.reject(t)
            };
          return this._sharingManager.perform("open", [t, n, i], this, function(t) {
            p.resolve(!t[2] || this.setOptions(t[2])).then(function() {
              e.resolve(this._sharingManager.getEntity().open(t[0], t[1]))
            }, s, this)
          }, s), e.promise()
        },
        setOptions: function(t) {
          return this._sharingManager.perform("setOptions", [t], this, function(t) {
            this._addForkOptions(), this._forkOptions.freeze().unsetAll().set(t[0]).unfreeze()
          })
        },
        getOptions: function() {
          return this._sharingManager.perform("getOptions", null, this, function() {
            return this._addForkOptions(), this._forkOptions
          })
        },
        _setupListeners: function() {
          this._actionListeners = this._map.events.group().add(["actionbegin", "actiontick"], this._onAction, this)
        },
        _clearListeners: function() {
          this._actionListeners.removeAll()
        },
        _onAction: function() {
          this.isOpen() && this.capture(null)
        },
        _addForkOptions: function() {
          var t = this._hint.options.getParent();
          t && "function" == typeof t.spliceParents ? t.indexOfParent(this._forkOptions) == -1 && t.spliceParents(0, 0, this._forkOptions) : this._hint.options.setParent(new a(this._forkOptions, t))
        },
        _reset: function() {
          this.getOwner() == this._map && this._hint.options.setParent(this._map.options), this._forkOptions.unsetAll()
        }
      }), u.add("map#hint", c), t(c)
    });
  }],
  ['!d', function(ym) {
    ym.modules.define("map.layer.Manager", ["util.defineClass", "LayerCollection", "layer.optionMapper", "option.Manager", "map.optionMapper"], function(e, n, t, a, r, i) {
      function o(e, n) {
        if (0 == e.indexOf("hotspotLayer")) return e;
        var t = "layer" + e.slice(0, 1).toUpperCase() + e.slice(1);
        return 0 == e.indexOf("balloon") || 0 == e.indexOf("hint") ? [t, e] : t
      }
      var s = function(e, n) {
        s.superclass.constructor.call(this, n), this.options = new r({}, e.options, "layerManager", a), this._map = e, this._mapListeners = this._map.events.group().add("destroy", this._onMapDestroy, this)
      };
      n(s, t, {
        setParent: function() {
          if (ym.env.debug) throw new Error("map.layer.Manager: невозможно выполнить операцию setParent")
        },
        getMap: function() {
          return this._map
        },
        _onMapDestroy: function() {
          this._mapListeners.removeAll(), this._map = null, this.removeAll(), this.options.setParent(null)
        }
      }), i.setRule({
        name: "layerManager",
        rule: o
      }), i.setRule({
        name: "layerManager",
        key: ["projection"],
        rule: "plain"
      }), e(s)
    });
  }],
  ['!e', function(ym) {
    ym.modules.define("map.margin.Accessor", ["event.Manager"], function(e, t) {
      function n(e, t) {
        return e.left == t.left && e.right == t.right && e.top == t.top && e.bottom == t.bottom && e.width == t.width && e.height == t.height
      }
      var r = function(e) {
        this.events = new t({
          context: this
        }), this.setArea(e)
      };
      r.prototype = {
        setArea: function(e) {
          return this._screenArea && n(this._screenArea, e) || (this._screenArea = e, this.events.fire("change")), this
        },
        getArea: function() {
          return this._screenArea
        },
        remove: function() {
          return this.events.fire("remove"), this
        }
      }, e(r)
    });
  }],
  ['!g', function(ym) {
    ym.modules.define("map.margin.Manager", ["event.Manager", "map.margin.Accessor", "util.array", "map.margin.util.findLargestFreeArea"], function(e, t, r, n, a) {
      function i(e, t) {
        return [Math.round(e[0][1]), Math.round(t[0] - e[1][0]), Math.round(t[1] - e[1][1]), Math.round(e[0][0])]
      }

      function s(e, t) {
        var r, n, a = t[0],
          i = t[1],
          s = o(e.width, a),
          h = o(e.height, i),
          c = null;
        return r = e.hasOwnProperty("left") ? o(e.left, a) : e.hasOwnProperty("right") ? a - o(e.right, i) - s : 0, n = e.hasOwnProperty("top") ? o(e.top, i) : e.hasOwnProperty("bottom") ? i - o(e.bottom, i) - h : 0, s > 0 && h > 0 && (c = [
          [r, n],
          [r + s, n + h]
        ]), c
      }

      function o(e, t) {
        if ("string" == typeof e) {
          var r = e[e.length - 1];
          e = "%" == r ? Number(e.replace("%", "")) / 100 * t : "x" == r ? Number(e.replace("px", "")) : Number(e)
        }
        return e
      }

      function h(e, t) {
        return e[0] == t[0] && e[1] == t[1] && e[2] == t[2] && e[3] == t[3]
      }
      var c = function(e) {
        this._mapContainer = e.container, this._margin = [0, 0, 0, 0], this._accessors = [], this.events = new t({
          context: this
        }), this._setupMapListener()
      };
      c.prototype = {
        getMargin: function() {
          return this._margin
        },
        addArea: function(e) {
          var t = new r(e);
          return t.events.add("change", this._recalculateMargin, this).add("remove", this._onAccessorRemoved, this), this._accessors.push(t), this._recalculateMargin(), t
        },
        destroy: function() {
          return this._teardownMapListener(), this
        },
        _onAccessorRemoved: function(e) {
          var t = e.get("target");
          t.events.remove("change", this._recalculateMargin, this).remove("remove", this._onAccessorRemoved, this), n.remove(this._accessors, t), this._recalculateMargin()
        },
        _recalculateMargin: function() {
          var e = [],
            t = this._mapContainer.getSize();
          n.each(this._accessors, function(r) {
            var n = s(r.getArea(), t);
            n && e.push(n)
          }, this);
          var r = [0, 0, 0, 0];
          if (e.length > 0) {
            var o = a(e, t);
            o && (r = i(o, t))
          }
          h(r, this._margin) || (this._margin = r, this.events.fire("change"))
        },
        _setupMapListener: function() {
          this._mapContainer.events.add("sizechange", this._recalculateMargin, this)
        },
        _teardownMapListener: function() {
          this._mapContainer.events.remove("sizechange", this._recalculateMargin, this)
        }
      }, e(c)
    });
  }],
  [':s', function(ym) {
    ym.modules.define("map.margin.util.findLargestFreeArea", ["util.array"], function(n, r) {
      function e(n, r) {
        for (var e = n.hLines, a = n.vLines, i = n.pixelBoundsArray, t = null, s = 0, f = a.length - 1; s < f; s++) {
          var h = l(i, a[s], e[r], a[s + 1], e[r + 1]);
          h ? (null != t && u(n, t, s, r), t = null) : null == t && (t = s)
        }
        null != t && u(n, t, s, r)
      }

      function u(n, r, e, u) {
        for (var l = n.hLines, a = n.vLines, i = n.pixelBoundsArray, t = a[r], s = a[e], f = l[0], h = l[l.length - 1], o = l[u], v = l[u + 1], d = 0, g = i.length; d < g; d++) {
          var p = i[d];
          p[0][0] <= t && p[1][0] <= t || p[0][0] >= s && p[1][0] >= s || (f < p[1][1] && o >= p[1][1] && (f = p[1][1]), h > p[0][1] && v <= p[0][1] && (h = p[0][1]))
        }
        var x = (s - t) * (h - f);
        n.maxArea < x && (n.maxArea = x, n.result = [
          [t, f],
          [s, h]
        ])
      }

      function l(n, r, e, u, l) {
        for (var a = !1, i = 0, t = n.length; i < t; i++) {
          var s = n[i],
            a = r >= s[0][0] && u <= s[1][0] && e >= s[0][1] && l <= s[1][1];
          if (a) break
        }
        return a
      }
      var a = function(n, r) {
          return n - r
        },
        i = function(n, u) {
          for (var l = {
              hLines: [0],
              vLines: [0],
              result: null,
              pixelBoundsArray: n,
              maxArea: 0
            }, i = l.hLines, t = l.vLines, s = 0, f = n.length; s < f; s++) {
            var h = n[s];
            r.indexOf(t, h[0][0]) == -1 && t.push(h[0][0]), r.indexOf(t, h[1][0]) == -1 && t.push(h[1][0]), r.indexOf(i, h[0][1]) == -1 && i.push(h[0][1]), r.indexOf(i, h[1][1]) == -1 && i.push(h[1][1])
          }
          i.sort(a), t.sort(a), i[i.length - 1] != u[1] && i.push(u[1]), t[t.length - 1] != u[0] && t.push(u[0]);
          for (var s = 0, f = i.length - 1; s < f; s++) e(l, s);
          return l.result
        };
      n(i)
    });
  }],
  ['5,', function(ym) {
    ym.modules.define("map.metaOptions", ["option.Manager", "option.Mapper", "projection.wgs84Mercator", "meta.internal"], function(e, o, n, t, i) {
      var a = new n,
        r = new o({}, null, null, a),
        p = i.suppressDistribution;
      r.mapper = a, r.set({
        projection: t,
        dragInertia: !0,
        minZoom: ym.env.restrictions && ym.env.restrictions.minZoom || 0,
        maxZoom: 23,
        dblClickTimeout: 400,
        touchContextMenuTimeout: 400,
        pointerContextMenuTimeout: 1e3,
        avoidFractionalZoom: !0,
        autoFitToViewport: "ifNull",
        autoFitToViewportDelay: 200,
        restrictMapArea: !1,
        balloonManager: "map#balloon",
        hintManager: "map#hint",
        fullscreenZIndex: 1e4,
        exitFullscreenByEsc: !0,
        suppressMapOpenBlock: p
      }), e(r)
    });
  }],
  ['5:', function(ym) {
    ym.modules.define("map.optionMapper", ["option.Mapper"], function(p, e) {
      p(new e)
    });
  }],
  [':t', function(ym) {
    ym.modules.define("map.pane.helper.areas", ["pane.MovablePane", "constants.paneZIndex", "map.pane.helper.storage"], function(e, a, n, p) {
      p.add("areas", function(e) {
        return new a(e, {
          zIndex: n.areas
        })
      }), e({})
    });
  }],
  [':u', function(ym) {
    ym.modules.define("map.pane.helper.balloon", ["pane.MovablePane", "constants.paneZIndex", "map.pane.helper.storage"], function(n, e, a, o) {
      o.add("balloon", function(n) {
        return new e(n, {
          zIndex: a.balloon
        })
      }), n({})
    });
  }],
  [':v', function(ym) {
    ym.modules.define("map.pane.helper.controls", ["pane.StaticPane", "constants.paneZIndex", "map.pane.helper.storage", "pane.controls.css"], function(n, e, o, t) {
      t.add("controls", function(n) {
        return new e(n, {
          zIndex: o.controls,
          css: {
            width: "100%"
          }
        })
      }), n({})
    });
  }],
  [':w', function(ym) {
    ym.modules.define("map.pane.helper.copyrights", ["pane.StaticPane", "constants.paneZIndex", "Monitor", "map.pane.helper.storage", "util.dom.style", "util.extend"], function(t, e, n, o, i, r, a) {
      function s(t) {
        for (var e in t) t.hasOwnProperty(e) && "auto" != t[e] && (t[e] += "px");
        return t
      }
      i.add("copyrights", function(t) {
        function i() {
          var e, n = {
              left: "auto",
              right: "auto",
              top: "auto",
              bottom: "auto"
            },
            o = t.options.get("copyrightPosition"),
            i = t.state.get("margin");
          return "undefined" != typeof o ? (o = a({}, n, o), e = o) : e = a({}, n, {
            bottom: i[2] + 5,
            right: i[1] + 3,
            left: i[3] + 10
          }), s(e)
        }
        var p = new e(t, {
            zIndex: n.copyrights,
            css: a(i(), {
              height: 0
            })
          }),
          u = function() {
            r.css(p.getElement(), i())
          },
          d = new o(t.state).add("margin", u),
          c = new o(t.options).add("copyrightPosition", u);
        return t.events.once("destroy", function() {
          d.destroy(), c.destroy()
        }), p
      }), t({})
    });
  }],
  [':x', function(ym) {
    ym.modules.define("map.pane.helper.editor", ["pane.MovablePane", "constants.paneZIndex", "map.pane.helper.storage"], function(e, n, a, d) {
      d.add("editor", function(e) {
        return new n(e, {
          zIndex: a.editor
        })
      }), e({})
    });
  }],
  [':y', function(ym) {
    ym.modules.define("map.pane.helper.editorActiveVertex", ["pane.MovablePane", "constants.paneZIndex", "map.pane.helper.storage"], function(e, n, t, a) {
      a.add("editorActiveVertex", function(e) {
        return new n(e, {
          zIndex: t.editorActiveVertex
        })
      }), e({})
    });
  }],
  [':A', function(ym) {
    ym.modules.define("map.pane.helper.editorMenu", ["pane.MovablePane", "constants.paneZIndex", "map.pane.helper.storage"], function(e, n, a, o) {
      o.add("editorMenu", function(e) {
        return new n(e, {
          overflow: "visible",
          zIndex: a.editorMenu
        })
      }), e({})
    });
  }],
  [':B', function(ym) {
    ym.modules.define("map.pane.helper.ground", ["pane.MovablePane", "constants.paneZIndex", "map.pane.helper.storage", "map.metaOptions", "theme.browser.current"], function(e, n, a, r, o) {
      r.add("ground", function(e) {
        return new n(e, {
          zIndex: a.ground,
          margin: o.get("groundPaneViewportMargin", 128)
        })
      }), e({})
    });
  }],
  [':C', function(ym) {
    ym.modules.define("map.pane.helper.ground-webgl", ["pane.movable.TransformPane", "constants.paneZIndex", "map.pane.helper.storage", "map.metaOptions", "theme.browser.current"], function(e, n, a, r, o) {
      r.add("ground-webgl", function(e) {
        return new n(e, {
          zIndex: a.ground,
          margin: 0
        })
      }), e({})
    });
  }],
  [':D', function(ym) {
    ym.modules.define("map.pane.helper.hint", ["pane.StaticPane", "constants.paneZIndex", "map.pane.helper.storage"], function(n, e, t, a) {
      a.add("hint", function(n) {
        return new e(n, {
          zIndex: t.hint,
          checkContextMenu: !0
        })
      }), n({})
    });
  }],
  [':E', function(ym) {
    ym.modules.define("map.pane.helper.outerBalloon", ["pane.MovablePane", "constants.paneZIndex", "map.pane.helper.storage"], function(e, n, o, a) {
      a.add("outerBalloon", function(e) {
        return new n(e, {
          overflow: "visible",
          zIndex: o.outerBalloon
        })
      }), e({})
    });
  }],
  [':F', function(ym) {
    ym.modules.define("map.pane.helper.outerHint", ["pane.StaticPane", "constants.paneZIndex", "map.pane.helper.storage"], function(e, n, t, a) {
      a.add("outerHint", function(e) {
        return new n(e, {
          overflow: "visible",
          zIndex: t.outerHint,
          checkContextMenu: !0
        })
      }), e({})
    });
  }],
  [':G', function(ym) {
    ym.modules.define("map.pane.helper.overlaps", ["pane.MovablePane", "constants.paneZIndex", "map.pane.helper.storage"], function(e, n, a, p) {
      p.add("overlaps", function(e) {
        return new n(e, {
          zIndex: a.overlaps
        })
      }), e(!0)
    });
  }],
  [':H', function(ym) {
    ym.modules.define("map.pane.helper.panel", ["pane.StaticPane", "constants.paneZIndex", "map.pane.helper.storage"], function(e, n, a, t) {
      t.add("panel", function(e) {
        return new n(e, {
          zIndex: a.controls + 1,
          css: {
            bottom: 0,
            top: void 0,
            width: "100%"
          }
        })
      }), e({})
    });
  }],
  [':K', function(ym) {
    ym.modules.define("map.pane.helper.places", ["pane.MovablePane", "constants.paneZIndex", "map.pane.helper.storage"], function(e, n, a, p) {
      p.add("places", function(e) {
        return new n(e, {
          zIndex: a.places
        })
      }), e({})
    });
  }],
  [':L', function(ym) {
    ym.modules.define("map.pane.helper.shadows", ["pane.MovablePane", "constants.paneZIndex", "map.pane.helper.storage"], function(e, n, a, s) {
      s.add("shadows", function(e) {
        return new n(e, {
          zIndex: a.shadows
        })
      }), e({})
    });
  }],
  [':M', function(ym) {
    ym.modules.define("map.pane.helper.storage", ["util.Storage"], function(e, n) {
      e(new n)
    });
  }],
  ['!h', function(ym) {
    ym.modules.define("map.pane.Manager", ["util.defineClass", "util.array", "util.dom.element", "util.dom.style", "util.dom.className", "map.pane.helper.storage", "util.css", "map.pane.helper.areas", "map.pane.helper.balloon", "map.pane.helper.controls", "map.pane.helper.copyrights", "map.pane.helper.editor", "map.pane.helper.ground", "map.pane.helper.ground-webgl", "map.pane.helper.hint", "map.pane.helper.outerBalloon", "map.pane.helper.outerHint", "map.pane.helper.overlaps", "map.pane.helper.panel", "map.pane.helper.places", "map.pane.helper.shadows", "map.paneManager.css"], function(e, n, t, r, a, i, s, h) {
      function l(e) {
        this._map = e, this._innerElement = null, this._outerElement = null, this._hash = {}, this._array = []
      }
      n(l, {
        getInnerElement: function() {
          return this._innerElement || (this._innerElement = this._createInnerElement())
        },
        getOuterElement: function() {
          return this._outerElement || (this._outerElement = this._createOuterElement())
        },
        get: function(e) {
          return this._hash[e] || this._tryToCreatePane(e), this._hash[e] ? this._hash[e].pane : null
        },
        append: function(e, n) {
          if (ym.env.debug && this._hash[e]) throw new Error('map.pane.Manager.append: Для данной карты пейн с ключом "' + e + '" уже существует');
          this._addPane(e, n)
        },
        insertBefore: function(e, n, t) {
          if (ym.env.debug) {
            if (this._hash[e]) throw new Error('map.pane.Manager.insertBefore: Для данной карты пейн с ключом "' + e + '" уже существует');
            if (!this._hash[t]) throw new Error('map.pane.Manager.insertBefore: Для данной карты пейн с ключом "' + t + '" отсутствует')
          }
          this._addPane(e, n, t)
        },
        remove: function(e) {
          for (var n = null, t = 0, a = this._array.length; t < a; t++)
            if (this._array[t].pane == e) {
              n = this._array[t];
              break
            }
          if (n) {
            e.events.setParent(null);
            var s = e.getElement();
            r.remove(s), i.remove(s, h.addPrefix(n.key + "-pane")), n.listeners.removeAll(), this._array.splice(t, 1), delete this._hash[n.key], this._refreshZIndexes()
          } else if (ym.env.debug) throw new Error("map.pane.Manager.remove: Для данной карты пейн отсутствует")
        },
        getUpper: function() {
          return this._findPane(0 == arguments.length ? this._array : this._keysToPanes(arguments), !0)
        },
        getLower: function() {
          return this._findPane(0 == arguments.length ? this._array : this._keysToPanes(arguments), !1)
        },
        destroy: function() {
          for (var e = 0, n = this._array.length; e < n; e++) {
            var t = this._array[e];
            t.listeners.removeAll(), t.pane.destroy()
          }
          this._innerElement && r.remove(this._innerElement), this._outerElement && r.remove(this._outerElement)
        },
        _createInnerElement: function() {
          var e = this._map.container;
          return r.create({
            parentNode: e.getElement(),
            className: h.addPrefix("inner-panes")
          })
        },
        _createOuterElement: function() {
          var e = this._map.container;
          return r.create({
            parentNode: e.getElement(),
            className: h.addPrefix("outer-panes")
          })
        },
        _tryToCreatePane: function(e) {
          var n = s.get(e);
          n && this._addPane(e, n(this._map))
        },
        _addPane: function(e, n, r) {
          var a = {
            key: e,
            pane: n,
            zIndex: 0,
            listeners: n.events.group().add("zindexchange", this._onZIndexChange, this).add("overflowchange", this._onOverflowChange, this)
          };
          this._hash[e] = a, r ? this._array.splice(t.indexOf(this._array, this._hash[r]), 0, a) : this._array.push(a), this._refreshZIndexes();
          var s = n.getElement();
          i.add(s, h.addPrefix(e + "-pane")), this._overflowToElement(n.getOverflow()).appendChild(s), n.events.setParent(this._map.container.events)
        },
        _findPane: function(e, n) {
          for (var t = null, r = 0, a = e.length; r < a; r++) {
            var i = e[r];
            t && !(n ? t.zIndex < i.zIndex : t.zIndex > i.zIndex) || (t = i)
          }
          return t ? t.key : null
        },
        _onZIndexChange: function() {
          this._refreshZIndexes()
        },
        _onOverflowChange: function(e) {
          var n = e.get("target");
          this._overflowToElement(n.getOverflow()).appendChild(n.getElement())
        },
        _refreshZIndexes: function() {
          for (var e = 0, n = this._array.length; e < n; e++) {
            var t = this._array[e];
            t.zIndex = t.pane.getElement().style.zIndex = t.pane.getZIndex() * n + e
          }
        },
        _overflowToElement: function(e) {
          if ("visible" == e) return this.getOuterElement();
          if ("hidden" == e) return this.getInnerElement();
          if (ym.env.debug) throw new Error('map.pane.Manager: Неверный результат getOverflow(): "' + e + '"');
          return null
        },
        _keysToPanes: function(e) {
          for (var n = [], t = 0, r = e.length; t < r; t++) {
            var a = e[t];
            if (this._hash[a] || this._tryToCreatePane(a), n[t] = this._hash[a], ym.env.debug && !n[t]) throw new Error('map.pane.Manager: Пейн с именем "' + a + '" не найден')
          }
          return n
        }
      }), e(l)
    });
  }],
  ['0U', function(ym) {
    ym.modules.define("map.paneManager.css", ["map-pane-manager"], function(a) {
      a({})
    });
  }],
  ['02', function(ym) {
    ym.modules.define("map.ru.css", ["map-ru-css"], function(s) {
      s({})
    });
  }],
  ['5@', function(ym) {
    ym.modules.define("map.ZoomRange", ["util.defineClass", "component.ZoomRangeObserver", "event.Manager", "util.bind", "util.math.areEqual", "Monitor", "vow"], function(t, o, n, e, i, s, r, a) {
      var h = function(t, o) {
        this._map = t, this._mapListeners = t.events.group().add("actionend", this._onActionEnd, this).add("destroy", this._onMapDestroy, this), this._mapOptionsMonitor = new r(this._map.options), this._mapOptionsMonitor.add(["minZoom", "maxZoom"], this._onConstraintsChange, this), this._zoomRange = this._constraints = o, this._providersZoomRange = null, this._error = null, this._zoomRangeObserver = new n(i(this._onProviderChange, this)), this.events = new e
      };
      o(h, {
        get: function(t) {
          var o = a.defer();
          return t || (t = this._map.getCenter({
            useMapMargin: this._map.options.get("coverageUseMapMargin", !1)
          }), this._lastDeferred = o), this._zoomRangeObserver.get(t).then(function(n) {
            this._onReady(null, n, t, o)
          }, function(n) {
            this._onReady(n, null, t, o)
          }, this), o.promise()
        },
        _onReady: function(t, o, n, e) {
          var i;
          if (i = t ? "noProvider" == t ? this._constraints.slice() : this._zoomRange : [Math.max(this._constraints[0], o[0]), Math.min(this._constraints[1], o[1])], this._lastDeferred == e && s(n, this._map.getCenter(), 1e-7)) {
            var r = this._zoomRange;
            this._providersZoomRange = o, this._error = t, this._zoomRange = i.slice(), r[0] == i[0] && r[1] == i[1] || this.events.fire("change", {
              oldZoomRange: r,
              newZoomRange: i
            })
          }
          e.resolve(i)
        },
        getCurrent: function() {
          return this._zoomRange.slice()
        },
        _onActionEnd: function() {
          this.get()
        },
        _onMapDestroy: function() {
          this._mapListeners.removeAll(), this._mapOptionsMonitor.destroy(), this._zoomRangeObserver.destroy()
        },
        _onConstraintsChange: function() {
          var t = this._zoomRange,
            o = this._map,
            n = this._providersZoomRange;
          this._constraints = [o.options.get("minZoom"), o.options.get("maxZoom")], n ? this._zoomRange = [Math.max(this._constraints[0], n[0]), Math.min(this._constraints[1], n[1])] : this._zoomRange = this._constraints.slice(), t[0] == this._zoomRange[0] && t[1] == this._zoomRange[1] || this.events.fire("change", {
            oldZoomRange: t,
            newZoomRange: this._zoomRange.slice()
          })
        },
        _onProviderChange: function() {
          this.get()
        },
        addProvider: function(t, o) {
          return "function" == typeof t.getZoomRange && this._zoomRangeObserver.addProvider(t, o), this
        },
        removeProvider: function(t) {
          return "function" == typeof t.getZoomRange && this._zoomRangeObserver.removeProvider(t), this
        }
      }), t(h)
    });
  }],
  ['1o', function(ym) {
    ym.modules.define("MapEvent", ["util.defineClass", "Event", "mapEvent.overrideStorage", "component.event.Cacher"], function(e, t, n, c, i) {
      function r(e, t) {
        r.superclass.constructor.call(this, e, t), this._cache = {}, this._cacher = new i(this, this._cache, c)
      }
      t(r, n, {
        get: function(e) {
          var t = this._cacher.get(e);
          return "undefined" == typeof t && this.getSourceEvent() && (t = this.getSourceEvent().get(e)), t
        },
        callMethod: function(e) {
          var t = this._cacher.get(e);
          return "undefined" == typeof t && this.getSourceEvent() ? this.getSourceEvent().callMethod.apply(this.getSourceEvent(), arguments) : t.apply(this.originalEvent, Array.prototype.slice.call(arguments, 1))
        },
        clone: function(e) {
          return new r(e, this.getSourceEvent())
        }
      }), e(r)
    });
  }],
  ['5i', function(ym) {
    ym.modules.define("mapEvent.override.common", ["mapEvent.overrideStorage"], function(e, o) {
      function r(e) {
        return e.originalEvent.position ? e.originalEvent.position : t(e, "page")
      }

      function t(e, o) {
        var r = e.get("domEvent");
        if (ym.env.debug && !r) throw new Error("MapEvent.getDomEventPixels: Не удалось получить DOM-событие");
        return [r.get(o + "X"), r.get(o + "Y")]
      }
      o.add("coords", function(e) {
        var o = e.get("map"),
          r = e.get("target"),
          t = (r.options || o.options).get("projection");
        if (ym.env.debug) {
          if (!t) throw new Error("MapEvent.coordsOverride: Не удалось получить проекцию");
          if (!o) throw new Error("MapEvent.coordsOverride: У события нет ссылки на карту")
        }
        return t.fromGlobalPixels(e.get("globalPixels"), o.action.getCurrentState().zoom)
      }), ym.env.debug && o.add("coordPosition", function() {
        throw new Error('MapEvent: Поле "coordPosition" не поддерживается, используйте "coords"')
      }), o.add("globalPixels", function(e) {
        if (ym.env.debug) {
          if (!e.get("pagePixels")) throw new Error("MapEvent.globalPixelsOverride: У события нет пиксельных координат");
          if (!e.get("map")) throw new Error("MapEvent.globalPixelsOverride: У события нет ссылки на карту")
        }
        return e.get("map").converter.pageToGlobal(e.get("pagePixels"))
      }), o.add("globalPixelPosition", function() {
        throw new Error('MapEvent: Поле "globalPixelPosition" не поддерживается, используйте "globalPixels"')
      }), o.add("position", r), o.add("pagePixels", r), o.add("clientPixels", function(e) {
        return t(e, "client")
      }), e(!0)
    });
  }],
  ['5j', function(ym) {
    ym.modules.define("mapEvent.overrideStorage", ["util.Storage"], function(e, n) {
      e(new n)
    });
  }],
  ['1r', function(ym) {
    ym.modules.define("MapType", [], function(e) {
      var t = function(e, t) {
        this._name = e, this._layers = t
      };
      t.prototype = {
        getLayers: function() {
          return this._layers
        },
        getName: function(e) {
          return this._name
        }
      }, e(t)
    });
  }],
  ['5Q', function(ym) {
    ym.modules.define("mapType.storage", ["util.Storage"], function(e, n) {
      e(new n)
    });
  }],
  ['1v', function(ym) {
    ym.modules.define("meta", [], function(e) {
      e({
        version: ym.env.version,
        coordinatesOrder: ym.env.coordinatesOrder,
        mode: ym.env.debug ? "debug" : "release",
        languageCode: ym.env.languageCode,
        countryCode: ym.env.countryCode,
        ns: ym.ns,
        isEnterprise: !!ym.env.enterprise
      })
    });
  }],
  ['5I', function(ym) {
    ym.modules.define("meta.internal", ["meta"], function(e, a) {
      var t = window.location.hostname,
        i = !!t.match(/(yandex|яндекс)\.(ru|com|by|ua|com\.tr|com\.ua|kz|рф)$/i),
        n = !!t.match(/tech\.yandex\.(ru|com|by|ua|com\.tr|com\.ua|kz|рф)$/i),
        o = "RU" == a.countryCode && (n || !i),
        m = !n && (a.isEnterprise || i);
      e({
        meta: a,
        isYandex: i,
        isYandexTech: n,
        displayAdvert: o,
        suppressDistribution: m
      })
    });
  }],
  ['1x', function(ym) {
    ym.modules.define("Monitor", ["util.extend", "util.bind", "util.array"], function(e, a, t, s) {
      function n(e) {
        this._dataManager = e, this._groups = [], this._names = {}, this._values = {}, this._oldValues = null, this._cleanTimeoutId = 0, this._clearGroupsCallback = t(function() {
          this._cleanTimeoutId = 0, this._clearGroups()
        }, this)
      }

      function l(e, a, t, s) {
        var n = {
          names: "string" == typeof e ? [e] : e.slice(),
          singleName: "string" == typeof e,
          changeCallback: a,
          context: t,
          resolveCallbacks: {},
          compareCallbacks: {},
          defaultValues: {},
          deleted: !1
        };
        if (s)
          for (var l = n.names, r = n.resolveCallbacks, o = n.compareCallbacks, i = n.defaultValues, h = 0, u = l.length; h < u; h++) e = l[h], r[e] = s.resolveCallbacks && s.resolveCallbacks[e] || s.resolveCallback, o[e] = s.compareCallbacks && s.compareCallbacks[e] || s.compareCallbacks, i[e] = s.defaultValues && "undefined" != typeof s.defaultValues[e] ? s.defaultValues[e] : s.defaultValue;
        return n
      }
      a(n.prototype, {
        add: function(e, a, t, s) {
          this._groups.length || this._dataManager.events.add("change", this._onChange, this);
          var n = l(e, a, t, s);
          if (ym.env.debug)
            for (var r = 0, o = n.names.length; r < o; r++)
              if (this._names[n.names[r]]) throw new Error('Monitor.add: name "' + n.names[r] + '" has already been added.');
          for (var r = 0, o = n.names.length; r < o; r++) e = n.names[r], this._names[e] = n, this._values[e] = this._resolveName(e);
          return this._groups.push(n), this
        },
        remove: function(e) {
          if ("string" == typeof e) this._removeField(e);
          else
            for (var a = 0, t = e.length; a < t; a++) this._removeField(e[a]);
          return this._groups.length || this._dataManager.events.remove("change", this._onChange, this), this
        },
        removeAll: function() {
          return this._values = {}, this._names = {}, this._groups = [], this._dataManager.events.remove("change", this._onChange, this), this
        },
        get: function(e) {
          return this._values[e]
        },
        forceChange: function() {
          return this._onChange(), this
        },
        _removeField: function(e) {
          if (ym.env.debug && !this._names[e]) throw new Error('Monitor.remove: name "' + e + '" was not added.');
          var a = this._names[e];
          delete this._values[e], delete this._names[e], 1 == a.names.length ? a.names[0] == e && a.names.pop() : a.names.splice(s.indexOf(a.names, e), 1), a.names.length || (a.deleted = !0, this._cleanTimeoutId || (this._cleanTimeoutId = setTimeout(this._clearGroupsCallback, 0)))
        },
        _resolveName: function(e) {
          var a = this._names[e],
            t = a.resolveCallbacks[e] ? a.context ? a.resolveCallbacks[e].call(a.context, e, this._dataManager) : a.resolveCallbacks[e](e, this._dataManager) : this._dataManager.get(e);
          return "undefined" == typeof t ? a.defaultValues[e] : t
        },
        _onChange: function() {
          for (var e = this._values, a = 0, t = this._groups.length; a < t; a++) {
            if (!this._groups.length) return;
            var s = this._groups[a];
            s.deleted || this._checkGroup(s, e)
          }
        },
        _checkGroup: function(e, t) {
          for (var s, n, l = !1, r = 0, o = e.names.length; r < o; r++) {
            var i = e.names[r],
              h = this._resolveName(i),
              u = t[i];
            (e.compareCallbacks[i] ? e.context ? e.compareCallbacks[i].call(e.context, h, u) : e.compareCallbacks[i](h, u) : h !== u) && (l || (s = e.singleName ? u : a({}, t), n = e.singleName ? h : a({}, t), l = !0), e.singleName || (s[i] = u, n[i] = h), this._values[i] = h)
          }
          l && (e.context ? e.changeCallback.call(e.context, n, s) : e.changeCallback(n, s))
        },
        _clearGroups: function() {
          for (var e, a = 0, t = this._groups.length - 1; t >= 0; t--) this._groups[t].deleted && (a++, e = t, t > 0) || a && (this._groups.length == a ? this._groups = [] : this._groups.splice(e, a), a = 0)
        }
      }), n.prototype.destroy = n.prototype.removeAll, e(n)
    });
  }],
  [':q', function(ym) {
    ym.modules.define("multiRoute.component.BoundsAggregator", ["util.defineClass", "util.bounds", "util.pixelBounds", "component.EventFreezer"], function(e, n, s, i, o) {
      function t(e, n) {
        this._collections = e, this._callbacks = n, this._boundsCache = h, this._pixelBoundsCache = h, this._freezer = new o(this._freezerCallback, this);
        for (var s = 0, i = e.length; s < i; s++) e[s].events.add("boundschange", this._onBoundsChange, this).add("pixelboundschange", this._onPixelBoundsChange, this).add("mapchange", this._onMapChange, this)
      }
      var h = {};
      n(t, {
        freeze: function() {
          this._freezer.freeze()
        },
        unfreeze: function() {
          this._freezer.unfreeze()
        },
        isFrozen: function() {
          return this._freezer.isFrozen()
        },
        getBounds: function() {
          return this._boundsCache != h ? this._boundsCache : this._boundsCache = this._calcBounds()
        },
        getPixelBounds: function() {
          return this._pixelBoundsCache != h ? this._pixelBoundsCache : this._pixelBoundsCache = this._calcPixelBounds()
        },
        destroy: function() {
          for (var e = 0, n = this._collections.length; e < n; e++) this._collections[e].events.remove("mapchange", this._onMapChange, this).remove("pixelboundschange", this._onPixelBoundsChange, this).remove("boundschange", this._onBoundsChange, this)
        },
        _freezerCallback: function(e) {
          if (e.newBounds) {
            var n = this._callbacks.boundsChange;
            n.callback.call(n.context)
          }
          if (e.newPixelBounds) {
            var s = this._callbacks.pixelBoundsChange;
            s.callback.call(s.context)
          }
        },
        _onPixelBoundsChange: function() {
          this._pixelBoundsCache = h, this._freezer.fire("PixelBounds", null, !0)
        },
        _onBoundsChange: function() {
          this._boundsCache = h, this._freezer.fire("Bounds", null, !0)
        },
        _onMapChange: function() {
          this._boundsCache = h, this._pixelBoundsCache = h, this._freezer.freeze(), this._freezer.fire("Bounds", null, !0), this._freezer.fire("PixelBounds", null, !0), this._freezer.unfreeze()
        },
        _calcBounds: function() {
          for (var e = null, n = 0, i = this._collections.length; n < i; n++) {
            var o = this._collections[n],
              t = o.getBounds();
            t && (e = e ? s.fromBounds([e, t], o.options.get("projection")) : t)
          }
          return e
        },
        _calcPixelBounds: function() {
          for (var e = null, n = 0, s = this._collections.length; n < s; n++) {
            var o = this._collections[n],
              t = o.getPixelBounds();
            t && (e = e ? i.fromBounds([e, t]) : t)
          }
          return e
        }
      }), e(t)
    });
  }],
  ['!m', function(ym) {
    ym.modules.define("multiRoute.component.DecoratorEventMapper", ["util.defineClass", "event.Mapper", "Event", "util.extend", "util.bind"], function(t, e, n, a, i, u) {
      function r(t, e) {
        r.superclass.constructor.call(this, t, i({
          "*": u(this._defaultEventMapping, this)
        }, e))
      }
      e(r, n, {
        _defaultEventMapping: function(t) {
          return new a({
            target: this.getTargetEventManager().params.context
          }, t)
        }
      }), t(r)
    });
  }],
  [':j', function(ym) {
    ym.modules.define("multiRoute.component.EventMappingTable", ["util.defineClass", "geoObject.EventMappingTable"], function(e, t, n) {
      function i(e) {
        i.superclass.constructor.call(this, e), this.update = !1
      }
      t(i, n), e(i)
    });
  }],
  [':U', function(ym) {
    ym.modules.define("multiRoute.model.common.emptyJson", [], function(e) {
      e({
        type: "FeatureCollection",
        features: [{
          type: "FeatureCollection",
          features: [],
          properties: {
            name: "waypoints"
          }
        }, {
          type: "FeatureCollection",
          features: [],
          properties: {
            name: "viapoints"
          }
        }, {
          type: "FeatureCollection",
          features: [],
          properties: {
            name: "routes"
          }
        }],
        properties: {}
      })
    });
  }],
  [':3', function(ym) {
    ym.modules.define("multiRoute.model.component.RequestQuery", ["util.defineClass", "util.id", "util.cancelableCallback"], function(e, t, s, i) {
      function a(e, t, s) {
        this._requestCallback = e, this._cancelCallback = t, this._context = s, this._requests = []
      }
      t(a, {
        push: function(e, t, a, c) {
          var l = s.gen(),
            n = i.create(function() {
              this._finalizeRequest(l), t.apply(c, arguments)
            }, this),
            u = i.create(function() {
              this._finalizeRequest(l), a.apply(c, arguments)
            }, this);
          this._requestCallback.call(this._context, e, n, u), this._requests.push({
            id: l,
            requestData: e,
            successHandler: n,
            errorHandler: u
          })
        },
        clear: function() {
          for (var e = 0, t = this._requests.length; e < t; e++) this._cancelRequest(this._requests[e]);
          this._requests = []
        },
        _finalizeRequest: function(e) {
          for (var t = 0, s = 0, i = this._requests.length; s < i; s++) {
            var a = this._requests[s];
            if (t++, a.id == e) break;
            this._cancelRequest(a)
          }
          this._requests.splice(0, t)
        },
        _cancelRequest: function(e) {
          e.successHandler.cancel(), e.errorHandler.cancel(), this._cancelCallback.call(this._context, e.requestData)
        }
      }), e(a)
    });
  }],
  [':4', function(ym) {
    ym.modules.define("multiRoute.model.component.RequestSieve", ["util.defineClass", "util.bind"], function(t, i, e) {
      function s(t, i, s) {
        this._timeout = t, this._callback = i, this._context = s, this._lastRequest = null, this._timeoutId = NaN, this._bindedTimeoutCallback = e(this._timeoutCallback, this)
      }
      i(s, {
        process: function() {
          this._lastRequest = arguments, this._timeoutId || (this._timeoutId = setTimeout(this._bindedTimeoutCallback, 0))
        },
        setTimeout: function(t) {
          this._timeout = t
        },
        getTimeout: function() {
          return this._timeout
        },
        stop: function() {
          this._timeoutId && (clearTimeout(this._timeoutId), this._timeoutId = NaN)
        },
        _timeoutCallback: function() {
          if (this._timeoutId = NaN, this._lastRequest) {
            var t = this._lastRequest;
            this._lastRequest = null, this._timeoutId = setTimeout(this._bindedTimeoutCallback, this._timeout), this._callback.apply(this._context, t)
          }
        }
      }), t(s)
    });
  }],
  [':*', function(ym) {
    ym.modules.define("multiRouter.base.LeafView", ["util.defineClass", "multiRouter.base.View"], function(e, s, t) {
      function n(e, s) {
        n.superclass.constructor.call(this, e, s)
      }
      s(n, t, {
        setupModelListeners: function() {
          this.model.events.add("jsonchange", this.onModelJsonChange, this)
        },
        clearModelListeners: function() {
          this.model.events.remove("jsonchange", this.onModelJsonChange, this)
        },
        onModelJsonChange: function() {
          this.geometry.setCoordinates(this.model.geometry.getCoordinates()), this.events.fire("update")
        }
      }), e(n)
    });
  }],
  [':(', function(ym) {
    ym.modules.define("multiRouter.base.ParentView", ["util.defineClass", "multiRouter.base.View", "component.array.ParentArray", "event.Mapper", "multiRoute.component.EventMappingTable", "multiRoute.component.BoundsAggregator"], function(e, n, t, s, o, a, i) {
      function u(e, n) {
        u.superclass.constructor.call(this, e, n);
        var t = this.createSubCollections();
        this._parentComponent = new s(t, this, {}, new o(this.events, new a(this))), this.boundsAggregator = new i(t, {
          pixelBoundsChange: {
            callback: this._pixelBoundsChangeCallback,
            context: this
          },
          boundsChange: {
            callback: this._boundsChangeCallback,
            context: this
          }
        })
      }
      n(u, t, {
        getBounds: function() {
          return this.boundsAggregator.getBounds()
        },
        getPixelBounds: function() {
          return this.boundsAggregator.getPixelBounds()
        },
        destroy: function() {
          this.boundsAggregator.destroy(), u.superclass.destroy.call(this)
        },
        _pixelBoundsChangeCallback: function() {
          this.events.fire("pixelboundschange")
        },
        _boundsChangeCallback: function() {
          this.events.fire("boundschange")
        }
      }), e(u)
    });
  }],
  [':)', function(ym) {
    ym.modules.define("multiRouter.base.Path", ["util.defineClass", "multiRouter.base.ParentView", "GeoObjectCollection", "geometryEditor.component.SubEntityManager", "component.array.ParentArray", "option.Mapper", "util.array", "util.math.cycleRestrict", "geometry.component.findClosestPathPosition"], function(e, t, n, s, o, i, r, a, l, g) {
      function c(e, t) {
        c.superclass.constructor.call(this, e, t), this._segmentsManager = new o(e.getSegments(), {
          create: {
            callback: this.segmentCreateCallback,
            context: this
          },
          destroy: {
            callback: this.segmentDestroyCallback,
            context: this
          }
        }, "model")
      }

      function h(e, t) {
        return t[0] >= e[0][0] && t[1] <= e[0][1] && t[0] <= e[1][0] && t[1] >= e[1][1]
      }
      t(c, n, {
        createSubCollections: function() {
          return this._segmentsCollection = new s, [this._segmentsCollection]
        },
        getSegments: function() {
          return this._segmentsCollection
        },
        destroy: function() {
          this._segmentsManager.destroy(), c.superclass.destroy.call(this)
        },
        setupModelListeners: function() {
          this.model.events.add("jsonchange", this._onModelJsonChange, this)
        },
        clearModelListeners: function() {
          this.model.events.remove("jsonchange", this._onModelJsonChange, this)
        },
        _onModelJsonChange: function(e) {
          this.boundsAggregator.freeze(), e.get("segmentsChange") && this._segmentsManager.update(this.model.getSegments()), this.boundsAggregator.unfreeze(), this.events.fire("update")
        },
        findSegment: function(e) {
          for (var t = this.getMap(), n = t.options.get("projection"), s = t.getZoom(), o = n.isCycled()[0], i = Math.pow(2, s + 8) / 2, r = function(t) {
              var r = n.toGlobalPixels(t, s);
              return o && (r[0] = l(r[0], e[0] - i, e[0] + i)), r
            }, c = this.options.get("strokeWidth") / 2, u = [], d = this.getSegments(), m = 0, f = d.length; m < f; m++) {
            var p = d[m],
              C = p.properties.get("boundedBy"),
              y = [r(C[0]), r(C[1])],
              b = [
                [y[0][0] - c, y[0][1] + c],
                [y[1][0] + c, y[1][1] - c]
              ];
            h(b, e) && u.push(p)
          }
          if (1 == u.length) return u[0];
          for (var M, m = 0, f = u.length, v = 1 / 0; m < f; m++) {
            var p = u[m],
              _ = g(a.map(p.getCoordinates(), r), e).distance;
            _ < v && (v = _, M = p)
          }
          return M
        }
      }), e(c)
    });
  }],
  [':,', function(ym) {
    ym.modules.define("multiRouter.base.Point", ["util.defineClass", "multiRouter.base.LeafView", "geometry.Point"], function(e, t, n, o) {
      function r(e, t) {
        r.superclass.constructor.call(this, e, t), this._captured = !1
      }
      t(r, n, {
        createGeoObjectFeature: function(e) {
          return {
            geometry: new o(e.geometry.getCoordinates()),
            properties: e.properties
          }
        },
        capture: function() {
          this._captured = !0
        },
        release: function() {
          this._captured = !1
        },
        isCaptured: function() {
          return this._captured
        },
        onModelJsonChange: function() {
          this.isCaptured() || r.superclass.onModelJsonChange.call(this)
        }
      }), e(r)
    });
  }],
  ['::', function(ym) {
    ym.modules.define("multiRouter.base.Route", ["util.defineClass", "multiRouter.base.ParentView", "GeoObjectCollection", "geometryEditor.component.SubEntityManager", "multiRouter.preset"], function(t, e, s, o, n) {
      function a(t, e) {
        a.superclass.constructor.call(this, t, e), this._pathsManager = new n(t.getPaths(), {
          create: {
            callback: this._pathCreateCallback,
            context: this
          },
          destroy: {
            callback: this._pathDestroyCallback,
            context: this
          }
        }, "model")
      }
      e(a, s, {
        createSubCollections: function() {
          return this._pathsCollection = new o, [this._pathsCollection]
        },
        getPaths: function() {
          return this._pathsCollection
        },
        destroy: function() {
          this._pathsManager.destroy(), a.superclass.destroy.call(this)
        },
        setupModelListeners: function() {
          this.model.events.add("jsonchange", this._onModelJsonChange, this)
        },
        clearModelListeners: function() {
          this.model.events.remove("jsonchange", this._onModelJsonChange, this)
        },
        _onModelJsonChange: function(t) {
          this.boundsAggregator.freeze(), t.get("pathsChange") && this._pathsManager.update(this.model.getPaths()), this.boundsAggregator.unfreeze(), this.events.fire("update")
        },
        _pathCreateCallback: function(t, e) {
          var s = this.createSubPath(t, e);
          return this._pathsCollection.add(s, e), s
        },
        _pathDestroyCallback: function(t) {
          this._pathsCollection.remove(t), t.destroy()
        }
      }), t(a)
    });
  }],
  [':;', function(ym) {
    ym.modules.define("multiRouter.base.Segment", ["util.defineClass", "multiRouter.base.LeafView", "geometry.LineString"], function(e, t, r, o) {
      function i(e, t) {
        i.superclass.constructor.call(this, e, t)
      }
      t(i, r, {
        createGeoObjectFeature: function(e) {
          return {
            geometry: new o(e.geometry.getCoordinates()),
            properties: e.properties
          }
        }
      }), e(i)
    });
  }],
  [':@', function(ym) {
    ym.modules.define("multiRouter.base.View", ["util.defineClass", "geoObject.abstract.GeoObject"], function(e, t, s) {
      function c(e, t) {
        this.model = e, c.superclass.constructor.call(this, this.createGeoObjectFeature(e), t), this.setupModelListeners()
      }
      t(c, s, {
        createGeoObjectFeature: function(e) {
          return e
        },
        destroy: function() {
          this.clearModelListeners()
        }
      }), e(c)
    });
  }],
  [':z', function(ym) {
    ym.modules.define("multiRouter.component.PointsDragController", ["util.defineClass", "geometryEditor.component.SubEntityManager", "event.Manager"], function(t, a, e, n) {
      function i(t, a) {
        this._wayPointsManager = new e(t.getWayPoints().toArray(), {
          create: {
            callback: this._pointCreateCallback,
            context: this
          },
          compare: {
            callback: this._pointIdentificationCallback,
            context: this
          },
          destroy: {
            callback: this._pointDestroyCallback,
            context: this
          }
        }), this._viaPointsManager = new e(t.getViaPoints().toArray(), {
          create: {
            callback: this._pointCreateCallback,
            context: this
          },
          compare: {
            callback: this._pointIdentificationCallback,
            context: this
          },
          destroy: {
            callback: this._pointDestroyCallback,
            context: this
          }
        }), t.events.add("update", this._onJsonViewUpdate, this), this.multiRouteJsonView = t, this._callbacks = a
      }
      i.staticEvents = new n, a(i, {
        destroy: function() {
          this.multiRouteJsonView.events.remove("update", this._onJsonViewUpdate, this), this._wayPointsManager.destroy(), this._viaPointsManager.destroy()
        },
        _onJsonViewUpdate: function() {
          this._wayPointsManager.update(this.multiRouteJsonView.getWayPoints().toArray()), this._viaPointsManager.update(this.multiRouteJsonView.getViaPoints().toArray())
        },
        _pointIdentificationCallback: function(t, a) {
          return t.view == a
        },
        _pointCreateCallback: function(t) {
          return {
            view: t,
            listeners: t.events.group().add("dragstart", this._onDragStart, this).add("drag", this._onDrag, this).add("dragend", this._onDragEnd, this)
          }
        },
        _pointDestroyCallback: function(t) {
          t.listeners.removeAll()
        },
        _onDragStart: function(t) {
          var a = this._callbacks.dragStart;
          a.callback.call(a.context, t.get("target"), t)
        },
        _onDrag: function(t) {
          var a = this._callbacks.drag;
          a.callback.call(a.context, t.get("target"), t)
        },
        _onDragEnd: function(t) {
          var a = this._callbacks.dragEnd;
          a.callback.call(a.context, t.get("target"), t)
        }
      }), t(i)
    });
  }],
  [':Q', function(ym) {
    ym.modules.define("multiRouter.component.RouteBalloon", ["util.defineClass", "Balloon", "geometry.LineString", "util.scheduler.strategy.Raf", "util.Associate"], function(t, o, e, n, i, s) {
      function l(t) {
        this._route = t, this._map = t.getMap(), this._route.events.add("mapchange", this._onMapChange, this), this._routeGeometryController = new a(t, {
          callback: this._routeGeometryCallback,
          context: this
        })
      }

      function a(t, o) {
        this._route = t, this._callback = o, this._geometry = null, t.events.add("geometrychange", this._onRouteGeometryChange, this)
      }
      o(l, {
        open: function(t) {
          this._balloon || (this._balloon = new e(this._map), this._balloon.options.setParent(this._route.options)), this._applyBalloonPosition(this._getBalloonPosition(this._routeGeometryController.getGeometry(), t))
        },
        close: function() {
          this._balloon && this._balloon.isOpen() && this._balloon.close()
        },
        destroy: function() {
          this._balloon && this._balloon.isOpen() && this._balloon.close(), this._routeGeometryController.destroy()
        },
        _getBalloonPosition: function(t, o) {
          var e = t.getClosest(o);
          return e ? e.position : null
        },
        _routeGeometryCallback: function() {
          this._balloon && this._balloon.isOpen() && this._balloon.close()
        },
        _applyBalloonPosition: function(t) {
          t ? this._balloon.isOpen() ? this._balloon.setPosition(t) : this._balloon.open(t, {
            properties: this._route.properties,
            route: this._route
          }) : this._balloon.isOpen() && this._balloon.close()
        },
        _onMapChange: function() {
          this._map = this._route.getMap(), this._map || this._balloon && this._balloon.isOpen() && this._balloon.close()
        }
      }), o(a, {
        getGeometry: function() {
          return this._geometry || this._createGeometry(), this._geometry
        },
        destroy: function() {
          this._route.events.remove("geometrychange", this._onRouteGeometryChange, this)
        },
        _createGeometry: function() {
          for (var t = this._route.getPaths(), o = [], e = 0, i = t.getLength(); e < i; e++)
            for (var s = t.get(e), l = s.getSegments(), a = 0, r = l.getLength(); a < r; a++) {
              var h = l.get(a);
              o.push(h.geometry.getCoordinates())
            }
          this._geometry = new n(Array.prototype.concat.apply([], o)), this._geometry.options.setParent(this._route.options), this._geometry.setMap(this._route.getMap())
        },
        _onRouteGeometryChange: function() {
          this._geometry = null, this._raf && (this._raf.stop(), this._raf = null), this._raf = new i(function() {
            this._raf = null, this._callback.callback.call(this._callback.context)
          }, this), this._raf.start()
        }
      }), t(new s(function(t) {
        return new l(t)
      }))
    });
  }],
  [':J', function(ym) {
    ym.modules.define("multiRouter.driving.Path", ["util.defineClass", "multiRouter.base.Path", "multiRouter.driving.Segment"], function(e, t, n, i) {
      function s(e, t) {
        s.superclass.constructor.call(this, e, t)
      }
      t(s, n, {
        segmentCreateCallback: function(e, t) {
          var n = new i(e);
          return this.getSegments().add(n, t), n
        },
        segmentDestroyCallback: function(e) {
          this.getSegments().remove(e), e.destroy()
        }
      }), e(s)
    });
  }],
  [':I', function(ym) {
    ym.modules.define("multiRouter.driving.Route", ["util.defineClass", "multiRouter.base.Route", "GeoObjectCollection", "multiRouter.driving.Path", "multiRouter.preset"], function(t, e, u, i, o) {
      function n(t, e) {
        n.superclass.constructor.call(this, t, e)
      }
      e(n, u, {
        createSubPath: function(t) {
          return new o(t)
        }
      }), t(n)
    });
  }],
  [':Z', function(ym) {
    ym.modules.define("multiRouter.driving.Segment", ["util.defineClass", "multiRouter.base.Segment"], function(e, t, i) {
      function n(e, t) {
        n.superclass.constructor.call(this, e, t)
      }
      t(n, i, {}), e(n)
    });
  }],
  ['!o', function(ym) {
    ym.modules.define("multiRouter.editor.addon", ["util.defineClass", "event.Manager", "event.Mapper", "Event", "data.Manager", "option.Manager", "multiRouter.MultiRoute", "util.Associate", "util.cancelableCallback", "data.Sync", "yandex.counter"], function(t, e, i, n, s, r, o, a, u, l, c, h) {
      function d() {
        this.editor.isActive() && this.editor.stop()
      }

      function _(t) {
        this._multiRoute = t, this.state = new r, this.events = new i({
          context: this
        }), this.options = new o({}, t.options, "editorAddon"), this._editor = null, this._stateSync = null, this._editorEventMapper = new n(this.events, new f(this)), this._requireCallback = null
      }

      function f(t) {
        this["*"] = function(e) {
          return new s({
            target: t
          }, e)
        }
      }
      var p = new u(function(t) {
        return this.create(t), t.editor
      });
      p.create = function(t) {
        "function" == typeof t.model.setReferencePoints && (t.editor = new _(t), t.events.add("mapchange", d, t))
      }, a.getMetaEventManager().add("create", function(t) {
        p.create(t.get("target"))
      }), e(_, {
        start: function(t) {
          this._editor || (this.state.setAll(t || {}), this._requireCallback = l.create(function(t) {
            this._editor = new t(this._multiRoute, this.state.getAll()), this._editor.events.setParent(this._editorEventMapper), this._editor.options.setParent(this.options), this._stateSync = new c([this._editor.state, this.state]), this.events.fire("start")
          }, this), ym.modules.require(["multiRouter.Editor"], this._requireCallback), h.countByKey("modulesUsage", "multiRoute.editor.start"))
        },
        stop: function() {
          this._editor ? (this._stateSync.destroy(), this._editor.destroy(), this._editor = null, this.events.fire("stop")) : this._requireCallback && this._requireCallback.isActive() && this._requireCallback.cancel()
        },
        isActive: function() {
          return !!this._editor
        }
      }), t(_)
    });
  }],
  [';a', function(ym) {
    ym.modules.define("multiRouter.masstransit.Path", ["util.defineClass", "GeoObjectCollection", "option.Mapper", "multiRouter.base.Path", "multiRouter.masstransit.TransferSegment", "multiRouter.masstransit.TransportSegment", "multiRouter.masstransit.WalkSegment", "multiRouter.masstransit.SegmentMarker"], function(e, t, r, n, s, a, o, l, m) {
      function i(e, t) {
        i.superclass.constructor.call(this, e, t), this.options.setMapper(c)
      }
      var u = new n,
        c = new n,
        k = new n,
        g = n.addOptionalPrefix,
        p = n.addPrefix;
      u.setRule({
        name: "transferSegment",
        rule: function(e) {
          return g(e, "transferSegment")
        }
      }), u.setRule({
        name: "transportSegment",
        rule: function(e) {
          return g(e, "transportSegment")
        }
      }), u.setRule({
        name: "walkSegment",
        rule: function(e) {
          return g(e, "walkSegment")
        }
      }), k.setRule({
        name: "walkMarker",
        rule: function(e) {
          return [p(e, "walkMarker"), p(e, "marker"), e]
        }
      }), k.setRule({
        name: "transferMarker",
        rule: function(e) {
          return [p(e, "transferMarker"), p(e, "marker"), e]
        }
      }), k.setRule({
        name: "transportMarker",
        rule: function(e) {
          return [p(e, "transportMarker"), p(e, "marker"), e]
        }
      }), t(i, s, {
        createSubCollections: function() {
          var e = i.superclass.createSubCollections.call(this);
          return e[0].options.setMapper(u), this._markersCollection = new r, this._markersCollection.options.setMapper(k), e.push(this._markersCollection), e
        },
        getSegmentMarkers: function() {
          return this._markersCollection
        },
        segmentCreateCallback: function(e, t) {
          var r = this._segmentTypeToSegmentClass[e.getType()],
            n = new r(e),
            s = new m(e);
          return s.options.setName(e.getType() + "Marker"), this.getSegments().add(n, t), this._markersCollection.add(s, t), {
            model: e,
            segment: n,
            marker: s
          }
        },
        segmentDestroyCallback: function(e) {
          this.getSegments().remove(e.segment), this._markersCollection.remove(e.marker), e.segment.destroy(), e.marker.destroy()
        },
        _segmentTypeToSegmentClass: {
          walk: l,
          transport: o,
          transfer: a
        }
      }), e(i)
    });
  }],
  [';b', function(ym) {
    ym.modules.define("multiRouter.masstransit.Route", ["util.defineClass", "multiRouter.base.Route", "GeoObjectCollection", "multiRouter.masstransit.Path", "multiRouter.preset"], function(t, e, u, s, o) {
      function i(t, e) {
        i.superclass.constructor.call(this, t, e)
      }
      e(i, u, {
        createSubPath: function(t) {
          return new o(t)
        }
      }), t(i)
    });
  }],
  [';c', function(ym) {
    ym.modules.define("multiRouter.masstransit.SegmentMarker", ["util.defineClass", "multiRouter.base.LeafView", "geometry.Point"], function(e, t, o, r) {
      function n(e, t) {
        n.superclass.constructor.call(this, e, t)
      }
      t(n, o, {
        createGeoObjectFeature: function(e) {
          return {
            geometry: new r(e.geometry.getCoordinates()[0]),
            properties: e.properties
          }
        },
        onModelJsonChange: function() {
          this.geometry.setCoordinates(this.model.geometry.getCoordinates()[0]), this.events.fire("update")
        }
      }), e(n)
    });
  }],
  [';d', function(ym) {
    ym.modules.define("multiRouter.masstransit.TransferSegment", ["util.defineClass", "multiRouter.base.Segment"], function(e, t, s) {
      function n(e, t) {
        n.superclass.constructor.call(this, e, t), this.options.setName("transferSegment")
      }
      t(n, s, {}), e(n)
    });
  }],
  [';e', function(ym) {
    ym.modules.define("multiRouter.masstransit.TransportSegment", ["util.defineClass", "multiRouter.base.Segment"], function(t, e, s) {
      function n(t, e) {
        n.superclass.constructor.call(this, t, e), this.options.setName("transportSegment")
      }
      e(n, s, {}), t(n)
    });
  }],
  [';f', function(ym) {
    ym.modules.define("multiRouter.masstransit.WalkSegment", ["util.defineClass", "multiRouter.base.Segment"], function(t, e, s) {
      function n(t, e) {
        n.superclass.constructor.call(this, t, e), this.options.setName("walkSegment")
      }
      e(n, s, {}), t(n)
    });
  }],
  [':0', function(ym) {
    ym.modules.define("multiRouter.model.component.EmptyPointController", ["util.defineClass", "util.extend", "util.array", "util.string"], function(e, t, r, s, i) {
      function n(e, t) {
        this._request = this.filterRequest(e), this._paramsLength = a(this._request.params), this._json = t
      }

      function a(e) {
        var t = 0;
        for (var r in e) e.hasOwnProperty(r) && t++;
        return t
      }
      t(n, {
        setJsonCache: function(e, t) {
          this._json = e, this._request = this.filterRequest(t), this._paramsLength = a(this._request.params)
        },
        getJsonCache: function(e) {
          e = this.filterRequest(e);
          var t = this._arePointsEqual(e.points) && this._areParamsEqual(e.params);
          return t ? this._json : null
        },
        filterRequest: function(e) {
          for (var t, s, n, a = e.points, o = 0, u = a.length; o < u; o++) t ? i.trim(a[o]) ? t.push(a[o]) : n.push(o) : i.trim(a[o]) || (t = a.slice(0, o), n = [o]);
          if (n) {
            s = e.params.viaIndexes.slice().sort();
            for (var o = n.length - 1; o >= 0; o--) {
              for (var p = s.length - 1; s[p] > n[o];) s[p]--, p--;
              s[p] == n[o] && s.splice(p, 1)
            }
          }
          return t ? {
            points: t,
            params: r({}, e.params, {
              viaIndexes: s
            })
          } : e
        },
        completeJson: function(e, t) {
          var n = e.features[0].features,
            a = e.features[1].features,
            o = 0,
            u = 0;
          n = n.slice(), a = a.slice();
          for (var p = 0, f = t.points.length; p < f; p++) {
            var l = t.points[p],
              h = s.indexOf(t.params.viaIndexes, p);
            if (h == -1) {
              if (i.trim(l)) {
                var m = n[o];
                n[o] = r({}, m, {
                  properties: r({}, m.properties, {
                    index: o
                  })
                })
              } else n.splice(o, 0, this._getEmptyWayPointJson(o));
              o++
            } else if ("auto" == t.params.routingMode) {
              if (i.trim(l)) {
                var c = a[u];
                a[u] = r({}, c, {
                  properties: r({}, c.properties, {
                    index: u
                  })
                })
              } else a.splice(u, 0, this._getEmptyViaPointJson(u));
              u++
            }
          }
          return e = r({}, e, {
            features: e.features.slice()
          }), e.features[0] = r({}, e.features[0], {
            features: n
          }), e.features[1] = r({}, e.features[1], {
            features: a
          }), e
        },
        _arePointsEqual: function(e) {
          var t = this._request.points;
          if (e.length != t.length) return !1;
          for (var r = !0, s = 0, i = t.length; s < i; s++)
            if (e[s] != t[s]) {
              r = !1;
              break
            }
          return r
        },
        _areParamsEqual: function(e) {
          var t = this._request.params,
            r = 0,
            s = !0;
          for (var i in e)
            if (e.hasOwnProperty(i)) {
              if (e[i] != t[i]) {
                s = !1;
                break
              }
              r++
            }
          return s && (s = this._paramsLength == r), s
        },
        _getEmptyWayPointJson: function(e) {
          return {
            type: "Feature",
            properties: {
              index: e,
              request: ""
            },
            geometry: {
              type: "Point",
              coordinates: null
            }
          }
        },
        _getEmptyViaPointJson: function(e) {
          return {
            type: "Feature",
            properties: {
              index: e
            },
            geometry: {
              type: "Point",
              coordinates: null
            }
          }
        }
      }), e(n)
    });
  }],
  [':2', function(ym) {
    ym.modules.define("multiRouter.model.component.ReferencePointManager", ["util.defineClass", "multiRouter.referencePointUtils"], function(e, t, n) {
      function i(e, t) {
        this._referencePoints = e, this._changeCallback = t, this._requests = [], this._calcRequests(), this._setupPoints()
      }
      t(i, {
        setPoint: function(e, t) {
          this._clearPoint(e), this._referencePoints[e] = t, this._calcRequest(e), this._setupPoint(e), this._callChangeCallback()
        },
        setPoints: function(e) {
          this._clearPoints(), this._referencePoints = e, this._calcRequests(), this._setupPoints(), this._callChangeCallback()
        },
        getPoints: function() {
          return this._referencePoints
        },
        getRequests: function() {
          return this._requests
        },
        destroy: function() {
          this._clearPoints()
        },
        _setupPoints: function() {
          for (var e = 0, t = this._referencePoints.length; e < t; e++) this._setupPoint(e)
        },
        _setupPoint: function(e) {
          var t = this._referencePoints[e],
            i = this._getPointListeningParams(t, n.getPointType(t));
          i && i.target.events.add(i.eventName, this._onPointChange, this)
        },
        _clearPoints: function() {
          for (var e = 0, t = this._referencePoints.length; e < t; e++) this._clearPoint(e)
        },
        _clearPoint: function(e) {
          var t = this._referencePoints[e],
            i = this._getPointListeningParams(t, n.getPointType(t));
          i && i.target.events.remove(i.eventName, this._onPointChange, this)
        },
        _calcRequests: function() {
          this._requests = [];
          for (var e = 0, t = this._referencePoints.length; e < t; e++) this._calcRequest(e)
        },
        _calcRequest: function(e) {
          this._requests[e] = n.getPointRequest(this._referencePoints[e])
        },
        _getPointListeningParams: function(e, t) {
          var n = null;
          return "geometry" == t ? n = {
            target: e,
            eventName: "change"
          } : "geoObject" == t && (n = {
            target: e.geometry,
            eventName: "change"
          }), n
        },
        _onPointChange: function(e) {
          this._callChangeCallback()
        },
        _callChangeCallback: function() {
          this._changeCallback.callback.call(this._changeCallback.context)
        }
      }), e(i)
    });
  }],
  [':5', function(ym) {
    ym.modules.define("multiRouter.model.component.ServiceController", ["util.defineClass", "util.extend", "util.array", "multiRouter.service", "multiRouter.referencePointUtils", "multiRoute.model.common.emptyJson", "multiRouter.model.component.ReferencePointManager", "multiRoute.model.component.RequestSieve", "multiRoute.model.component.RequestQuery", "multiRouter.model.component.EmptyPointController", "vow"], function(e, t, s, n, i, r, a, o, c, l, u, h) {
      function _(e, t, n) {
        this._referencePointManager = new o(e, {
          callback: this._referencePointsChangeCallback,
          context: this
        }), this._params = s({}, f, t), this._callbacks = n, this._oldRequest = this._createActualRequest(), this._referencePointIndexes = null, this._serviceRequestSieve = new c(333, this._sendRequestCallback, this), this._serviceRequestQuery = new l(this._makeRequestCallback, this._cancelRequestCallback, this), this._emptyPointController = new u({
          points: [],
          params: {}
        }, a), this._prevSnap = this._params.snap, this._fireWayPointsChange = !1, this._fireViaPointsChange = !1, this._fireRoutesChange = !1, this._initFlag = !1, this._oldRequest.points.length && (this._initFlag = !0, this._serviceRequestSieve.process())
      }
      var f = {
        routingMode: "auto",
        viaIndexes: [],
        avoidTrafficJams: !1,
        results: 3,
        searchCoordOrder: ym.env.coordinatesOrder,
        boundedBy: null,
        strictBounds: !1
      };
      t(_, {
        setReferencePoints: function(e, t, s) {
          "undefined" != typeof t && (this._params.viaIndexes = t), s && (this._serviceRequestQuery.clear(), this._serviceRequestSieve.stop()), this._referencePointManager.setPoints(e)
        },
        setReferencePoint: function(e, t) {
          this._referencePointManager.setPoint(e, t)
        },
        getReferencePoints: function() {
          return this._referencePointManager.getPoints()
        },
        getReferencePointIndexes: function() {
          return this._referencePointIndexes || (this._referencePointIndexes = this._calcReferencePointIndexes())
        },
        setParams: function(e, t, n) {
          this._params = t ? s({}, this._params, e) : s({}, f, e), this._referencePointIndexes = null, (n || this._params.snap != this._prevSnap) && (this._serviceRequestQuery.clear(), this._serviceRequestSieve.stop()), this._serviceRequestSieve.process(), this._callRequestChangeCallback()
        },
        getParams: function() {
          return this._params
        },
        destroy: function() {
          this._serviceRequestQuery.clear(), this._serviceRequestSieve.stop()
        },
        _referencePointsChangeCallback: function() {
          this._referencePointIndexes = null, this._serviceRequestSieve.process(), this._callRequestChangeCallback()
        },
        _calcReferencePointIndexes: function() {
          for (var e = [], t = [], s = 0, i = this._referencePointManager.getPoints().length; s < i; s++) {
            var r = n.indexOf(this._params.viaIndexes, s) == -1 ? e : t;
            r.push(s)
          }
          return {
            way: e,
            via: t
          }
        },
        _callRequestChangeCallback: function() {
          var e = this._oldRequest,
            t = this._createActualRequest();
          this._oldRequest = t;
          var s = this._callbacks.onRequestChange;
          s && s.callback.call(s.context, e, t)
        },
        _createActualRequest: function() {
          return {
            referencePoints: this._referencePointManager.getPoints(),
            points: this._referencePointManager.getRequests(),
            params: this._params
          }
        },
        _sendRequestCallback: function() {
          var e = this._params.snap,
            t = "auto" == this._params.routingMode,
            s = this._initFlag,
            n = +new Date,
            i = this._createActualRequest();
          this._prevSnap = e, this._initFlag = !1, this._serviceRequestQuery.push(i, function(i) {
            this._serviceRequestSieve.setTimeout((this._serviceRequestSieve.getTimeout() + (+new Date - n)) / 2), this._successRequestCallback(i, "rough" == e, s, t)
          }, this._failRequestCallback, this);
          var r = this._callbacks.onRequestSend;
          r && r.callback.call(r.context, i)
        },
        _makeRequestCallback: function(e, t, s) {
          var n, r = this._emptyPointController.filterRequest(e),
            a = this._emptyPointController.getJsonCache(r),
            o = r != e;
          a ? (o && (a = this._emptyPointController.completeJson(a, e)), n = h.resolve(a)) : (n = i.route(r.points, r.params), o && (n = n.then(function(t) {
            return this._emptyPointController.setJsonCache(t, r), this._emptyPointController.completeJson(t, e)
          }, this)));
          var c = this._callbacks.onRequestLoading;
          c && (n = c.callback.call(c.context, n)), n.done(t, s)
        },
        _cancelRequestCallback: function(e) {
          var t = this._callbacks.onRequestCancel;
          t && t.callback.call(t.context, e)
        },
        _successRequestCallback: function(e, t, s, n) {
          e = this._fixConsistency(e, n);
          var i = this._callbacks.onRequestSuccess;
          i && i.callback.call(i.context, e, t, s)
        },
        _failRequestCallback: function(e) {
          var t = this._callbacks.onRequestFail;
          t && t.callback.call(t.context, e)
        },
        _coordMakers: {
          "null": function() {
            return null
          },
          string: function() {
            return null
          },
          coords: function(e) {
            return e
          },
          geometry: function(e) {
            return e.getCoordinates()
          },
          geoObject: function(e) {
            return e.geometry.getCoordinates()
          }
        },
        _fixConsistency: function(e, t) {
          var s = this.getReferencePointIndexes().via,
            n = e.features[1].features;
          if (s.length && !n.length && t)
            for (var i = 0, a = s.length; i < a; i++) {
              var o = s[i],
                c = this._referencePointManager.getPoints()[o],
                l = r.getPointType(c);
              n.push({
                type: "Feature",
                properties: {
                  index: i,
                  request: r.getPointRequest(c)
                },
                geometry: {
                  type: "Point",
                  coordinates: this._coordMakers[l](c)
                }
              })
            }
          return e
        }
      }), e(_)
    });
  }],
  ['!B', function(ym) {
    ym.modules.define("multiRouter.MultiRoute", ["util.defineClass", "event.Manager", "event.globalize", "multiRoute.component.DecoratorEventMapper", "multiRouter.component.PointsDragController", "yandex.state.component.MultiRouter", "multiRouter.MultiRouteModel", "multiRouter.MultiRouteJsonView", "multiRouter.referencePointUtils", "util.bind"], function(t, e, n, i, o, s, r, u, a, l, g) {
      function h(t, e) {
        t = c(t), this._jsonView = new a(t, e), this.geometry = this._jsonView.geometry, this.properties = this._jsonView.properties, this.state = this._jsonView.state, this.options = this._jsonView.options, this.events = new n({
          context: this
        }), this._jsonView.events.setParent(new o(this.events)), this._pointsDragController = new s(this._jsonView, {
          dragStart: {
            callback: this._onDragStart,
            context: this
          },
          drag: {
            callback: this._onDrag,
            context: this
          },
          dragEnd: {
            callback: this._onDragEnd,
            context: this
          }
        }), this.model = this._jsonView.model, this.events.addController(d), this.events.fire("create"), this._yandexStateComponent = new r(this)
      }

      function c(t) {
        return "function" != typeof t.getWayPoints && (t = new u(t.referencePoints, t.params, t.json)), t
      }
      var d = i(h);
      e(h, {
        getWayPoints: function() {
          return this._jsonView.getWayPoints()
        },
        getViaPoints: function() {
          return this._jsonView.getViaPoints()
        },
        getRoutes: function() {
          return this._jsonView.getRoutes()
        },
        setActiveRoute: function(t) {
          if (ym.env.debug && t && t.model.multiRoute != this.model) throw new Error("multiRouter.MultiRoute: Недопустимый объект маршрута.");
          this._jsonView.setActiveRoute(t)
        },
        getActiveRoute: function() {
          return this._jsonView.getActiveRoute()
        },
        getPixelBounds: function() {
          return this._jsonView.getPixelBounds()
        },
        getBounds: function() {
          return this._jsonView.getBounds()
        },
        destroy: function() {
          this._pointsDragController.destroy(), this._jsonView.events.setParent(null), this._jsonView.destroy()
        },
        getOverlay: function() {
          return this._jsonView.getOverlay()
        },
        getOverlaySync: function() {
          return this._jsonView.getOverlaySync()
        },
        setParent: function(t) {
          return this._jsonView.setParent(t), this
        },
        getParent: function() {
          return this._jsonView.getParent()
        },
        getMap: function() {
          return this._jsonView.getMap()
        },
        _onDragStart: function(t) {
          this._dragendTimeoutID && clearTimeout(this._dragendTimeoutID), t.capture(), s.staticEvents.fire("dragstart", {
            map: t.getMap()
          });
          var e = t.model.multiRoute,
            n = e.getParams();
          n.snap = "rough", e.setParams(n)
        },
        _onDrag: function(t) {
          t.model.setReferencePoint(l.fixCoordOrder(t.model.multiRoute, t.geometry.getCoordinates()))
        },
        _onDragEnd: function(t) {
          var e = t.model.multiRoute,
            n = e.getParams();
          delete n.snap, e.setParams(n);
          var i = t.getMap();
          this._dragendTimeoutID || (this._dragendTimeoutID = setTimeout(g(function() {
            this._dragendTimeoutID = NaN, s.staticEvents.fire("dragend", {
              map: i
            }), t.release()
          }, this), 700))
        }
      }), t(h)
    });
  }],
  ['!D', function(ym) {
    ym.modules.define("multiRouter.MultiRouteJsonView", ["util.defineClass", "multiRouter.base.ParentView", "geometryEditor.component.SubEntityManager", "multiRouter.WayPoint", "multiRouter.ViaPoint", "multiRouter.Pin", "multiRouter.driving.Route", "multiRouter.masstransit.Route", "multiRouter.pedestrian.Route", "option.Mapper", "GeoObjectCollection", "util.bounds", "util.bind", "multiRouter.component.RouteBalloon", "theme.islands.multiRouter.meta"], function(t, e, i, o, n, s, a, l, u, r, c, h, _, p, v) {
      function d(t, e) {
        d.superclass.constructor.call(this, t, e), this.options.setName("multiRoute"), this.options.setMapper(C), this._wayPointsManager = new o(t.getWayPoints(), {
          create: {
            callback: this._wayPointCreateCallback,
            context: this
          },
          process: {
            callback: this._wayPointProcessCallback,
            context: this
          },
          destroy: {
            callback: this._wayPointDestroyCallback,
            context: this
          }
        }, "model"), this._viaPointsManager = new o(t.getViaPoints(), {
          create: {
            callback: this._viaPointCreateCallback,
            context: this
          },
          destroy: {
            callback: this._viaPointDestroyCallback,
            context: this
          }
        }, "model"), this._routesManager = new o(t.getRoutes(), {
          create: {
            callback: this._routeCreateCallback,
            context: this
          },
          process: {
            callback: this._routeProcessCallback,
            context: this
          },
          destroy: {
            callback: this._routeDestroyCallback,
            context: this
          }
        }, "model"), this._activeRoute = this.options.get("activeRouteAutoSelection", !0) ? g(this._routesManager.getSubEntities()) : null, this._setupActiveRoute()
      }

      function g(t) {
        for (var e = null, i = 1 / 0, o = 0, n = t.length; o < n; o++) {
          var s = t[o],
            a = s.model.properties.get("durationInTraffic") || s.model.properties.get("duration");
          a && (!e || a < i) && (i = a, e = s)
        }
        return e
      }
      var C = new c,
        f = c.addOptionalPrefix;
      C.setRule({
        name: "wayPoints",
        rule: function(t) {
          return f(t, "wayPoint")
        }
      }), C.setRule({
        name: "viaPoints",
        rule: function(t) {
          return f(t, "viaPoint")
        }
      }), C.setRule({
        name: "pins",
        rule: function(t) {
          return f(t, "pin")
        }
      }), C.setRule({
        name: "routes",
        rule: function(t) {
          return f(t, "route")
        }
      }), C.setRule({
        name: "editorAddon",
        rule: function(t) {
          return c.addPrefix(t, "editor")
        }
      });
      var m = new c;
      m.setRule({
        name: "startWayPoint",
        rule: function(t) {
          return f(t, "start")
        }
      }), m.setRule({
        name: "finishWayPoint",
        rule: function(t) {
          return f(t, "finish")
        }
      });
      var R = new c;
      R.setRule({
        name: "viaPoint",
        rule: function(t) {
          return f(t, "active")
        }
      });
      var P = new c;
      P.setRule({
        name: "pin",
        rule: function(t) {
          return f(t, "active")
        }
      });
      var y = new c;
      y.setRule({
        name: "activeRoute",
        rule: function(t) {
          return f(t, "active")
        }
      });
      var b = {
        driving: l,
        masstransit: u,
        pedestrian: r
      };
      e(d, i, {
        createSubCollections: function() {
          return this._wayPointsCollection = new h, this._wayPointsCollection.options.setName("wayPoints"), this._wayPointsCollection.options.setMapper(m), this._viaPointsCollection = new h, this._viaPointsCollection.options.setName("viaPoints"), this._pinsCollection = new h, this._pinsCollection.options.setName("pins"), this._routesCollection = new h, this._routesCollection.options.setName("routes"), this._routesCollection.options.setMapper(y), this._routesCollection.events.add("dblclick", this._onRouteDblClick, this).add("click", this._onRouteClick, this), [this._wayPointsCollection, this._viaPointsCollection, this._pinsCollection, this._routesCollection]
        },
        getWayPoints: function() {
          return this._wayPointsCollection
        },
        getViaPoints: function() {
          return this._viaPointsCollection
        },
        getRoutes: function() {
          return this._routesCollection
        },
        setActiveRoute: function(t) {
          if (ym.env.debug && t && t.model.multiRoute != this.model) throw new Error("multiRouter.MultiRouteJsonView: Недопустимый объект маршрута.");
          this._setActiveRoute(t)
        },
        getActiveRoute: function() {
          return this._activeRoute
        },
        destroy: function() {
          this._routesManager.destroy(), this._viaPointsManager.destroy(), this._wayPointsManager.destroy(), d.superclass.destroy.call(this)
        },
        setupModelListeners: function() {
          this.model.events.add("jsonchange", this._onModelJsonChange, this)
        },
        clearModelListeners: function() {
          this.model.events.remove("jsonchange", this._onModelJsonChange, this)
        },
        _onModelJsonChange: function(t) {
          this.boundsAggregator.freeze(), t.get("wayPointsChange") && this._wayPointsManager.update(this.model.getWayPoints()), t.get("viaPointsChange") && this._viaPointsManager.update(this.model.getViaPoints()), t.get("routesChange") && this._routesManager.update(this.model.getRoutes()), this.boundsAggregator.unfreeze(), this.events.fire("update")
        },
        _wayPointCreateCallback: function(t, e) {
          var i = new n(t);
          this._wayPointsCollection.add(i, e);
          var o = new a(t);
          return this._pinsCollection.add(o, e), {
            model: t,
            wayPoint: i,
            pin: o
          }
        },
        _wayPointProcessCallback: function(t) {
          for (var e = 0, i = t.length; e < i; e++) {
            var o = "wayPoint";
            0 == e ? o = "startWayPoint" : e == t.length - 1 && (o = "finishWayPoint"), t[e].wayPoint.options.setName(o)
          }
        },
        _wayPointDestroyCallback: function(t) {
          this._pinsCollection.remove(t.pin), this._wayPointsCollection.remove(t.wayPoint)
        },
        _viaPointCreateCallback: function(t, e) {
          var i = new s(t);
          return this._viaPointsCollection.add(i, e), i
        },
        _viaPointDestroyCallback: function(t) {
          this._viaPointsCollection.remove(t)
        },
        _routeCreateCallback: function(t, e) {
          var i = b[t.getType()],
            o = new i(t);
          return this._routesCollection.add(o, e), o
        },
        _routeProcessCallback: function(t) {
          if (this.options.get("activeRouteAutoSelection", !0)) this._setActiveRoute(g(t));
          else {
            var e = !0;
            if (this._activeRoute)
              for (var i = 0, o = t.length; i < o; i++) t[i] == this._activeRoute && (e = !1);
            e && this._setActiveRoute(null)
          }
        },
        _routeDestroyCallback: function(t) {
          this._routesCollection.remove(t)
        },
        _setActiveRoute: function(t) {
          if (this._activeRoute != t) {
            this._activeRoute && v.get(this._activeRoute).close(), this._clearActiveRoute();
            var e = this._activeRoute;
            return this._activeRoute = t, this._setupActiveRoute(), this._setActivePins(e, this._activeRoute), this.events.fire("activeroutechange", {
              oldActiveRoute: e
            }), !0
          }
          return !1
        },
        _setupActiveRoute: function() {
          this._activeRoute && this._activeRoute.options.setName("activeRoute")
        },
        _clearActiveRoute: function() {
          this._activeRoute && this._activeRoute.options.setName("route")
        },
        _onRouteClick: function(t) {
          for (var e = t.get("target"); e && e.getParent() != this._routesCollection;) e = e.getParent();
          if (e) {
            var i = t.get("target").geometry.getType(),
              o = v.get(e);
            if ("LineString" == i) {
              var n = this._setActiveRoute(e);
              !n && this.options.get("routeOpenBalloonOnClick") && (o.open(t.get("coords")), this._forbidDblClick())
            } else this.options.get("routeOpenBalloonOnClick") && o.close()
          }
        },
        _onRouteDblClick: function(t) {
          this._dblClickForbiden && t.disallowMapEvent()
        },
        _forbidDblClick: function() {
          this._dblClickForbiden = !0, setTimeout(p(function() {
            this._dblClickForbiden = !1
          }, this), 25)
        },
        _setActivePins: function(t, e) {
          !t && e && (this._pinsCollection.options.setMapper(P), this._viaPointsCollection.options.setMapper(R)), t && !e && (this._pinsCollection.options.setMapper(null), this._viaPointsCollection.options.setMapper(null))
        },
        mapChangeCallback: function(t, e) {
          d.superclass.mapChangeCallback.call(this, t, e), e && this.options.get("boundsAutoApply") && (this._boundsAutoApply() || this.model.events.add("requestsuccess", this._onRequestSuccess1, this))
        },
        _boundsAutoApply: function() {
          var t = this._wayPointsCollection.getBounds();
          if (t) {
            var e = this.getMap().options.get("projection"),
              i = this._routesCollection.getBounds(),
              o = this._viaPointsCollection.getBounds();
            return i && (t = _.fromBounds([t, i], e)), o && (t = _.fromBounds([t, o], e)), this.getMap().setBounds(t, {
              checkZoomRange: !0,
              zoomMargin: this.options.get("zoomMargin", 0),
              useMapMargin: this.options.get("useMapMargin", !0)
            }).then(this._fireBoundsAutoApply, this), !0
          }
          return !1
        },
        _onRequestSuccess1: function(t) {
          this.model.events.remove("requestsuccess", this._onRequestSuccess1, this), t.get("init") && this.getMap() && this._boundsAutoApply()
        },
        _fireBoundsAutoApply: function() {
          this.events.fire("boundsautoapply")
        }
      }), t(d)
    });
  }],
  ['!s', function(ym) {
    ym.modules.define("multiRouter.MultiRouteModel", ["util.defineClass", "event.Manager", "data.Manager", "data.Sync", "vow", "util.array", "multiRoute.model.common.emptyJson", "multiRouter.model.component.ServiceController", "multiRoute.component.DecoratorEventMapper"], function(e, t, n, o, s, i, r, a, l, c) {
      function h(e, t) {
        this._serviceController = new l(e, t, {
          onRequestChange: {
            callback: this._requestChangeCallback,
            context: this
          },
          onRequestSend: {
            callback: this._requestSendCallback,
            context: this
          },
          onRequestLoading: {
            callback: this._requestLoadingCallback,
            context: this
          },
          onRequestSuccess: {
            callback: this._requestSuccessCallback,
            context: this
          },
          onRequestFail: {
            callback: this._requestFailCallback,
            context: this
          },
          onRequestCancel: {
            callback: this._requestCancelCallback,
            context: this
          }
        }), this._jsonModel = null, this._jsonModelDataSync = null, this._pointModelsDecorator = null, this.events = new n({
          context: this
        }), this.properties = new o
      }
      var u, d, f;
      t(h, {
        getJson: function() {
          return this._jsonModel ? this._jsonModel.getJson() : a
        },
        setReferencePoints: function(e, t, n) {
          this._serviceController.setReferencePoints(e, t, n)
        },
        getReferencePoints: function() {
          return this._serviceController.getReferencePoints()
        },
        getReferencePointIndexes: function() {
          return this._serviceController.getReferencePointIndexes()
        },
        setParams: function(e, t, n) {
          this._serviceController.setParams(e, t, n)
        },
        getParams: function() {
          return this._serviceController.getParams()
        },
        getAllPoints: function() {
          return this._pointModelsDecorator ? this._pointModelsDecorator.getAllPoints() : []
        },
        getWayPoints: function() {
          return this._pointModelsDecorator ? this._pointModelsDecorator.getWayPoints() : []
        },
        getViaPoints: function() {
          return this._pointModelsDecorator ? this._pointModelsDecorator.getViaPoints() : []
        },
        getRoutes: function() {
          return this._pointModelsDecorator ? this._pointModelsDecorator.getRoutes() : []
        },
        destroy: function() {
          this._serviceController.destroy(), this._jsonModel && (this._pointModelsDecorator.destroy(), this._jsonModelDataSync.destroy(), this._jsonModel.events.remove("jsonchange", this._onJsonModelJsonChange, this), this._jsonModel.events.setParent(null), this._jsonModel.destroy())
        },
        _requestChangeCallback: function(e, t) {
          this.events.fire("requestchange", {
            referencePoints: t.referencePoints,
            params: t.params,
            oldReferencePoints: e.referencePoints,
            oldParams: e.params
          })
        },
        _requestSendCallback: function(e) {
          this.events.fire("requestsend", {
            referencePoints: e.referencePoints,
            params: e.params
          })
        },
        _requestLoadingCallback: function(e) {
          return this._jsonModel || (e = d ? e.then(function(e) {
            return this._createJsonModel(), e
          }, this) : i.all([e, this._getPreloadPromise()]).spread(function(e) {
            return this._createJsonModel(), e
          }, this)), e
        },
        _requestSuccessCallback: function(e, t, n) {
          this._jsonModel.setJson(e);
          var o = this._fireWayPointsChange,
            s = this._fireViaPointsChange,
            i = this._fireRoutesChange;
          this._fireWayPointsChange = !1, this._fireViaPointsChange = !1, this._fireRoutesChange = !1, this.events.fire("requestsuccess", {
            init: n,
            rough: t,
            wayPointsChange: o,
            viaPointsChange: s,
            routesChange: i
          })
        },
        _requestFailCallback: function(e) {
          this.events.fire("requestfail", {
            error: e
          })
        },
        _requestCancelCallback: function(e) {
          this.events.fire("requestcancel", {
            referencePoints: e.referencePoints,
            params: e.params
          })
        },
        _createJsonModel: function() {
          this._jsonModel = new d(a), this._jsonModel.events.setParent(new c(this.events)), this._jsonModel.events.add("jsonchange", this._onJsonModelJsonChange, this), this._jsonModelDataSync = new s([this.properties, this._jsonModel.properties]), this._pointModelsDecorator = new u(this._jsonModel, this, {
            wayReferencePointChangeCallback: {
              callback: this._onWayPointReferencePointChange,
              context: this
            },
            viaReferencePointChangeCallback: {
              callback: this._onViaPointReferencePointChange,
              context: this
            }
          })
        },
        _onViaPointReferencePointChange: function(e) {
          var t = e.get("target"),
            n = this._serviceController.getReferencePointIndexes().via[r.indexOf(this._pointModelsDecorator.getViaPoints(), t)];
          this._serviceController.setReferencePoint(n, t.getReferencePoint())
        },
        _onWayPointReferencePointChange: function(e) {
          var t = e.get("target"),
            n = this._serviceController.getReferencePointIndexes().way[r.indexOf(this._pointModelsDecorator.getWayPoints(), t)];
          this._serviceController.setReferencePoint(n, t.getReferencePoint())
        },
        _getPreloadPromise: function() {
          return "undefined" == typeof f && (f = ym.modules.require(["multiRouter.model.component.PointModelsDecorator", "multiRouter.MultiRouteJsonModel"]).spread(function(e, t) {
            u = e, d = t
          })), f
        },
        _onJsonModelJsonChange: function(e) {
          this._fireWayPointsChange = e.get("wayPointsChange"), this._fireViaPointsChange = e.get("viaPointsChange"), this._fireRoutesChange = e.get("routesChange")
        }
      }), h.prototype.getPoints = h.prototype.getAllPoints, e(h)
    });
  }],
  [';g', function(ym) {
    ym.modules.define("multiRouter.pedestrian.Path", ["util.defineClass", "GeoObjectCollection", "option.Mapper", "multiRouter.base.Path", "multiRouter.pedestrian.Segment", "multiRouter.pedestrian.SegmentMarker"], function(e, t, r, n, s, a, i) {
      function o(e, t) {
        o.superclass.constructor.call(this, e, t), this.options.setMapper(m)
      }
      var l = new n,
        m = new n,
        u = new n;
      l.setRule({
        name: "pedestrianSegment",
        rule: function(e) {
          return n.addOptionalPrefix(e, "pedestrianSegment")
        }
      }), u.setRule({
        name: "pedestrianMarker",
        rule: function(e) {
          return [n.addPrefix(e, "pedestrianMarker"), n.addPrefix(e, "marker"), e]
        }
      }), t(o, s, {
        createSubCollections: function() {
          var e = o.superclass.createSubCollections.call(this);
          return e[0].options.setMapper(l), this._markersCollection = new r, this._markersCollection.options.setMapper(u), e.push(this._markersCollection), e
        },
        getSegmentMarkers: function() {
          return this._markersCollection
        },
        segmentCreateCallback: function(e, t) {
          var r = new a(e),
            n = new i(e);
          return n.options.setName(e.getType() + "Marker"), this.getSegments().add(r, t), this._markersCollection.add(n, t), {
            model: e,
            segment: r,
            marker: n
          }
        },
        segmentDestroyCallback: function(e) {
          this.getSegments().remove(e.segment), this._markersCollection.remove(e.marker), e.segment.destroy(), e.marker.destroy()
        }
      }), e(o)
    });
  }],
  [';h', function(ym) {
    ym.modules.define("multiRouter.pedestrian.Route", ["util.defineClass", "multiRouter.base.Route", "GeoObjectCollection", "multiRouter.pedestrian.Path", "multiRouter.preset"], function(e, t, u, o, i) {
      function n(e, t) {
        n.superclass.constructor.call(this, e, t)
      }
      t(n, u, {
        createSubPath: function(e) {
          return new i(e)
        }
      }), e(n)
    });
  }],
  [';k', function(ym) {
    ym.modules.define("multiRouter.pedestrian.Segment", ["util.defineClass", "multiRouter.base.Segment"], function(e, t, s) {
      function n(e, t) {
        n.superclass.constructor.call(this, e, t), this.options.setName("pedestrianSegment")
      }
      t(n, s, {}), e(n)
    });
  }],
  [';l', function(ym) {
    ym.modules.define("multiRouter.pedestrian.SegmentMarker", ["util.defineClass", "multiRouter.base.LeafView", "geometry.Point"], function(e, t, o, r) {
      function n(e, t) {
        n.superclass.constructor.call(this, e, t)
      }
      t(n, o, {
        createGeoObjectFeature: function(e) {
          return {
            geometry: new r(e.geometry.getCoordinates()[0]),
            properties: e.properties
          }
        },
        onModelJsonChange: function() {
          this.geometry.setCoordinates(this.model.geometry.getCoordinates()[0]), this.events.fire("update")
        }
      }), e(n)
    });
  }],
  ['!E', function(ym) {
    ym.modules.define("multiRouter.Pin", ["util.defineClass", "multiRouter.base.LeafView", "geometry.Point"], function(e, t, o, i) {
      function r(e, t) {
        r.superclass.constructor.call(this, e, t), this.options.setName("pin")
      }
      t(r, o, {
        createGeoObjectFeature: function(e) {
          return {
            geometry: new i(e.geometry.getCoordinates()),
            properties: e.properties
          }
        }
      }), e(r)
    });
  }],
  ['6b', function(ym) {
    var images = ym.modules.importImages({
      "via.png": {
        src: "images/via.png"
      }
    });
    ym.modules.define("multiRouter.preset", ["option.presetStorage", "map.associate.serviceGeoObjects", "util.math.cycleRestrict", "util.extend", "GeoObject", "interactivityModel.transparent", "layout.Image", "geoObject.addon.balloon"], function(e, t, o, a, i, n, r, g, m) {
      t.add("router#interactivePath", {
        balloonDataSource: function(e, t, g) {
          var s, l, c = e.getParent(),
            u = e.findSegment(g),
            d = e.geometry.getCoordinates()[u.getPolylineStartIndex()],
            p = e.getMap(),
            h = u.getHumanAction(),
            y = u.getStreet(),
            v = u.getHumanLength(),
            f = c.options.get("avoidTrafficJams") ? u.getHumanJamsTime() : u.getHumanTime(),
            T = "",
            H = p.options.get("projection"),
            b = p.getZoom(),
            C = H.isCycled()[0],
            S = Math.pow(2, b + 8) / 2,
            k = function() {
              s && (c.options.set("opacity", s), s = null), l && (o.get(p).remove(l), l = null), m.get(e).events.remove("close", k)
            },
            L = function(e) {
              var t = H.toGlobalPixels(e, b);
              return C && (t[0] = a(t[0], g[0] - S, g[0] + S)), t
            };
          h && (T += h), y && (T && (T += ", "), T += y), T && (T += "<br/>"), T += v + ", " + f, t({
            properties: i({
              balloonContent: T,
              action: u.getAction(),
              humanAction: u.getHumanAction(),
              angle: u.getAngle(),
              lenght: u.getLength(),
              length: u.getLength(),
              humanLength: u.getHumanLength(),
              time: u.getTime(),
              humanTime: u.getHumanTime(),
              jamsTime: u.getJamsTime(),
              humanJamsTime: u.getHumanJamsTime(),
              street: u.getStreet()
            }, e.properties.getAll())
          }, L(d)), k(), s = c.options.get("opacity"), c.options.set("opacity", .5), l = new n({
            geometry: {
              type: "LineString",
              coordinates: u.getCoordinates()
            }
          }, {
            interactivityModel: r,
            opacity: Math.max(2 * s - 1, 0),
            strokeWidth: e.options.get("strokeWidth"),
            strokeColor: e.options.get("strokeColor")
          }), o.get(p).add(l), m.get(e).events.add("close", k)
        }
      }), t.add("router#plainPath", {}), t.add("multiRouter#route", {
        pane: "routes",
        strokeWidth: 3,
        strokeColor: "#4d4d4d",
        opacity: .7
      }), t.add("multiRouter#activeRoute", {
        strokeColor: "#2086f8",
        opacity: .85
      }), t.add("router#viaPoint", {
        iconImageHref: images.get("via.png"),
        iconImageOffset: [-9, -9],
        iconImageSize: [18, 19],
        iconLayout: g
      }), e(!0)
    });
  }],
  ['!l', function(ym) {
    ym.modules.define("multiRouter.referencePointUtils", ["util.array"], function(e, r) {
      function t(e) {
        return "function" == typeof e.getType && "Point" == e.getType()
      }

      function n(e) {
        return e.getCoordinates().join(",")
      }

      function o(e) {
        var n = "";
        if (e ? "string" == typeof e ? n = "string" : r.isArray(e) ? n = "coords" : t(e) ? n = "geometry" : e.geometry && t(e.geometry) && (n = "geoObject") : n = "null", ym.env.debug && !n) throw new Error("multiRouter.referencePointUtils: Неправильный формат опорной точки.");
        return n
      }
      var i = {
        "null": function() {
          return ""
        },
        string: function(e) {
          return e
        },
        coords: function(e) {
          return e.join(",")
        },
        geometry: n,
        geoObject: function(e) {
          return n(e.geometry)
        }
      };
      e({
        getPointRequest: function(e) {
          return i[o(e)](e)
        },
        getPointType: o,
        fixCoordOrder: function(e, r) {
          return e.getParams().searchCoordOrder != ym.env.coordinatesOrder ? r.slice().reverse() : r
        }
      })
    });
  }],
  ['6f', function(ym) {
    ym.modules.define("multiRouter.service", ["util.defineClass", "util.array", "util.extend", "util.coordinates.decode", "util.bounds", "util.signedJsonp", "projection.wgs84Mercator", "multiRouter.service.yMapsJsonToGeoJson", "router.restrict", "geocode", "search", "vow"], function(e, t, r, n, o, s, a, i, u, c, p, f, d) {
      function l() {}

      function g(e, t) {
        for (var r = [], n = 0, o = e.length; n < o; n++) r.push(v(e[n], t));
        return r
      }

      function v(e, t) {
        var n = /^(\s*-?\d+(\.\d+)?\s*(,(?!$)|$)){2}$/;
        return "string" == typeof e && n.test(e) && (e = r.map(e.split(","), Number)), "string" != typeof e && (e = k(e, t)), e
      }

      function h(e, t) {
        for (var r = [], n = [], o = 0, s = e.length; o < s; o++) {
          var a = e[o];
          "string" == typeof a ? (r.push(a), n.push(o)) : t.reverseGeocoding && (r.push("longlat" == ym.env.coordinatesOrder ? a : [a[1], a[0]]), n.push(o))
        }
        return {
          points: r,
          indexes: n
        }
      }

      function y(e, t) {
        return M(e, t).then(function(e) {
          for (var t = [], r = [], n = 0, o = e.length; n < o; n++) {
            var s = e[n].geoObjects.get(0);
            s ? (t[n] = s.geometry.getCoordinates(), r[n] = s.properties.getAll()) : (t[n] = [], r[n] = {})
          }
          return {
            points: t,
            metaData: r
          }
        })
      }

      function m(e, t, r) {
        for (var n = t.points, o = t.metaData, s = {
            points: e.slice(),
            metaData: []
          }, a = 0, i = n.length; a < i; a++) {
          var u = r.indexes[a];
          "string" == typeof s.points[u] && (s.points[u] = k(n[a], ym.env.coordinatesOrder)), s.metaData[u] = o[a], s.metaData[u].request = r.points[a]
        }
        return s
      }

      function M(e, t) {
        for (var r = [], n = 0, o = e.length; n < o; n++) r.push(f(e[n], {
          results: 1,
          strictBounds: t.strictBounds,
          boundedBy: t.boundedBy,
          searchType: "string" == typeof t.searchType ? t.searchType : t.searchType.join(",")
        }));
        return d.all(r)
      }

      function j(e, t) {
        return e.length < 2 ? d.resolve(D(e)) : a({
          url: ym.env.hosts.api.services.route + "2.0/",
          requestParams: b(e, t),
          postprocessUrl: function(e) {
            return ym.env.hostConfigQuery ? e + "&" + ym.env.hostConfigQuery : e
          },
          responseFieldName: "data"
        })
      }

      function D(e) {
        for (var t = [], r = 0, n = e.length; r < n; r++) t.push({
          request: e[r],
          coordinates: e[r]
        });
        return {
          type: "FeatureCollection",
          properties: {
            RouterMetaData: {
              Waypoints: t
            }
          },
          features: []
        }
      }

      function O(e, t, n) {
        for (var o = e.properties.RouterMetaData.Waypoints, s = 0, a = 0, i = t.length; s < i; s++)
          if (r.indexOf(n.viaIndexes, s) == -1) {
            var u = t[s];
            u && w(o[a], u), a++
          }
        return e
      }

      function w(e, t) {
        for (var r = 0, n = C.length; r < n; r++) {
          var o = C[r];
          "undefined" != typeof t[o] && (e[o] = t[o])
        }
      }

      function x(e, t) {
        e.properties.params = t;
        var r;
        c.isActive() && (r = u(e), c.testMultiroute(r) || (e.features = [], r.features[2].features = []));
        try {
          "function" == typeof t.jsonProcessor && (e = r && t.jsonProcessor == u ? r : t.jsonProcessor(e))
        } catch (n) {
          throw new Error("multiRouter.service.route: Ошибка при разборе ответа сервера: " + n.message)
        }
        return e
      }

      function b(e, t) {
        var n = {
            lang: ym.env.lang,
            key: ym.env.key,
            token: ym.env.token,
            apikey: ym.env.apikey,
            rll: J(e).join("~"),
            rtm: t.avoidTrafficJams ? "dtr" : "atm",
            results: t.results || 3
          },
          o = t.viaIndexes;
        if (o.length) {
          if (ym.env.debug && (r.indexOf(o, 0) != -1 || r.indexOf(o, e.length - 1) != -1)) throw new Error("multiRouter.service: Недопустимый индекс транзитной точки.");
          n.via = o.join("~")
        }
        switch (t.snap && (n.snap = t.snap, "rough" != t.snap || "masstransit" != t.routingMode && "pedestrian" != t.routingMode || (n.results = 1)), t.routingMode) {
          case "masstransit":
            n.rtt = "mt";
            break;
          case "pedestrian":
            n.rtt = "pd"
        }
        return n
      }

      function J(e) {
        for (var t = [], r = 0, n = e.length; r < n; r++) t.push(String(e[r]));
        return t
      }

      function k(e, t) {
        return "longlat" != t ? e.slice().reverse() : e
      }
      l.WrongJson = function() {
        return new Error("Wrong JSON")
      }, t(l, {
        route: function(e, t) {
          t = n({
            jsonProcessor: u,
            searchCoordOrder: ym.env.coordinatesOrder,
            viaIndexes: [],
            searchType: "geo"
          }, t), e = g(e, t.searchCoordOrder);
          var r = h(e, t);
          return r.points.length ? y(r.points, t).then(function(n) {
            return n = m(e, n, r), j(n.points, t).then(function(e) {
              return e.properties ? (e = O(e, n.metaData, t), x(e, t)) : d.reject(l.WrongJson())
            })
          }, this) : j(e, t).then(function(e) {
            return e.properties ? x(e, t) : d.reject(l.WrongJson())
          })
        }
      });
      var C = ["request", "address", "description", "name", "companyMetaData", "geocoderMetaData", "publicMapMetaData"];
      e(new l)
    });
  }],
  ['!A', function(ym) {
    ym.modules.define("multiRouter.service.yMapsJsonToGeoJson", ["util.array", "util.bounds", "util.extend", "util.coordinates.decode", "formatter", "projection.wgs84Mercator", "coordSystem.geo"], function(e, t, r, n, o, a, i, s) {
      function p(e) {
        for (var t = e.properties.RouterMetaData.Waypoints, r = [], o = 0, a = t.length; o < a; o++) {
          var i = t[o];
          r[o] = {
            type: "Feature",
            properties: n({
              index: o
            }, i),
            geometry: {
              type: "Point",
              coordinates: i.coordinates ? L(i.coordinates) : null
            }
          }
        }
        return r
      }

      function u(e, t) {
        for (var r = [], n = 0, o = e.length; n < o; n++) {
          var a = e[n];
          r[n] = j[a.properties.RouteMetaData.type](a, n, t)
        }
        return r
      }

      function d(e, r, n) {
        var o = e.properties.RouteMetaData;
        return {
          type: "FeatureCollection",
          features: c(e.features, n),
          properties: {
            index: r,
            type: o.type,
            blocked: !!o.blocked,
            hasTolls: !!o.hasTolls,
            distance: o.Distance,
            duration: o.Duration,
            durationInTraffic: o.DurationInTraffic,
            boundedBy: t.map(e.properties.boundedBy, L),
            rawProperties: e.properties
          }
        }
      }

      function c(e, r) {
        for (var n = [], a = 0, i = e.length; a < i; a++) {
          var s = e[a],
            p = s.properties,
            u = p.PathMetaData,
            d = t.map(o(p.encodedCoordinates), L);
          n[a] = {
            type: "FeatureCollection",
            features: l(s.features, d, r, a),
            properties: {
              index: a,
              type: "driving",
              distance: u.Distance,
              duration: u.Duration,
              durationInTraffic: u.DurationInTraffic,
              coordinates: d,
              encodedCoordinates: p.encodedCoordinates,
              rawProperties: p
            }
          }
        }
        return n
      }

      function l(e, t, r, n) {
        for (var o = [], a = 0, i = e.length; a < i; a++) {
          var s = e[a],
            p = s.properties,
            u = p.SegmentMetaData,
            d = J(s);
          o[a] = {
            type: "Feature",
            properties: {
              index: a,
              type: "driving",
              street: u.street,
              action: u.Action,
              distance: u.Distance,
              duration: u.Duration,
              durationInTraffic: u.DurationInTraffic,
              text: u.text,
              lodIndex: d.lodIndex,
              viaPoints: f(s.geometry.geometries, t, r, n),
              rawProperties: p
            },
            geometry: {
              type: "LineString",
              coordinates: R(s, e[a + 1], t, J)
            }
          }
        }
        return o
      }

      function f(e, t, r, n) {
        for (var o = [], a = 0, i = 0, s = e.length; i < s; i++) {
          var p = e[i];
          if ("Point" == p.type) {
            var u = r.length;
            r.push({
              type: "Feature",
              properties: {
                index: u,
                lodIndex: p.lodIndex,
                pathIndex: n
              },
              geometry: {
                type: "Point",
                coordinates: t[p.lodIndex]
              }
            }), o[a] = u, a++
          }
        }
        return o
      }

      function y(e, r) {
        var n = e.properties.RouteMetaData,
          o = g(e.features);
        return {
          type: "FeatureCollection",
          features: o,
          properties: {
            index: r,
            type: n.type,
            distance: k(o),
            duration: {
              value: n.Duration.value,
              text: n.Duration.text || B(n.Duration.value)
            },
            boundedBy: e.properties.boundedBy ? t.map(e.properties.boundedBy, L) : v(o),
            rawProperties: e.properties
          }
        }
      }

      function g(e) {
        for (var r = [], n = 0, a = e.length; n < a; n++) {
          var i = e[n],
            s = i.properties,
            p = s.PathMetaData,
            u = t.map(o(s.encodedCoordinates), L),
            d = x(i.features, u);
          r[n] = {
            type: "FeatureCollection",
            features: d,
            properties: {
              index: n,
              type: "masstransit",
              distance: k(d),
              duration: p.Duration,
              coordinates: u,
              encodedCoordinates: s.encodedCoordinates,
              rawProperties: s
            }
          }
        }
        return r
      }

      function v(e) {
        for (var t = [], n = 0, o = e.length; n < o; n++) t.push(r.fromPoints(e[n].properties.coordinates, i));
        return r.fromBounds(t, i)
      }

      function x(e, t) {
        for (var r = [], n = 0, o = e.length; n < o; n++) {
          var a = e[n];
          r[n] = A[D(a)](a, e[n + 1], t, n)
        }
        return r
      }

      function D(e) {
        var t = e.properties.SegmentMetaData;
        if (t.Walk) return "walk";
        if (t.Transports) return "transport";
        if (t.Transfer) return "transfer";
        throw new Error("multiRouter.service.yMapsJsonToGeoJson: Неизвестный тип сегмента маршрута")
      }

      function m(e, t, r, n) {
        var o = e.properties.SegmentMetaData,
          a = {
            index: n,
            type: "walk",
            text: o.text,
            distance: o.Distance,
            duration: o.Duration,
            links: o.Links,
            lodIndex: G(e).lodIndex,
            rawProperties: e.properties
          };
        return o.WaitingDuration && (a.waitingDuration = o.WaitingDuration), {
          type: "Feature",
          properties: a,
          geometry: {
            type: "LineString",
            coordinates: R(e, t, r, G)
          }
        }
      }

      function I(e, t, r, n) {
        var o = R(e, t, r, G),
          a = e.properties.SegmentMetaData,
          i = {
            index: n,
            type: "transport",
            text: a.text,
            distance: T(o),
            duration: a.Duration,
            links: a.Links,
            cost: a.Cost,
            transports: a.Transports,
            lodIndex: G(e).lodIndex,
            stops: {
              type: "FeatureCollection",
              features: w(e.features, r)
            },
            rawProperties: e.properties
          };
        return {
          type: "Feature",
          properties: i,
          geometry: {
            type: "LineString",
            coordinates: o
          }
        }
      }

      function h(e, t, r, n) {
        var o = e.properties.SegmentMetaData,
          a = {
            index: n,
            type: "transfer",
            text: o.text,
            distance: o.Distance,
            duration: o.Duration,
            links: o.Links,
            lodIndex: G(e).lodIndex,
            rawProperties: e.properties
          };
        return o.WaitingDuration && (a.waitingDuration = o.WaitingDuration), {
          type: "Feature",
          properties: a,
          geometry: {
            type: "LineString",
            coordinates: R(e, t, r, G)
          }
        }
      }

      function w(e, t) {
        for (var r = [], n = 0, o = 0, a = e.length; n < a; n++) {
          var i = e[n],
            s = i.properties && i.properties.StopMetaData,
            p = i.geometry.lodIndex;
          s && (r[o] = {
            type: "Feature",
            properties: {
              index: o,
              id: s.id,
              name: s.name,
              lodIndex: p,
              rawProperties: i.properties
            },
            geometry: {
              type: "Point",
              coordinates: t[p]
            }
          }, o++)
        }
        return r
      }

      function P(e, r) {
        var n = e.properties.RouteMetaData,
          o = C(e.features);
        return {
          type: "FeatureCollection",
          features: o,
          properties: {
            index: r,
            type: n.type,
            distance: {
              value: n.WalkingDistance.value,
              text: n.WalkingDistance.text || W(n.WalkingDistance.value)
            },
            duration: {
              value: n.Duration.value,
              text: n.Duration.text || B(n.Duration.value)
            },
            boundedBy: e.properties.boundedBy ? t.map(e.properties.boundedBy, L) : v(o),
            rawProperties: e.properties
          }
        }
      }

      function C(e) {
        for (var r = [], n = 0, a = e.length; n < a; n++) {
          var i = e[n],
            s = i.properties,
            p = s.PathMetaData,
            u = t.map(o(s.encodedCoordinates), L),
            d = F(i.features, u);
          r[n] = {
            type: "FeatureCollection",
            features: d,
            properties: {
              index: n,
              type: "pedestrian",
              distance: p.WalkingDistance,
              duration: p.Duration,
              coordinates: u,
              encodedCoordinates: s.encodedCoordinates,
              rawProperties: s
            }
          }
        }
        return r
      }

      function F(e, t) {
        for (var r = [], n = 0, o = e.length; n < o; n++) r[n] = M(e[n], e[n + 1], t, n);
        return r
      }

      function M(e, t, r, n) {
        var o = e.properties.SegmentMetaData,
          a = {
            index: n,
            type: "pedestrian",
            text: o.text,
            distance: o.Distance,
            duration: o.Duration,
            links: o.Links,
            lodIndex: G(e).lodIndex,
            rawProperties: e.properties
          };
        return {
          type: "Feature",
          properties: a,
          geometry: {
            type: "LineString",
            coordinates: R(e, t, r, G)
          }
        }
      }

      function k(e) {
        var t = S(e);
        return {
          value: t,
          text: W(t)
        }
      }

      function S(e) {
        for (var t = 0, r = 0, n = e.length; r < n; r++) t += e[r].properties.distance.value;
        return t
      }

      function T(e) {
        var t = b(e);
        return {
          value: t,
          text: W(t)
        }
      }

      function b(e) {
        for (var t = 0, r = 0, n = e.length; r < n - 1; r++) t += s.solveInverseProblem(e[r], e[r + 1]).distance;
        return t
      }

      function W(e) {
        return a.distance(e).replace(/\&\#160\;/g, " ")
      }

      function B(e) {
        return a.duration(e).replace(/\&\#160\;/g, " ")
      }

      function L(e) {
        return E ? [e[1], e[0]] : e
      }

      function R(e, t, r, n) {
        return t ? r.slice(n(e).lodIndex, n(t).lodIndex + 1) : r.slice(n(e).lodIndex)
      }

      function J(e) {
        return e.geometry.geometries[0]
      }

      function G(e) {
        return e.features[0].geometry
      }
      e(function(e) {
        var t = [],
          r = u(e.features, t);
        return {
          type: "FeatureCollection",
          features: [{
            type: "FeatureCollection",
            features: p(e),
            properties: {
              name: "waypoints"
            }
          }, {
            type: "FeatureCollection",
            features: t,
            properties: {
              name: "viapoints"
            }
          }, {
            type: "FeatureCollection",
            features: r,
            properties: {
              name: "routes"
            }
          }],
          properties: {
            waypoints: e.properties.RouterMetaData.Waypoints,
            params: e.properties.params,
            rawProperties: e.properties
          }
        }
      });
      var j = {
          driving: d,
          masstransit: y,
          pedestrian: P
        },
        A = {
          walk: m,
          transport: I,
          transfer: h
        },
        E = "latlong" == ym.env.coordinatesOrder
    });
  }],
  ['!F', function(ym) {
    ym.modules.define("multiRouter.ViaPoint", ["util.defineClass", "multiRouter.base.Point"], function(t, i, o) {
      function s(t, i) {
        s.superclass.constructor.call(this, t, i), this.options.setName("viaPoint")
      }
      i(s, o), t(s)
    });
  }],
  ['!H', function(ym) {
    ym.modules.define("multiRouter.WayPoint", ["util.defineClass", "multiRouter.base.Point"], function(t, i, o) {
      function s(t, i) {
        s.superclass.constructor.call(this, t, i), this.options.setName("wayPoint")
      }
      i(s, o), t(s)
    });
  }],
  ['.k', function(ym) {
    ym.modules.define('not-found-tile', ['system.provideCss'], function(provide, provideCss) {
      provideCss(".ymaps-2-1-42-tile-not-found{text-align:center;display:block;font-family:Arial,serif;font-size:10px;white-space:nowrap;position:absolute;top:40%;width:90%;left:10%;overflow:hidden}", provide);
    });
  }],
  ['!M', function(ym) {
    ym.modules.define("ObjectManager", ["util.defineClass", "BaseObjectManager", "event.Manager", "objectManager.ObjectCollection", "objectManager.ClusterCollection", "objectManager.component.View", "component.child.MapChild", "objectManager.component.ObjectControllerAddon", "util.extend", "Event", "yandex.counter"], function(e, t, n, o, s, r, i, a, l, c, d, h) {
      var u = function(e) {
        this.events = new o({
          context: this
        }), this._mapChildComponent = new a({
          onMapChange: {
            callback: this._onMapChange,
            context: this
          },
          onParentChange: {
            callback: this._onParentChange,
            context: this
          }
        }), this._objectsEditingEventManager = new o, this._clustersEditingEventManager = new o, this.objects = new s(this, this._objectsEditingEventManager), this.clusters = new r(this, this._clustersEditingEventManager), u.superclass.constructor.call(this, e, {
          objects: this.objects,
          clusters: this.clusters,
          events: this.events,
          addDisplayedObjects: {
            callback: this._addObjects,
            context: this
          },
          removeDisplayedObjects: {
            callback: this._removeObjects,
            context: this
          },
          removeAll: {
            callback: this._removeAllObjects,
            context: this
          }
        }), this._objectControllerAddon = new l(this), this._view = null, h.countByKey("modulesUsage", "objectManager.create")
      };
      t(u, n, {
        getMap: function() {
          return this._mapChildComponent.getMap()
        },
        getParent: function() {
          return this._mapChildComponent.getParent()
        },
        setParent: function(e) {
          return this._mapChildComponent.setParent(e), this
        },
        add: function(e) {
          return this.objects.add(e), this
        },
        remove: function(e) {
          return this.objects.remove(e), this
        },
        removeAll: function() {
          return this.objects.removeAll(), this
        },
        onAddToMap: function(e) {
          this._setupView(), this._objectControllerAddon.setMap(e), this._objectControllerAddon.events.add("statechange", this._onObjectControllerStateChange, this).add("pixelboundschange", this._onObjectControllerBoundsChange, this), u.superclass.onAddToMap.call(this, e)
        },
        onRemoveFromMap: function(e) {
          u.superclass.onRemoveFromMap.call(this, e), this._objectControllerAddon.events.remove("statechange", this._onObjectControllerStateChange, this).remove("pixelboundschange", this._onObjectControllerBoundsChange, this), this._objectControllerAddon.setMap(null), this._clearView()
        },
        getObjectState: function(e) {
          var t = u.superclass.getObjectState.call(this, e),
            n = this._objectControllerAddon.getController(),
            o = n && n.getObjectState(e);
          return o && (t = c(t, o)), t
        },
        getBounds: function() {
          return this._objectControllerAddon.getController() ? this._objectControllerAddon.getController().getBounds() : null
        },
        getPixelBounds: function() {
          return this._objectControllerAddon.getController() ? this._objectControllerAddon.getController().getPixelBounds() : null
        },
        _setupView: function() {
          this._view = new i(this, this._objectsEditingEventManager, this._clustersEditingEventManager)
        },
        _clearView: function() {
          this._view.destroy()
        },
        _onMapChange: function(e, t) {
          e && this.onRemoveFromMap(e), t && this.onAddToMap(t), this.events.fire("mapchange", {
            oldMap: e,
            newMap: t
          })
        },
        _onParentChange: function(e, t) {
          t && this.options.setParent(t.options), t || this.options.setParent(null), this.events.fire("parentchange", {
            oldParent: e,
            newParent: t
          })
        },
        _addObjects: function(e) {
          this._objectControllerAddon.getController().add(e)
        },
        _removeObjects: function(e) {
          this._objectControllerAddon.getController().remove(e)
        },
        _removeAllObjects: function() {
          this._objectControllerAddon.getController().removeAll()
        },
        _onObjectControllerStateChange: function(e) {
          var t = e.get("removedClusters"),
            n = e.get("addedClusters");
          t && t.length && this._clustersEditingEventManager.fire("remove", new d({
            target: this,
            type: "remove",
            clusters: t
          })), n && n.length && this._clustersEditingEventManager.fire("add", new d({
            target: this,
            type: "add",
            clusters: n
          })), this._fireStateChange({
            added: e.get("added"),
            removed: e.get("removed"),
            addedClusters: e.get("addedClusters"),
            removedClusters: e.get("removedClusters"),
            update: e.get("update"),
            sync: e.get("sync")
          })
        },
        _onObjectControllerBoundsChange: function() {
          this.events.fire("pixelboundschange")
        },
        _fireStateChange: function(e) {
          this.events.fire("statechange", {
            added: e.added || [],
            removed: e.removed || [],
            addedClusters: e.addedClusters || [],
            removedClusters: e.removedClusters || [],
            update: e.update || [],
            sync: e.sync
          })
        }
      }), e(u)
    });
  }],
  [';m', function(ym) {
    ym.modules.define("objectManager.addon.clustersBalloon", ["objectManager.ClusterCollection", "popup.addonBuilder", "objectManager.Balloon"], function(e, a, n, o) {
      e(n.build({
        type: "balloon",
        metaEventManager: a.getMetaEventManager(),
        defaultManager: o
      }))
    });
  }],
  [';o', function(ym) {
    ym.modules.define("objectManager.addon.clustersHint", ["objectManager.ClusterCollection", "popup.addonBuilder", "objectManager.Hint"], function(e, a, n, t) {
      e(n.build({
        type: "hint",
        metaEventManager: a.getMetaEventManager(),
        defaultManager: t,
        popupManagerOption: "objectManagerHintManager"
      }))
    });
  }],
  [';n', function(ym) {
    ym.modules.define("objectManager.addon.objectsBalloon", ["objectManager.ObjectCollection", "popup.addonBuilder", "objectManager.Balloon"], function(e, a, n, o) {
      e(n.build({
        type: "balloon",
        metaEventManager: a.getMetaEventManager(),
        defaultManager: o
      }))
    });
  }],
  [';p', function(ym) {
    ym.modules.define("objectManager.addon.objectsHint", ["objectManager.ObjectCollection", "popup.addonBuilder", "objectManager.Hint"], function(e, a, n, t) {
      e(n.build({
        type: "hint",
        metaEventManager: a.getMetaEventManager(),
        defaultManager: t,
        popupManagerOption: "objectManagerHintManager"
      }))
    });
  }],
  ['6k', function(ym) {
    ym.modules.define("objectManager.Balloon", ["util.defineClass", "Balloon", "component.sharedEntity.captor.Balloon", "event.Manager", "map.addon.balloon", "option.Manager", "data.Manager", "util.component", "util.extend", "util.array", "projection.idle", "util.preset", "Monitor", "popup.managerStorage", "projection.idle", "objectManager.objectCollection.optionMapper", "objectManager.clusterCollection.optionMapper", "popup.component.checkEmptiness", "vow", "balloon.component.getBalloonMode", "objectManager.component.createGeometry", "geoObject.balloonPositioner.storage"], function(t, e, o, n, i, s, l, a, c, r, p, h, _, u, g, d, v, M, b, f, O, j, m) {
      function y(t) {
        this._collection = t, this.events = new i({
          context: this
        }), this._objectIdWithOpenBalloon = null, this._balloonCaptorListener = null, this._setupCaptor(), this._setupListeners(), this._setupOptionMonitor(), this._activeObjectId = null, this._checkMapListener(this._collection.getObjectManager().getMap())
      }

      function C(t, e) {
        var o = t.properties || {},
          n = e.properties || {},
          i = o.clusterCaption || o.balloonContentHeader || "",
          s = n.clusterCaption || n.balloonContentHeader || "";
        return i.toString() < s.toString() ? -1 : 1
      }
      var I = {
          autoPan: !1
        },
        B = {
          projection: d
        };
      e(y, c.createProxyMethods(function() {
        return this._captor
      }, ["getOverlay", "getOverlaySync", "autoPan", "getOwner", "setOptions", "getOptions"]), {
        destroy: function() {
          this._clearOptionMonitor(), this._clearListeners(), this._clearCaptor()
        },
        open: function(t, e) {
          this._activeObjectId = t;
          var o = this._collection.getById(t),
            n = f.defer();
          return this._captor.open(this._specifyPosition(t, e), this._specifyData(o), this._createPopupOptions(o)).always(function(e) {
            e.isRejected() ? (this._activeObjectId = null, n.reject(e.valueOf())) : (this._onOpen(t), n.resolve(!0))
          }, this), n.promise()
        },
        close: function(t) {
          var e = f.defer();
          return this._captor.close(t).always(function(t) {
            t.isRejected() ? e.reject(t.valueOf()) : (this._onClose(), e.resolve(!0))
          }, this), e.promise()
        },
        isOpen: function(t) {
          return this._objectIdWithOpenBalloon == t
        },
        isEmpty: function(t) {
          var e = this._collection.getById(t),
            o = this._specifyData(e),
            n = this._collection.getObjectManager().getMap();
          return o.options = this._createPopupOptions(e), b(n, "balloon", e.geometry.coordinates, o)
        },
        setData: function(t) {
          return this._captor.setData(this._specifyData(t))
        },
        getData: function() {
          var t = this._captor.getData();
          return t ? t.object : null
        },
        getPosition: function() {
          return this._collection.options.get("projection").fromGlobalPixels(this._captor.getPosition(), this._collection.getObjectManager().getMap().getZoom())
        },
        setPosition: function(t) {
          var e = this._captor,
            o = e.getData().object.id;
          return e.setPosition(this._specifyPosition(o, t))
        },
        _setupCaptor: function() {
          var t = this._collection.getObjectManager().getMap(),
            e = t && s.get(t);
          this._captor = new n(this, this._collection, "balloon", e), this._captor.events.add(["open", "close"], function(t) {
            t.stopImmediatePropagation()
          }).add(["release"], function() {
            this._onClose()
          }, this)
        },
        _clearCaptor: function() {
          this._captor.close(), this._captor.destroy(), this._captor = null
        },
        _setupListeners: function() {
          this._collection.getObjectManager().events.add("mapchange", this._onMapChange, this), this._collection.events.add("remove", this._onChildRemove, this), this._collection.overlays.events.add("remove", this._onOverlayRemove, this), this._collection.options.get("openBalloonOnClick", !0) && this._collection.events.add("click", this._onClick, this)
        },
        _clearListeners: function() {
          this._collection.getObjectManager().events.remove("mapchange", this._onMapChange, this), this._collection.events.remove("remove", this._onChildRemove, this), this._collection.overlays.events.remove("remove", this._onOverlayRemove, this), this._collection.options.get("openBalloonOnClick", !0) && this._collection.events.remove("click", this._onClick, this), this._checkMapListener(null)
        },
        _setupOptionMonitor: function() {
          this._optionMonitor = new u(this._collection.options).add("openBalloonOnClick", this._onOpenBallonOnClickChange, this, {
            defaultValue: !0
          })
        },
        _clearOptionMonitor: function() {
          this._optionMonitor.destroy()
        },
        _onClick: function(t) {
          if (!t.isDefaultPrevented()) {
            var e = t.get("objectId");
            e != this._objectIdWithOpenBalloon && this._getObjectOption(e, "openBalloonOnClick", !0) && (t.preventDefault(), this._getObjectOption(e, "openEmptyBalloon", !1) ? this.open(e, t.get("globalPixels")) : this.isEmpty(e).done(function(o) {
              !o && this._collection.getById(e) && this.open(e, t.get("globalPixels"))
            }, this))
          }
        },
        _onOpen: function(t) {
          this._objectIdWithOpenBalloon && this._onClose(), this._captor.isOpen() && this._activeObjectId == t && (this._activeObjectId = null, this._objectIdWithOpenBalloon = t, this._balloonCaptorListener = this._captor.getPopup().events.group().add("userclose", this._onUserClose, this), "Point" == this._collection.getById(t).geometry.type && this._getObjectOption(t, "hideIconOnBalloonOpen", !0) && (this._panelModeMonitor = new u(this._captor.getPopup().getOverlaySync().options).add(["panelMode"], function() {
            this._toggleIcon(t, this._panelModeMonitor.get("panelMode"))
          }, this), this._panelModeMonitor.get("panelMode") || this._toggleIcon(t, this._panelModeMonitor.get("panelMode"))), this.events.fire("open", {
            objectId: t
          }))
        },
        _onClose: function() {
          if (null != this._objectIdWithOpenBalloon) {
            var t = this._collection.getById(this._objectIdWithOpenBalloon);
            t && "Point" == t.geometry.type && this._showIcon(this._objectIdWithOpenBalloon), this.events.fire("close", {
              objectId: this._objectIdWithOpenBalloon
            }), this._objectIdWithOpenBalloon = null
          }
          this._panelModeMonitor && (this._panelModeMonitor.removeAll(), this._panelModeMonitor = null), this._balloonCaptorListener && this._balloonCaptorListener.removeAll()
        },
        _onMapChange: function() {
          var t = this._collection.getObjectManager().getMap();
          t ? this._setupSharingManager() : this.close(), this._checkMapListener(t)
        },
        _checkMapListener: function(t) {
          this._mapEventsListener && this._mapEventsListener.removeAll(), t ? (this._mapEventsListener = t.events.group().add("boundschange", this._onMapBoundsChange, this), this._oldMapZoom = t.getZoom()) : this._mapEventsListener = null
        },
        _onMapBoundsChange: function() {
          var t = this._oldMapZoom,
            e = this._collection.getObjectManager().getMap().getZoom();
          if (this._captor.isOpen() && t != e) {
            var o = this._captor.getPosition(),
              n = Math.pow(2, e - t);
            this._disableAutoPan(), this._captor.setPosition([o[0] * n, o[1] * n]), this._enableAutoPan()
          }
          this._oldMapZoom = e
        },
        _onOpenBallonOnClickChange: function() {
          this._optionMonitor.get("openBalloonOnClick") ? this._collection.events.add("click", this._onClick, this) : this._collection.events.remove("click", this._onClick, this)
        },
        _setupSharingManager: function() {
          this._captor.setSharingManager(s.get(this._collection.getObjectManager().getMap()))
        },
        _onUserClose: function() {
          this._onClose()
        },
        _specifyData: function(t) {
          var e, o = this._collection.getObjectManager().options.get("showInAlphabeticalOrder", !1);
          return "Cluster" == t.type && o && t.features ? (e = r({}, t, {
            features: t.features.slice().sort(C)
          }), e.properties = r({}, t.properties, {
            geoObjects: e.features
          })) : e = t, {
            collection: this._collection,
            properties: new a(e.properties),
            state: this._collection.state || new a,
            object: e
          }
        },
        _toggleIcon: function(t, e) {
          e ? this._showIcon(t) : this._hideIcon(t)
        },
        _hideIcon: function(t) {
          var e = this._collection.overlays.getById(t);
          e && e.setMap(null)
        },
        _showIcon: function(t) {
          var e = this._collection.overlays.getById(t);
          e && e.setMap(this._collection.getObjectManager().getMap())
        },
        _disableAutoPan: function() {
          _.addTo(this.getOptions(), I)
        },
        _enableAutoPan: function() {
          _.removeFrom(this.getOptions(), I)
        },
        _onChildRemove: function(t) {
          var e = t.get("objectId");
          this._objectIdWithOpenBalloon == e && this.close()
        },
        _onOverlayRemove: function(t) {
          var e = t.get("objectId");
          this._objectIdWithOpenBalloon == e && this.close()
        },
        _getObjectOption: function(t, e, o) {
          var n = this._collection.getById(t);
          if (!n) return null;
          var i = n.options ? n.options[e] : void 0;
          return "undefined" == typeof i ? this._collection.options.get(e, o) : i
        },
        _specifyPosition: function(t, e) {
          var o = this._collection.getById(t),
            n = this._collection.getObjectManager().getMap(),
            i = j(o, this._collection.options.get("projection"));
          i.setMap(n);
          var s = i.getPixelGeometry();
          return m.get(s.getType()).calculatePosition(s, e || n.getGlobalPixelCenter())
        },
        _createPopupOptions: function(t) {
          return new l({}, new l(t.options ? r({}, B, t.options) : B, this._collection.options, null, v), "balloon")
        }
      }), v.setRule({
        name: "balloon",
        rule: "prefixed"
      }).setRule({
        name: "balloon",
        key: ["projection"],
        rule: "plain"
      }), M.setRule({
        name: "balloon",
        rule: "prefixed"
      }).setRule({
        name: "balloon",
        key: ["projection"],
        rule: "plain"
      }), g.add("objectManager#balloon", y), t(y)
    });
  }],
  ['!P', function(ym) {
    ym.modules.define("objectManager.ClusterCollection", ["util.defineClass", "ReadOnlyCollection", "objectManager.OverlayCollection", "objectManager.clusterCollection.optionMapper", "objectManager.clusterCollection.overlayOptionMapper", "event.Manager", "event.Mapper", "Event", "objectManager.OverlayMappingTable", "option.Manager", "data.Manager", "util.bind", "event.globalize", "util.extend", "theme.islands.cluster.metaOptions"], function(e, t, s, n, i, r, o, a, l, d, v, h, c, g, u) {
      var y = function(e, t) {
          this._clusterEditingEventManager = new o, y.superclass.constructor.call(this, this._clusterEditingEventManager), this._objectManager = e, this.options.setMapper(i), this.options.setName("clusterCollection"), this.options.events.add("change", function() {
            this.events.fire("optionschange")
          }, this), this.events.addController(p), this.state = new h, this._clustersById = {}, this._overlayEditingEventManager = new o, this.overlays = new n(this._overlayEditingEventManager), this.overlays.options.setMapper(r), this.overlays.options.setParent(this.options), this.overlays.events.setParent(new a(this.events, new d(this))), this._editingEventManager = t, this._editingEventManager.add("add", this._onClustersAdd, this).add("remove", this._onClustersRemove, this).add("removeall", this._onClustersRemoveAll, this).add("addoverlay", this._onOverlayAdd, this).add("removeoverlay", this._onOverlayRemove, this).add("removealloverlays", this._onOverlayRemoveAll, this), this.events.fire("create")
        },
        p = g(y);
      t(y, s, {
        getById: function(e) {
          return this._clustersById[e] || null
        },
        getObjectManager: function() {
          return this._objectManager
        },
        setClusterOptions: function(e, t) {
          var s = this.getById(e);
          return s && (s.options = s.options ? u(s.options, t) : t, this.events.fire("clusteroptionschange", {
            objectId: e
          })), this
        },
        setClusterProperties: function(e, t) {
          var s = this.getById(e);
          s && (s.properties = s.properties ? u(s.properties, t) : t, this.events.fire("clusterpropertieschange", {
            objectId: e
          }))
        },
        onChildAdd: function(e) {
          var t = new l({
            type: "add",
            target: this,
            child: e,
            objectId: e.id
          });
          this.events.fire("add", t)
        },
        onChildRemove: function(e) {
          var t = new l({
            type: "remove",
            target: this,
            child: e,
            objectId: e.id
          });
          this.events.fire("remove", t)
        },
        _onClustersAdd: function(e) {
          for (var t = e.get("clusters"), s = 0, n = t.length; s < n; s++) this._clustersById[t[s].id] = t[s], this._clusterEditingEventManager.fire("add", new l({
            type: "add",
            target: this,
            object: t[s]
          }));
          this.events.fire("clustersadd", new l({
            clusters: t,
            target: this,
            type: "clustersadd"
          }))
        },
        _onClustersRemove: function(e) {
          for (var t = e.get("clusters"), s = this._getIdsArray(t), n = this._getAddedObjectsById(s), i = 0, r = n.length; i < r; i++) delete this._clustersById[n[i].id], this._clusterEditingEventManager.fire("remove", new l({
            target: this,
            type: "remove",
            object: n[i]
          }));
          this.events.fire("clustersremove", new l({
            clusters: n,
            target: this,
            type: "clustersremove"
          }))
        },
        _onClustersRemoveAll: function() {
          this._clustersById = {}, this._clusterEditingEventManager.fire("removeall")
        },
        _getAddedObjectsById: function(e) {
          for (var t = [], s = 0, n = e.length; s < n; s++) this._clustersById[e[s]] && t.push(this._clustersById[e[s]]);
          return t
        },
        _getIdsArray: function(e) {
          for (var t = [], s = 0, n = e.length; s < n; s++) t.push("undefined" != typeof e[s].id ? e[s].id : e[s]);
          return t
        },
        _onOverlayAdd: function(e) {
          this._overlayEditingEventManager.fire("add", new l({
            type: "add",
            target: this,
            overlay: e.get("overlay"),
            objectId: e.get("objectId")
          }))
        },
        _onOverlayRemove: function(e) {
          this._overlayEditingEventManager.fire("remove", new l({
            type: "remove",
            target: this,
            overlay: e.get("overlay"),
            objectId: e.get("objectId")
          }))
        },
        _onOverlayRemoveAll: function(e) {
          this._overlayEditingEventManager.fire("removeall")
        }
      }), e(y)
    });
  }],
  [';t', function(ym) {
    ym.modules.define("objectManager.clusterCollection.optionMapper", ["option.Mapper"], function(e, o) {
      e(new o)
    });
  }],
  [';u', function(ym) {
    ym.modules.define("objectManager.clusterCollection.overlayOptionMapper", ["option.Mapper"], function(e, l) {
      function r(e, l) {
        return l + e.slice(0, 1).toUpperCase() + e.slice(1)
      }
      var n = new l;
      n.setRule({
        name: "overlay.html.Placemark",
        rule: function(e, l) {
          return [r(e, "clusterIcon"), r(e, "cluster"), r(e, "icon")]
        }
      }), n.setRule({
        name: "overlay.Placemark",
        rule: function(e, l) {
          return [r(e, "clusterIcon"), r(e, "cluster"), r(e, "icon")]
        }
      }), n.setRule({
        name: "overlay.html.Placemark",
        key: "projection",
        rule: "plain"
      }), n.setRule({
        name: "overlay.Placemark",
        key: "projection",
        rule: "plain"
      }), e(n)
    });
  }],
  [';s', function(ym) {
    ym.modules.define("objectManager.CollectionMappingTable", ["util.defineClass", "Event"], function(t, n, e) {
      var i = function(t) {
        this._context = t, this["*"] = this._defaultMappingFunction, this.add = !1, this.remove = !1, this.parentchange = !1, this.optionschange = !1, this.mapchange = !1
      };
      n(i, {
        _defaultMappingFunction: function(t) {
          return new e({
            currentTarget: this._context
          }, t)
        }
      }), t(i)
    });
  }],
  [';y', function(ym) {
    ym.modules.define("objectManager.component.BaseDataLoadController", ["util.defineClass", "event.Manager", "component.TileBoundsGetter", "component.tileBoundsGetter.util", "objectManager.component.DataStorage", "objectManager.component.DataSource", "util.cancelableCallback", "util.bounds", "util.math.areEqual"], function(t, e, o, n, a, s, i, r, l, u) {
      function h(t, e) {
        for (var o, n = [], a = 0, s = t.length; a < s; a++) {
          o = t[a];
          for (var i = o[0][0]; i < o[1][0]; i++)
            for (var r = o[0][1]; r < o[1][1]; r++) n.push({
              tileNumber: [i, r],
              zoom: e
            })
        }
        return n
      }
      var d = function(t) {
        var e = t.getMap();
        this.events = new o({
          context: this
        }), this.context = t, this.storage = new s(this.context), this.dataSource = new i(this.context), this._tileBoundsGetter = new n(this.context.options, {
          wholeZoom: !0
        }), this._tileBoundsListener = this._tileBoundsGetter.events.group().add("tileboundschange", this._onTileBoundsChange, this), this._tileBoundsGetter.setMap(e), this._requestCallbacks = [], this.loadData(h(this._tileBoundsGetter.get(), Math.round(e.getZoom())))
      };
      e(d, {
        destroy: function() {
          this._tileBoundsGetter.setMap(null), this._tileBoundsListener.removeAll(), this.storage.removeAll(), this.abortLoading()
        },
        onMapZoomChange: function(t) {},
        onMapMove: function(t) {
          var e = a.getDisjointArea(t.get("newTileBounds"), t.get("oldTileBounds"), !0);
          this.loadData(this.getNotLoadedTiles(h(e.added, Math.round(this.context.getMap().getZoom()))))
        },
        loadData: function(t) {
          var e = r.create(function(t) {
            this.onDataLoad(t.tilesArray, t.data)
          }, this);
          this._requestCallbacks.push(e), this.dataSource.load(t).then(e)
        },
        abortLoading: function() {
          for (var t = this._requestCallbacks, e = 0, o = t.length; e < o; e++) t[e].cancel();
          t = []
        },
        reloadData: function() {
          var t = this.storage.getAll();
          this.storage.removeAll(), this.events.fire("statechange", {
            added: [],
            removed: t
          }), this.loadData(h(this._tileBoundsGetter.get(), Math.round(this.context.getMap().getZoom())))
        },
        getNotLoadedTiles: function(t) {},
        onDataLoad: function(t, e) {
          this._checkBounds()
        },
        getBounds: function() {
          var t = this.getPixelBounds(),
            e = this.context.getMap();
          return t && e ? l.fromGlobalPixelBounds(t, e.getZoom(), e.options.get("projection")) : null
        },
        getPixelBounds: function() {
          var t = this.storage.getBounds();
          if (t && this.context.getMap()) {
            var e = Math.pow(2, this.context.getMap().getZoom() - 23);
            return [
              [t[0][0] * e, t[0][1] * e],
              [t[1][0] * e, t[1][1] * e]
            ]
          }
          return null
        },
        _getTileDataFromStorage: function(t, e) {
          return this.storage.getTileData(t, e)
        },
        _onTileBoundsChange: function(t) {
          Math.round(t.get("oldZoom")) != Math.round(t.get("newZoom")) ? this.onMapZoomChange(t) : this.onMapMove(t)
        },
        _checkBounds: function() {
          var t = this.getPixelBounds();
          !!this._oldBounds == !!t && t && u(t[0], this._oldBounds[0]) && u(t[1], this._oldBounds[1]) || (this.events.fire("pixelboundschange"), this._oldBounds = t)
        }
      }), t(d)
    });
  }],
  ['!U', function(ym) {
    ym.modules.define("objectManager.component.ClusterListener", ["util.defineClass", "util.bounds", "Monitor"], function(t, o, e, i) {
      var s = function(t) {
        this._context = t, this._map = null, this._optionMonitor = null
      };
      o(s, {
        setMap: function(t) {
          this._map != t && (this._map && this._removeFromMap(), this._map = t, this._map && this._addToMap())
        },
        _addToMap: function() {
          this._context.options.get("clusterDisableClickZoom", !1) || this._startClusterClickListening(), this._optionMonitor = new i(this._context.options).add("clusterDisableClickZoom", this._onDisableClickZoomChange, this)
        },
        _removeFromMap: function() {
          this._optionMonitor.destroy(), this._context.options.get("clusterDisableClickZoom", !1) || this._stopClusterClickListening()
        },
        _onDisableClickZoomChange: function() {
          this._context.options.get("clusterDisableClickZoom", !1) ? this._stopClusterClickListening() : this._startClusterClickListening()
        },
        _startClusterClickListening: function() {
          this._context.clusters.overlays.events.add("click", this._onClusterOverlayClick, this)
        },
        _stopClusterClickListening: function() {
          this._context.clusters.overlays.events.remove("click", this._onClusterOverlayClick, this)
        },
        _onClusterOverlayClick: function(t) {
          if (!t.isDefaultPrevented()) {
            var o = this._map;
            Math.round(o.getZoom()) != o.zoomRange.getCurrent()[1] && (this._setMapBounds(t.get("objectId")), t.preventDefault())
          }
        },
        _setMapBounds: function(t) {
          var o = this._calculateClusterBounds(t);
          if (o) {
            var e = this._map;
            e.setBounds(o, {
              preciseZoom: !e.options.get("avoidFractionalZoom"),
              margin: this._context.options.get("zoomMargin", 0),
              useMapMargin: this._context.options.get("useMapMargin", !0),
              checkZoomRange: !0
            })
          }
        },
        _calculateClusterBounds: function(t) {
          var o = this._context.clusters.getById(t),
            i = null;
          if (o.bbox) i = o.bbox;
          else if (o.features) {
            for (var s = o.features, n = [], l = 0, r = s.length; l < r; l++) n.push(s[l].geometry.coordinates);
            i = 0 == n.length ? null : e.fromPoints(n, this._context.options.get("projection"))
          }
          return i
        }
      }), t(s)
    });
  }],
  ['!V', function(ym) {
    ym.modules.define("objectManager.component.createGeometry", ["geometry.Point", "geometry.LineString", "geometry.Circle", "geometry.Polygon", "geometry.Rectangle", "util.extend"], function(e, n, t, o, r, i, a) {
      var c = {
        POINT: "Point",
        CIRCLE: "Circle",
        RECTANGLE: "Rectangle",
        LINE_STRING: "LineString",
        POLYGON: "Polygon"
      };
      e(function(e, a) {
        var g, l = {
            projection: a,
            pixelRendering: "static"
          },
          s = e.geometry,
          y = s.type,
          m = s.coordinates,
          L = s.options || l;
        switch (y) {
          case c.POINT:
            g = new n(m, L);
            break;
          case c.CIRCLE:
            g = new o(m, s.radius, L);
            break;
          case c.LINE_STRING:
            g = new t(m, L);
            break;
          case c.POLYGON:
            g = new r(m, s.fillRule || "nonZero", L);
            break;
          case c.RECTANGLE:
            g = new i(m, L)
        }
        return g
      })
    });
  }],
  ['!X', function(ym) {
    ym.modules.define("objectManager.component.customPaddingJsonp", ["util.jsonp", "vow"], function(e, r, o) {
      function n(e) {
        var n = e.padding,
          a = o.defer();
        if (n) {
          var t = window[n];
          window[n] = function(e) {
            window[n] = t, !e || e.error ? a.reject(e ? e.error : "no data") : a.resolve(e.data || e)
          }
        }
        return r({
          paramName: e.paramName || "callback",
          padding: e.padding,
          url: e.url,
          timeout: e.timeout,
          noCache: e.noCache,
          requestParams: e.requestParams
        }).done(function(e) {
          e.error ? a.reject(e.error) : a.resolve(e.data || e)
        }, function(e) {
          n && (window[n] = t), a.reject(e)
        }), a.promise()
      }
      e(n)
    });
  }],
  ['!Y', function(ym) {
    ym.modules.define("objectManager.component.DataSource", ["util.defineClass", "vow", "util.processUrlTemplate", "util.bounds", "util.array", "objectManager.component.customPaddingJsonp", "objectManager.util"], function(e, t, o, r, n, i, u, a) {
      function s(e) {
        var t, o, r = e.slice(1),
          n = [e[0].slice(), e[0].slice()];
        do t = l(n, r, "left"); while (t);
        do t = l(n, r, "right"); while (t);
        do t = l(n, r, "top"); while (t);
        do t = l(n, r, "bottom"); while (t);
        return o = [n], r.length && (o = o.concat(s(r))), o
      }

      function l(e, t, o) {
        var r = [];
        if ("left" == o) {
          if (0 == e[0][0]) return !1;
          for (var n, u = e[0][1], a = e[1][1] + 1; u < a; u++) {
            if (n = f([e[0][0] - 1, u], t), n == -1) return !1;
            r.push(t[n])
          }
          e[0][0] -= 1
        }
        if ("right" == o) {
          for (var n, u = e[0][1], a = e[1][1] + 1; u < a; u++) {
            if (n = f([e[1][0] + 1, u], t), n == -1) return !1;
            r.push(t[n])
          }
          e[1][0] += 1
        }
        if ("top" == o) {
          if (0 == e[1][0]) return !1;
          for (var n, s = e[0][0], a = e[1][0] + 1; s < a; s++) {
            if (n = f([s, e[0][1] - 1], t), n == -1) return !1;
            r.push(t[n])
          }
          e[0][1] -= 1
        }
        if ("bottom" == o) {
          for (var n, s = e[0][0], a = e[1][0] + 1; s < a; s++) {
            if (n = f([s, e[1][1] + 1], t), n == -1) return !1;
            r.push(t[n])
          }
          e[1][1] += 1
        }
        for (var n, l = 0, a = r.length; l < a; l++) n = i.indexOf(t, r[l]), t.splice(n, 1);
        return !0
      }

      function f(e, t) {
        for (var o = 0, r = t.length; o < r; o++)
          if (t[o][0] == e[0] && t[o][1] == e[1]) return o;
        return -1
      }
      var h = function(e) {
        this._context = e
      };
      t(h, {
        load: function(e) {
          for (var t = this._getRequests(e), r = [], n = o.defer(), i = {
              tilesArray: [],
              data: []
            }, u = 0, s = t.length; u < s; u++) r.push(this._makeLayersInfoRequest(t[u]));
          return o.allResolved(r).then(function() {
            for (var e = 0, o = r.length; e < o; e++) r[e].isFulfilled() && (i.data.push(r[e].valueOf()), i.tilesArray = i.tilesArray.concat(a.getTilesArrayFromTileBoundsArray([t[e].tileBounds], t[e].zoom, !0)));
            n.resolve(i)
          }), n.promise()
        },
        _getRequests: function(e) {
          var t = [];
          if (this._context.options.get("splitRequests", !1))
            for (var o, r, n = 0, i = e.length; n < i; n++) o = e[n].tileNumber, r = e[n].zoom, t.push({
              zoom: e[n].zoom,
              tileNumber: e[n].tileNumber,
              boundingBox: this._getBoundingBox([o, o], r),
              tileBounds: [o, o]
            });
          else {
            for (var u = {}, a = [], n = 0, i = e.length; n < i; n++) u[e[n].zoom] || (u[e[n].zoom] = []), u[e[n].zoom].push(e[n].tileNumber);
            for (var r in u) u.hasOwnProperty(r) && a.push({
              zoom: Number(r),
              tileBoundsArray: s(u[r])
            });
            for (var l, n = 0, i = a.length; n < i; n++) {
              l = a[n];
              for (var f, h = 0, d = l.tileBoundsArray.length; h < d; h++) f = l.tileBoundsArray[h], t.push({
                zoom: l.zoom,
                boundingBox: this._getBoundingBox(f, l.zoom),
                tileBounds: f
              })
            }
          }
          return t
        },
        _makeLayersInfoRequest: function(e) {
          var t = this._context,
            o = t.getTileUrl(e),
            r = t.getPadding(e);
          return u({
            url: o,
            padding: r,
            paramName: t.options.get("paddingParamName"),
            noCache: t.options.get("noCache"),
            timeout: t.options.get("timeout")
          })
        },
        _getBoundingBox: function(e, t) {
          var o = [
            [256 * e[0][0], 256 * e[0][1]],
            [256 * (e[1][0] + 1) - 1e-10, 256 * (e[1][1] + 1) - 1e-10]
          ];
          return n.fromGlobalPixelBounds(o, t, this._context.options.get("projection"))
        }
      }), e(h)
    });
  }],
  ['!0', function(ym) {
    ym.modules.define("objectManager.component.DataStorage", ["util.defineClass", "util.PrTree", "objectManager.component.getObjectBBox"], function(t, e, i, n) {
      function r(t, e) {
        var i = [
            [256 * t[0], 256 * t[1]],
            [256 * (t[0] + 1), 256 * (t[1] + 1)]
          ],
          n = 23 - e,
          r = Math.pow(2, n);
        return [
          [i[0][0] * r, i[0][1] * r],
          [i[1][0] * r - 1, i[1][1] * r - 1]
        ]
      }
      var s = function(t) {
        this._context = t, this._tree = new i, this._items = {}
      };
      e(s, {
        add: function(t) {
          for (var e, i = [], r = 0, s = t.length; r < s; r++) e = t[r].id, this._items[e] || (this._items[e] = {
            value: t[r],
            bbox: n(t[r], this._context.getMap())
          }, i.push(this._items[e]));
          i.length && this._tree.insert(i)
        },
        remove: function(t) {
          for (var e = 0, i = t.length; e < i; e++) {
            var n = this._items[t[e].id];
            n && (this._tree.remove(n), delete this._items[t[e].id])
          }
        },
        removeAll: function() {
          this._tree.removeAll(), this._items = {}
        },
        getAll: function() {
          var t = [];
          for (var e in this._items) t.push(this._items[e].value);
          return t
        },
        getTileData: function(t, e) {
          for (var i = r(t, e), n = this._tree.search(i), s = [], o = 0, h = n.length; o < h; o++) s.push(n[o].value);
          return s
        },
        getBounds: function() {
          return this._tree.getLength() ? this._tree.getBounds() : null
        },
        getLength: function() {
          return this._tree.getLength()
        }
      }), t(s)
    });
  }],
  ['!2', function(ym) {
    ym.modules.define("objectManager.component.Filter", ["util.id", "util.defineClass"], function(provide, utilId, defineClass) {
      function Filter(e) {
        if (this._objects = {}, "string" == typeof e) {
          var t = addObjectToFilterString(e),
            r = createFilterFunctionTemplate(t);
          this._filterFunction = evaluateExpression(r)
        } else this._filterFunction = e
      }

      function evaluateExpression(expression) {
        var result;
        return eval("result = " + expression), result
      }

      function createFilterFunctionTemplate(e) {
        return "function (object) { return " + e + "; }"
      }

      function addObjectToFilterString(e) {
        for (var t, r = "", i = 0; t = textInQuotesRegExp.exec(e);) r += processReservedWords(e.slice(i, t.index)), r += t[0], i = textInQuotesRegExp.lastIndex;
        return i < e.length && (r += processReservedWords(e.slice(i))), r
      }

      function processReservedWords(e) {
        for (var t, r = e; t = optionsSearchRegExp.exec(e);) r = r.replace(t[0], t[1] + "object." + t[2] + t[3]);
        return r
      }
      var optionsSearchRegExp = /(^|[^\w])(options|properties|geometry|id)($|[^\w])/g,
        textInQuotesRegExp = /["'](.*?)["']+/g;
      defineClass(Filter, {
        add: function(e) {
          for (var t = 0, r = e.length; t < r; t++) this._objects[utilId.get(e[t])] = {
            filterResult: this._applyFilter(e[t]),
            object: e[t]
          }
        },
        remove: function(e) {
          for (var t = 0, r = e.length; t < r; t++) delete this._objects[utilId.get(e[t])]
        },
        destroy: function() {
          this._objects = null
        },
        isFilteredOut: function(e) {
          var t = utilId.get(e);
          return !this._objects[t] || !this._objects[t].filterResult
        },
        getValidObjects: function() {
          var e = [];
          for (var t in this._objects) this._objects.hasOwnProperty(t) && this._objects[t].filterResult && e.push(this._objects[t].object);
          return e
        },
        getFilteredObjects: function() {
          var e = [];
          for (var t in this._objects) this._objects.hasOwnProperty(t) && !this._objects[t].filterResult && e.push(this._objects[t].object);
          return e
        },
        _applyFilter: function(e) {
          return this._filterFunction(e)
        }
      }), provide(Filter)
    });
  }],
  ['!3', function(ym) {
    ym.modules.define("objectManager.component.getObjectBBox", ["geometry.Circle", "util.bounds", "util.pixelBounds", "util.array"], function(e, o, t, n, a) {
      function r(e, o) {
        var t = [];
        return a.each(e, function(e) {
          t.push(o.toGlobalPixels(e, i))
        }), t
      }
      var i = 23,
        c = {
          POINT: "Point",
          CIRCLE: "Circle",
          RECTANGLE: "Rectangle",
          LINE_STRING: "LineString",
          POLYGON: "Polygon"
        };
      e(function(e, a) {
        var s, l = a.options.get("projection"),
          u = e.geometry,
          p = u.type,
          N = u.coordinates;
        switch (p) {
          case c.POINT:
            var P = r([N], l)[0];
            s = [P, P];
            break;
          case c.CIRCLE:
            var g = new o(N, u.radius);
            g.setMap(a), s = t.toGlobalPixelBounds(g.getBounds(), i, l), g.setMap(null);
            break;
          case c.RECTANGLE:
          case c.LINE_STRING:
            N = r(N, l), s = n.fromPoints(N);
            break;
          case c.POLYGON:
            N = [].concat.apply([], N), N = r(N, l), s = n.fromPoints(N)
        }
        return s
      })
    });
  }],
  ['!6', function(ym) {
    ym.modules.define("objectManager.component.ObjectController", ["util.defineClass", "event.Manager", "component.TileBoundsGetter", "Monitor", "util.array", "util.extend", "component.tileBoundsGetter.util", "util.PrTree", "objectManager.component.getObjectBBox", "util.bounds", "util.math.areEqual"], function(e, t, s, r, i, n, o, h, d, p, a, u) {
      function c(e, t) {
        var s = [
            [256 * e[0][0], 256 * e[0][1]],
            [256 * e[1][0], 256 * e[1][1]]
          ],
          r = 23 - t,
          i = Math.pow(2, r);
        return [
          [s[0][0] * i, s[0][1] * i],
          [s[1][0] * i - 1, s[1][1] * i - 1]
        ]
      }

      function _(e, t) {
        return "Point" == e.geometry.type || !!t.zoomChanged
      }
      var l = function(e) {
        this.options = e, this._map = null, this.events = new s({
          context: this
        }), this._tileBoundsGetter = new r(e), this._optionMonitor = null, this._unprocessedObjects = [], this._objectWrappers = [], this._wrappersById = {}, this._prTree = null
      };
      t(l, {
        setMap: function(e) {
          this._map = e, e ? (this._prTree = new d, this._tileBoundsGetter.setMap(e), this._addToMap(e)) : (this._removeFromMap(e), this._tileBoundsGetter.setMap(null))
        },
        getMap: function() {
          return this._map
        },
        add: function(e) {
          return this._map ? (this._addObjectsToTree(e), this._showObjects(this._tileBoundsGetter.get()), this._checkBounds()) : this._unprocessedObjects = this._unprocessedObjects.concat(e), this
        },
        remove: function(e) {
          return this._map && (this._hideShownObjects(e), this._removeObjectsFromTree(e), this._checkBounds()), this._removeUnprocessedObjects(e), this
        },
        removeAll: function() {
          this._fireRemoveAll(), this._prTree && (this._prTree.removeAll(), this._checkBounds()), this._objectWrappers = [], this._unprocessedObjects = [], this._wrappersById = {}
        },
        destroy: function() {
          this._map && (this.removeAll(), this._removeFromMap()), this.events.fire("destroy")
        },
        getObjectState: function(e) {
          return e in this._wrappersById ? {
            isShown: !!this._wrappersById[e].isShown,
            isClustered: !1,
            cluster: null
          } : null
        },
        getObject: function(e) {
          return e in this._wrappersById ? o({}, this._wrappersById[e].hash) : null
        },
        getAll: function() {
          for (var e = [], t = 0, s = this._objectWrappers.length; t < s; t++) e.push(this._objectWrappers[t].hash);
          return e.concat(this._unprocessedObjects)
        },
        getBounds: function() {
          var e = this._prTree;
          return e && e.getLength() ? a.fromGlobalPixelBounds(e.getBounds(), 23, this._map.options.get("projection")) : null
        },
        getPixelBounds: function() {
          var e = this._prTree;
          if (e && e.getLength()) {
            var t = Math.pow(2, this._map.getZoom() - 23),
              s = e.getBounds();
            return [
              [s[0][0] * t, s[0][1] * t],
              [s[1][0] * t, s[1][1] * t]
            ]
          }
          return null
        },
        _addToMap: function(e) {
          this._setupOptionMonitor(), this._unprocessedObjects.length && (this._addObjectsToTree(this._unprocessedObjects), this._unprocessedObjects = []), this._tileBoundsListener = this._tileBoundsGetter.events.group().add("tileboundschange", this._onTileBoundsChange, this), this._objectWrappers.length && this._showObjects(this._tileBoundsGetter.get())
        },
        _removeFromMap: function(e) {
          this._clearOptionMonitor(), this._fireRemoveAll(), this._tileBoundsListener.removeAll()
        },
        _setupOptionMonitor: function() {
          this._optionMonitor = new i(this.options).add("viewportMargin", this._refresh, this)
        },
        _clearOptionMonitor: function() {
          this._optionMonitor.destroy()
        },
        _showObjects: function(e, t) {
          for (var s = [], r = 0, i = e.length; r < i; r++)
            for (var n = this._getObjectsInBounds(e[r], t), o = 0, h = n.length; o < h; o++) this._wrappersById[n[o].id].isShown || (this._wrappersById[n[o].id].isShown = !0, s.push(n[o]));
          this._fireStateChange({
            added: s
          })
        },
        _getObjectsInBounds: function(e, t) {
          var s = c(e, this._map.getZoom()),
            r = this._prTree.search(s),
            i = [];
          if ("undefined" == typeof t)
            for (var n = 0, o = r.length; n < o; n++) i.push(r[n].hash);
          else {
            for (var h = {}, n = 0, o = t.length; n < o; n++) h[t[n].hash.id] = !0;
            for (var n = 0, o = r.length; n < o; n++) h[r[n].hash.id] && i.push(r[n].hash)
          }
          return i
        },
        _fireStateChange: function(e) {
          var t = [],
            s = [],
            r = [],
            i = [];
          if (e.removed)
            for (var n = 0, o = e.removed.length; n < o; n++) "Feature" == e.removed[n].type ? t.push(e.removed[n]) : "Cluster" == e.removed[n].type && i.push(e.removed[n]);
          if (e.added)
            for (var n = 0, o = e.added.length; n < o; n++) "Feature" == e.added[n].type ? s.push(e.added[n]) : "Cluster" == e.added[n].type && r.push(e.added[n]);
          (s.length || t.length || r.length || i.length || e.update && e.update.length) && this.events.fire("statechange", {
            added: s,
            removed: t,
            addedClusters: r,
            removedClusters: i,
            update: e.update || [],
            sync: e.sync
          })
        },
        _fireRemoveAll: function() {
          for (var e = [], t = 0, s = this._objectWrappers.length; t < s; t++) e.push(this._objectWrappers[t].hash), this._objectWrappers[t].isShown = !1;
          e.length && this._fireStateChange({
            removed: e,
            sync: !0
          })
        },
        _hideShownObjects: function(e) {
          for (var t = [], s = 0, r = e.length; s < r; s++) this._wrappersById[e[s].id] && this._wrappersById[e[s].id].isShown && t.push(e[s]);
          this._fireStateChange({
            removed: t
          })
        },
        _removeUnprocessedObjects: function(e) {
          for (var t, s = [], r = 0, i = this._unprocessedObjects.length; r < i; r++) {
            t = !0;
            for (var n = 0, o = e.length; n < o && !t; n++) e[n].id == this._unprocessedObjects[r].id && (t = !1);
            t && s.push(this._unprocessedObjects[r])
          }
          this._unprocessedObjects = s
        },
        _onTileBoundsChange: function(e) {
          this._refresh({
            zoomChanged: e.get("oldzoom") != e.get("newZoom")
          })
        },
        _refresh: function(e) {
          for (var t = [], s = 0, r = this._objectWrappers.length; s < r; s++) this._objectWrappers[s].isShown && t.push(this._objectWrappers[s].hash);
          var i = this._getObjectsInTileBoundsArray(this._tileBoundsGetter.get());
          this._updateVisibleObjects(t, i, e)
        },
        _updateVisibleObjects: function(e, t, s) {
          e.sort(f), t.sort(f);
          for (var r = [], i = [], n = [], o = 0, h = 0, d = e.length, p = t.length; o < d && h < p;) e[o].id < t[h].id ? (_(e[o], s) ? i.push(e[o]) : n.push(e[o]), o++) : e[o].id > t[h].id ? (r.push(t[h]), h++) : (n.push(e[o]), o++, h++);
          for (o != d && (i = i.concat(e.slice(o))), h != p && (r = r.concat(t.slice(h))), o = 0, d = r.length; o < d; o++) this._wrappersById[r[o].id].isShown = !0;
          for (o = 0, d = i.length; o < d; o++) this._wrappersById[i[o].id].isShown = !1;
          this._fireStateChange({
            update: n,
            added: r,
            removed: i
          })
        },
        _getObjectsInTileBoundsArray: function(e, t) {
          for (var s, r = [], i = {}, n = 0, o = e.length; n < o; n++) {
            s = this._getObjectsInBounds(e[n], t);
            for (var h = 0, d = s.length; h < d; h++) i[s[h].id] || (i[s[h].id] = !0, r.push(s[h]))
          }
          return r
        },
        _addObjectsToTree: function(e) {
          for (var t = [], s = 0, r = e.length; s < r; s++)
            if (!this._wrappersById[e[s].id]) {
              var i = {
                hash: e[s],
                bbox: p(e[s], this._map)
              };
              this._wrappersById[e[s].id] = i, this._objectWrappers.push(i), t.push(i)
            }
          this._prTree.insert(t)
        },
        _removeObjectsFromTree: function(e) {
          for (var t = [], s = {}, r = 0, i = e.length; r < i; r++) this._wrappersById[e[r].id] && (s[e[r].id] = !0, t.push(this._wrappersById[e[r].id]));
          for (var n, o = [], h = {}, r = 0, i = this._objectWrappers.length; r < i; r++) n = this._objectWrappers[r].hash.id, s[n] || (o.push(this._objectWrappers[r]), h[n] = this._objectWrappers[r]);
          if (this._wrappersById = h, this._prTree.getLength() / 10 < t.length) this._prTree.removeAll(), this._prTree.insert(o);
          else
            for (var r = 0, i = t.length; r < i; r++) this._prTree.remove(t[r]);
          this._objectWrappers = o
        },
        _checkBounds: function() {
          var e = this._prTree.getBounds();
          !!this._oldBounds == !!e && e && u(e[0], this._oldBounds[0]) && u(e[1], this._oldBounds[1]) || (this.events.fire("pixelboundschange"), this._oldBounds = e)
        }
      });
      var f = function(e, t) {
        return e.id > t.id ? 1 : e.id == t.id ? 0 : -1
      };
      e(l)
    });
  }],
  ['!4', function(ym) {
    ym.modules.define("objectManager.component.ObjectControllerAddon", ["util.defineClass", "Monitor", "clusterer.component.GridClusterer", "objectManager.component.ObjectController", "option.Manager", "event.Manager"], function(e, t, o, n, r, s, i) {
      var l = function(e, t) {
        this._context = e, this._map = null, this._objectController = null, this._objectControllerListener = null, this._parameters = t || {}, this.events = new i({
          context: this
        })
      };
      t(l, {
        setMap: function(e) {
          this._map = e, e ? this._addToMap(e) : this._removeFromMap(e)
        },
        getController: function() {
          return this._objectController
        },
        _addToMap: function(e) {
          this._setupObjectController(), this._parameters.clusteringDisabled || (this._optionMonitor = new o(this._context.options).add(["clusterize"], this._onClusterizeChange, this))
        },
        _removeFromMap: function(e) {
          this._optionMonitor && this._optionMonitor.destroy(), this._clearObjectController()
        },
        _setupObjectController: function() {
          !this._parameters.clusteringDisabled && this._context.options.get("clusterize", !1) ? this._objectController = new n(new s((void 0), this._context.options, "clusterer")) : this._objectController = new r(this._context.options), this._objectControllerListener = this._objectController.events.group().add("statechange", function(e) {
            this._fireStateChange({
              added: e.get("added"),
              removed: e.get("removed"),
              addedClusters: e.get("addedClusters"),
              removedClusters: e.get("removedClusters"),
              update: e.get("update"),
              sync: e.get("sync")
            })
          }, this).add("pixelboundschange", function() {
            this.events.fire("pixelboundschange")
          }, this), this._objectController.setMap(this._context.getMap())
        },
        _clearObjectController: function() {
          this._objectController && (this._objectController.destroy(), this._objectControllerListener.removeAll())
        },
        _onClusterizeChange: function() {
          var e = [];
          this._objectController && (e = this._objectController.getAll()), this._clearObjectController(), this._setupObjectController(), this._objectController && this._objectController.add(e)
        },
        _fireStateChange: function(e) {
          this.events.fire("statechange", {
            added: e.added || [],
            removed: e.removed || [],
            addedClusters: e.addedClusters || [],
            removedClusters: e.removedClusters || [],
            update: e.update || [],
            sync: e.sync
          })
        }
      }), e(l)
    });
  }],
  [';A', function(ym) {
    ym.modules.define("objectManager.component.OnceLoadingDataController", ["util.defineClass", "objectManager.component.BaseDataLoadController", "objectManager.component.TileLoadTree", "objectManager.parseData", "objectManager.util"], function(e, t, a, o, n, r) {
      var i = function(e) {
        i.superclass.constructor.call(this, e), this._tileLoadTree = new o(e)
      };
      t(i, a, {
        onMapZoomChange: function(e) {
          var t = e.get("newTileBounds"),
            a = this.getNotLoadedTiles(r.getTilesArrayFromTileBoundsArray(t, Math.round(this.context.getMap().getZoom())));
          a.length && this.loadData(a)
        },
        getNotLoadedTiles: function(e) {
          for (var t, a, o = [], n = 0, r = e.length; n < r; n++) t = e[n].tileNumber, a = e[n].zoom, this._tileLoadTree.isTileLoaded(t, a) || (o = o.concat(this._tileLoadTree.getMissingTiles(t, a)));
          return o
        },
        onDataLoad: function(e, t) {
          for (var a = 0, o = e.length; a < o; a++) this._tileLoadTree.addLoadedTile(e[a].tileNumber, e[a].zoom);
          for (var r = [], a = 0, o = t.length; a < o; a++) r = r.concat(n(t[a]));
          this.storage.add(r), this._showData(e), i.superclass.onDataLoad.call(this, e, t)
        },
        reloadData: function() {
          this._tileLoadTree.clear(), i.superclass.reloadData.call(this)
        },
        _showData: function(e) {
          for (var t = 0, a = e.length; t < a; t++) this.events.fire("statechange", {
            added: this._getTileDataFromStorage(e[t].tileNumber, e[t].zoom),
            removed: []
          })
        },
        _getTileDataFromStorage: function(e, t) {
          return this.storage.getTileData(e, t)
        }
      }), e(i)
    });
  }],
  [';B', function(ym) {
    ym.modules.define("objectManager.component.ReloadOnZoomChangeController", ["util.defineClass", "objectManager.component.BaseDataLoadController", "objectManager.parseData", "objectManager.util", "util.cancelableCallback"], function(e, t, o, a, s, i) {
      var d = function(e) {
        d.superclass.constructor.call(this, e), this._loadedTiles = {}, this._oldZoomObjects = []
      };
      t(d, o, {
        onMapZoomChange: function(e) {
          this._loadedTiles = {}, this.abortLoading(), this._expiredObjects = this.storage.getAll(), this.loadData(s.getTilesArrayFromTileBoundsArray(e.get("newTileBounds"), Math.round(this.context.getMap().getZoom())))
        },
        getNotLoadedTiles: function(e) {
          for (var t, o = [], a = 0, s = e.length; a < s; a++) t = e[a].tileNumber, this._loadedTiles[t[0]] && this._loadedTiles[t[0]][t[1]] || o.push(e[a]);
          return o
        },
        onDataLoad: function(e, t) {
          for (var o = [], s = [], i = [], l = [], r = {}, n = 0, h = t.length; n < h; n++) {
            for (var c = a(t[n]), u = [], g = 0, f = c.length; g < f; g++) r[c[g].id] || (r[c[g].id] = !0, u.push(c[g]));
            o = o.concat(u)
          }
          if (this._expiredObjects) {
            var m = this._getObjectsDiff(o, this._expiredObjects);
            s = m.removed, i = m.added, l = m.update, this._expiredObjects = null
          } else i = o;
          this._markTiles(e), this.storage.remove(s), this.storage.add(i), this.events.fire("statechange", {
            added: i,
            removed: s
          }), d.superclass.onDataLoad.call(this, e, t)
        },
        destroy: function() {
          d.superclass.destroy.call(this), this._expiredObjects = []
        },
        _markTiles: function(e) {
          for (var t, o, a = 0, s = e.length; a < s; a++) t = e[a].tileNumber[0], o = e[a].tileNumber[1], this._loadedTiles[t] || (this._loadedTiles[t] = {}), this._loadedTiles[t][o] = {
            loaded: !0
          }
        },
        _getObjectsDiff: function(e, t) {
          var o, a, s = {
              added: [],
              removed: []
            },
            i = {},
            d = {};
          for (o = 0, a = e.length; o < a; o++) d[e[o].id] = e[o];
          for (o = 0, a = t.length; o < a; o++) i[t[o].id] = t[o];
          for (o = 0, a = e.length; o < a; o++) i[e[o].id] || s.added.push(e[o]);
          for (o = 0, a = t.length; o < a; o++) d[t[o].id] || s.removed.push(t[o]);
          return s
        }
      }), e(d)
    });
  }],
  ['!9', function(ym) {
    ym.modules.define("objectManager.component.TileLoadTree", ["util.defineClass"], function(i, e) {
      function t(i) {
        var e = [],
          t = [2 * i[0], 2 * i[1]];
        return e.push(t), e.push([t[0], t[1] + 1]), e.push([t[0] + 1, t[1]]), e.push([t[0] + 1, t[1] + 1]), e
      }
      var s = function(i) {
        this._tileTree = {}, this._context = i
      };
      e(s, {
        clear: function() {
          this._tileTree = {}
        },
        addLoadedTile: function(i, e) {
          this._tileTree[e] || (this._tileTree[e] = {}), this._tileTree[e][i[0]] || (this._tileTree[e][i[0]] = {}), this._tileTree[e][i[0]][i[1]] = !0
        },
        isTileLoaded: function(i, e, s) {
          if (this._tileTree[e] && this._tileTree[e][i[0]] && this._tileTree[e][i[0]][i[1]]) return !0;
          if (e >= this._context.options.get("maxZoom", 23) || e <= this._context.options.get("minZoom", 0)) return !1;
          if ("down" != s) {
            var o = [Math.floor(i[0] / 2), Math.floor(i[1] / 2)];
            if (this.isTileLoaded(o, e - 1, "up")) return this.addLoadedTile(i, e), !0
          }
          if ("up" != s) {
            var n = t(i),
              r = e + 1;
            if (this.isTileLoaded(n[0], r, "down") && this.isTileLoaded(n[1], r, "down") && this.isTileLoaded(n[2], r, "down") && this.isTileLoaded(n[3], r, "down")) return this.addLoadedTile(i, e), !0
          }
          return !1
        },
        getMissingTiles: function(i, e) {
          var s = [];
          if (!this.isTileLoaded(i, e))
            if (e == this._context.options.get("maxZoom", 23)) s.push({
              tileNumber: i,
              zoom: e
            });
            else {
              for (var o = t(i), n = e + 1, r = !0, d = 0; d < 4; d++) this.isTileLoaded(o[d], n) && (r = !1);
              r ? s.push({
                tileNumber: i,
                zoom: e
              }) : s = s.concat(this.getMissingTiles(o[0], n)).concat(this.getMissingTiles(o[1], n)).concat(this.getMissingTiles(o[2], n)).concat(this.getMissingTiles(o[3], n))
            }
          return s
        }
      }), i(s)
    });
  }],
  ['!$', function(ym) {
    ym.modules.define("objectManager.component.TileSource", ["util.processUrlTemplate", "util.defineClass"], function(e, t, n) {
      function a(e) {
        this._objectManager = e
      }
      n(a, {
        getTileUrl: function(e) {
          var n = this._objectManager;
          return t(n.getUrlTemplate(), e)
        },
        getPadding: function(e) {
          var n = this._objectManager.options.get("paddingTemplate", null);
          return n ? t(n, e).replace(/\W/g, "_") : null
        }
      }), e(a)
    });
  }],
  ['!_', function(ym) {
    ym.modules.define("objectManager.component.View", ["util.defineClass", "vow", "util.cancelableCallback", "geometry.pixel.Point", "overlay.storage", "option.Manager", "option.Router", "Event", "util.id", "constants.zIndex", "objectManager.objectCollection.overlayOptionMapper", "objectManager.clusterCollection.overlayOptionMapper", "util.extend", "objectManager.component.createGeometry", "util.Chunker", "util.bind"], function(e, t, s, o, r, i, a, n, l, c, h, v, _, u, g, d, y) {
      var p = function(e, t, s) {
        this._context = e, this._objectsEditingEventManager = t, this._clustersEditingEventManager = s, this._contextListener = null, this._overlayStorageCallbacks = {}, this._overlayCreateCallbacks = {}, this._objectCollectionListener = null, this._clusterCollectionListener = null, this._overlayListeners = {}, this._startObjectManagerListening(), this._startListeningObjectCollection(), this._startListeningClusterCollection(), this._startOverlaysListening(), this._geometries = {}, this._geometriesListeners = {}, this._chunker = null, this._removeFromMapQueue = {}
      };
      t(p, {
        setObjectManager: function(e) {
          e != this._context && (this._context && this._onObjectManagerRemove(), this._context = e, this._context && this._onObjectManagerAdd())
        },
        destroy: function() {
          this._stopOverlaysListening(), this._stopListeningClusterCollection(), this._stopListeningObjectCollection(), this._stopObjectManagerListening(), this._clearOverlayCreateCallbacks(), this._clearOverlayStorageCallbacks()
        },
        _startObjectManagerListening: function() {
          this._contextListener = this._context.events.group().add("statechange", this._onStateChange, this)
        },
        _stopObjectManagerListening: function() {
          this._contextListener.removeAll()
        },
        _startListeningObjectCollection: function() {
          this._objectCollectionListener = this._context.objects.events.group().add("objectoptionschange", this._onObjectOptionsChange, this).add("objectpropertieschange", this._onObjectPropertiesChange, this)
        },
        _stopListeningObjectCollection: function() {
          this._objectCollectionListener.removeAll()
        },
        _startListeningClusterCollection: function() {
          this._clusterCollectionListener = this._context.clusters.events.group().add("clusteroptionschange", this._onClusterOptionsChange, this).add("clusterpropertieschange", this._onClusterPropertiesChange, this)
        },
        _stopListeningClusterCollection: function() {
          this._clusterCollectionListener.removeAll()
        },
        _startOverlaysListening: function() {
          this._context.objects.overlays.events.add("mouseenter", this._onOverlayMouseEnter, this).add(["mouseleave", "mapchange"], this._onOverlayMouseLeave, this), this._context.clusters.overlays.events.add("mouseenter", this._onOverlayMouseEnter, this).add(["mouseleave", "mapchange"], this._onOverlayMouseLeave, this)
        },
        _stopOverlaysListening: function() {
          this._context.objects.overlays.events.remove("mouseenter", this._onOverlayMouseEnter, this).remove(["mouseleave", "mapchange"], this._onOverlayMouseLeave, this), this._context.clusters.overlays.events.remove("mouseenter", this._onOverlayMouseEnter, this).remove(["mouseleave", "mapchange"], this._onOverlayMouseLeave, this)
        },
        _onObjectOptionsChange: function(e) {
          var t = e.get("objectId"),
            s = this._context.objects.overlays.getById(t);
          s && this._setParentOptionManager(s, this._context.objects.getById(t), "object")
        },
        _onClusterOptionsChange: function(e) {
          var t = e.get("objectId"),
            s = this._context.clusters.overlays.getById(t);
          s && this._setParentOptionManager(s, this._context.clusters.getById(t), "cluster")
        },
        _onObjectPropertiesChange: function(e) {
          var t = e.get("objectId"),
            s = this._context.objects.overlays.getById(t);
          s && s.setData(this._context.objects.getById(t))
        },
        _onClusterPropertiesChange: function(e) {
          var t = e.get("objectId"),
            s = this._context.clusters.overlays.getById(t);
          s && s.setData(this._context.clusters.getById(t))
        },
        _onStateChange: function(e) {
          var t = e.get("added"),
            s = e.get("removed"),
            o = e.get("update"),
            r = e.get("addedClusters"),
            i = e.get("removedClusters"),
            a = e.get("sync");
          a ? (s && s.length && this._removeObjectsFromMapSync(s), i && i.length && this._removeClustersFromMapSync(i)) : (s && s.length && this._removeObjectsFromMap(s), i && i.length && this._removeClustersFromMap(i)), r && r.length && this._addClustersToMap(r), t && t.length && this._addObjectsToMap(t), o && o.length && this._updateObjects(o)
        },
        _addObjectsToMap: function(e) {
          for (var t = 0, s = e.length; t < s; t++) this._removeFromMapQueue[e[t].id] ? delete this._removeFromMapQueue[e[t].id] : this._setupObjectView(e[t], "object")
        },
        _removeObjectsFromMap: function(e) {
          for (var t = 0, s = e.length; t < s; t++) this._removeFromMapQueue[e[t].id] = !0;
          new d(e, {
            worker: y(this._removeObjectFromMap, this),
            chunkSize: 1e3,
            useRaf: !0
          }).start()
        },
        _removeClustersFromMap: function(e) {
          for (var t = 0, s = e.length; t < s; t++) this._removeFromMapQueue[e[t].id] = !0;
          new d(e, {
            worker: y(this._removeClusterFromMap, this),
            chunkSize: 1e3,
            useRaf: !0
          }).start()
        },
        _removeObjectsFromMapSync: function(e) {
          for (var t = 0, s = e.length; t < s; t++) {
            var o = e[t];
            this._removeFromMapQueue[o.id] = !0, this._removeObjectFromMap(o)
          }
        },
        _removeClustersFromMapSync: function(e) {
          for (var t = 0, s = e.length; t < s; t++) {
            var o = e[t];
            this._removeFromMapQueue[o.id] = !0, this._removeClusterFromMap(o)
          }
        },
        _removeObjectFromMap: function(e) {
          this._removeFromMapQueue[e.id] && (this._clearOverlayData(e, "object"), this._destroyObjectView(e, "object"), delete this._removeFromMapQueue[e.id])
        },
        _addClustersToMap: function(e) {
          for (var t = 0, s = e.length; t < s; t++) this._removeFromMapQueue[e[t].id] ? delete this._removeFromMapQueue[e[t].id] : this._setupObjectView(e[t], "cluster")
        },
        _removeClusterFromMap: function(e) {
          this._removeFromMapQueue[e.id] && (this._clearOverlayData(e, "cluster"), this._destroyObjectView(e, "cluster"), delete this._removeFromMapQueue[e.id])
        },
        _setupObjectView: function(e, t) {
          var s = e.id;
          if (this._context.options.get("syncOverlayInit", !1)) {
            var r = this._createObjectOverlaySync(e);
            this._addOverlayToMap(r, e, t)
          } else this._overlayCreateCallbacks[s] = o.create(function(o) {
            this._overlayCreateCallbacks[s] && delete this._overlayCreateCallbacks[s], this._addOverlayToMap(o, e, t)
          }, this), this._createObjectOverlay(e).done(this._overlayCreateCallbacks[s])
        },
        _addOverlayToMap: function(e, t, s) {
          var o = "object" == s,
            r = new l({
              target: this,
              type: "addoverlay",
              objectId: t.id,
              overlay: e
            });
          o ? this._objectsEditingEventManager.fire("addoverlay", r) : this._clustersEditingEventManager.fire("addoverlay", r);
          var i = null != (o ? this._context.objects.overlays.getById(t.id) : this._context.clusters.overlays.getById(t.id));
          i && (this._setParentOptionManager(e, t, s), e.setMap(this._context.getMap()))
        },
        _clearOverlayData: function(e, t) {
          var s = e.id;
          this._geometries[s] && (this._geometries[s].setMap(null), delete this._geometries[s], this._geometriesListeners[e.id].removeAll(), delete this._geometriesListeners[e.id]), this._overlayCreateCallbacks[s] && (this._overlayCreateCallbacks[s].cancel(), delete this._overlayCreateCallbacks[s]), this._overlayStorageCallbacks[s] && (this._overlayStorageCallbacks[s].cancel(), delete this._overlayStorageCallbacks[s])
        },
        _destroyObjectView: function(e, t) {
          var s = e.id,
            o = "object" == t,
            r = o ? this._context.objects.overlays.getById(s) : this._context.clusters.overlays.getById(s);
          if (r) {
            r.setMap(null), r.options.setParent(null);
            var i = new l({
              type: "remove",
              target: this,
              overlay: r,
              objectId: s
            });
            o ? this._objectsEditingEventManager.fire("removeoverlay", i) : this._clustersEditingEventManager.fire("removeoverlay", i)
          }
        },
        _createObjectOverlay: function(e) {
          var t = s.defer();
          return this._getOverlay(e, function(s) {
            var o = this._createOverlay(s, e);
            t.resolve(o)
          }), t.promise()
        },
        _createObjectOverlaySync: function(e) {
          var t = this._getOverlaySync(e);
          return this._createOverlay(t, e)
        },
        _createOverlay: function(e, t) {
          return new e(this._createPixelGeometry(t), t)
        },
        _updateOverlay: function(e, t) {
          t && t.setGeometry(this._createPixelGeometry(e))
        },
        _updateObjects: function(e) {
          for (var t, s = 0, o = e.length; s < o; s++) t = this._context.objects.overlays.getById(e[s].id) || this._context.clusters.overlays.getById(e[s].id), t && "Point" == e[s].geometry.type && this._updateOverlay(e[s], t)
        },
        _getOverlay: function(e, t) {
          var s = this._resolveOverlay(e),
            r = i.get(s);
          "undefined" == typeof r ? (this._overlayStorageCallbacks[e.id] = o.create(function(s) {
            this._overlayStorageCallbacks[e.id] && delete this._overlayStorageCallbacks[e.id], t.call(this, s)
          }, this), i.require([s], this._overlayStorageCallbacks[e.id])) : t.call(this, r)
        },
        _getOverlaySync: function(e) {
          var t = this._resolveOverlay(e);
          return i.get(t)
        },
        _resolveOverlay: function(e) {
          var t = null != this._context.objects.getById(e.id),
            s = t ? this._context.objects.options : this._context.clusters.options;
          return e.options && e.options.overlay || s.get(e.geometry.type + "Overlay", "default#placemark")
        },
        _setParentOptionManager: function(e, t, s) {
          var o = "object" == s,
            r = o ? this._context.objects.overlays.options : this._context.clusters.overlays.options;
          if (t.options) {
            var i = new a(t.options);
            o ? i.setMapper(v) : i.setMapper(_), e.options.setParent(new n(i, r))
          } else e.options.setParent(r);
          this._setOverlayZIndex(e, "zIndex", this._isMouseOver ? "hover" : "overlay")
        },
        _onOverlayMouseEnter: function(e) {
          this._isMouseOver = !0, this._setupHoverZIndex(e.get("overlay"))
        },
        _onOverlayMouseLeave: function(e) {
          this._isMouseOver = !1, this._clearOverlayZIndex(e.get("overlay"))
        },
        _setupHoverZIndex: function(e) {
          this._setOverlayZIndex(e, "zIndexHover", "hover")
        },
        _clearOverlayZIndex: function(e) {
          this._setOverlayZIndex(e, "zIndex", "overlay")
        },
        _setOverlayZIndex: function(e, t, s) {
          var o = e.options.getParent(),
            r = o.resolve(t);
          r || (r = o.resolve("icon" + t.charAt(0).toUpperCase() + t.substr(1))), e.options.set("zIndex", r || h[s])
        },
        _clearOverlayCreateCallbacks: function() {
          for (var e in this._overlayCreateCallbacks) this._overlayCreateCallbacks.hasOwnProperty(e) && this._overlayCreateCallbacks[e].cancel()
        },
        _clearOverlayStorageCallbacks: function() {
          for (var e in this._overlayStorageCallbacks) this._overlayStorageCallbacks.hasOwnProperty(e) && this._overlayStorageCallbacks[e].cancel()
        },
        _createPixelGeometry: function(e) {
          return "Point" == e.geometry.type ? new r(this._context.options.get("projection").toGlobalPixels(e.geometry.coordinates, this._context.getMap().getZoom())) : (this._geometries[e.id] || (this._geometries[e.id] = g(e, this._context.options.get("projection")), this._geometries[e.id].setMap(this._context.getMap()), this._geometriesListeners[e.id] = this._geometries[e.id].events.group().add("pixelgeometrychange", function() {
            this._updateOverlay(e, this._context.objects.overlays.getById(e.id))
          }, this)), this._geometries[e.id].getPixelGeometry())
        }
      }), e(p)
    });
  }],
  ['6m', function(ym) {
    ym.modules.define("objectManager.Hint", ["util.defineClass", "Hint", "component.sharedEntity.captor.Popup", "event.Manager", "map.addon.hint", "objectManager.objectCollection.optionMapper", "objectManager.clusterCollection.optionMapper", "option.Manager", "util.component", "util.extend", "util.preset", "Monitor", "projection.idle", "data.Manager", "popup.component.checkEmptiness", "popup.managerStorage", "vow", "util.id", "util.cancelableCallback", "objectManager.component.createGeometry", "util.bounds"], function(t, e, n, i, o, s, c, a, l, r, h, p, _, u, g, d, v, O, b, f, j, M) {
      function m(t) {
        this._collection = t, t.getObjectManager().getMap() && (this._setupSharingManager(), this._setupDomEvents()), this.events = new o({
          context: this
        }), this._setupOptionMonitor(), this._objectIdWithOpenHint = null, this._activeObjectId = null, this._objectIdWithOpenBalloon = null, this._collectionEventListener = null, this._enableHintMove = !0, this._setupCollectionEvents(), this._setupMapChangeListener(), this._captorListeners = {}, this._isEmptyCheckCallback = null
      }
      var C = {
        projection: u
      };
      e(m, r.createProxyMethods(function() {
        return this._captor
      }, ["getOwner", "getOverlay", "getOverlaySync", "getPosition", "getOptions", "setOptions", "setPosition"]), {
        isOpen: function(t) {
          return !(!this._captor || !this._captor.isOpen() || this._objectIdWithOpenHint != t)
        },
        isEmpty: function(t) {
          var e = this._collection.getById(t),
            n = this._specifyData(e);
          return n.options = this._createPopupOptions(e), d(this._collection.getObjectManager().getMap(), "hint", e.geometry.coordinates, n)
        },
        open: function(t, e) {
          this._activeObjectId = t;
          var n = O.defer();
          this._captor && this._objectIdWithOpenHint != t && (this._destroyCaptor(this._captor), this._clearCaptorListeners(this._captor)), this._objectIdWithOpenHint == t && this._captor || (this._captor = this._createCaptor(t), this._setupCaptorListeners(this._captor));
          var i = this._collection.getById(t),
            o = this._captor.open(e || this._getCenter(t), this._specifyData(i), this._createPopupOptions(i));
          return o.always(function(e) {
            e.isRejected() ? (this._onOpenReject(t), n.reject(e.valueOf())) : (this._onOpen(t), n.resolve(!0))
          }, this), n.promise()
        },
        close: function(t) {
          if (this._captor) {
            var e = O.defer();
            return this._captor.close(t).always(function(t) {
              t.isRejected() ? e.reject(t.valueOf()) : (this._onClose(), e.resolve(!0))
            }, this), e.promise()
          }
          return O.resolve(!0)
        },
        setData: function(t) {
          if (this._captor) return this._captor.setData(this._specifyData(t))
        },
        getData: function() {
          if (this._captor) {
            var t = this._captor.getData();
            return t ? t.object : null
          }
          return null
        },
        destroy: function() {
          this.close(!0), this._captor && (this._clearCaptorListeners(this._captor), this._destroyCaptor(this._captor), this._captor = null), this._optionMonitor.destroy(), this._clearDomEvents(), this._clearMapChangeListener()
        },
        _setupOptionMonitor: function() {
          this._optionMonitor = new _(this._collection.options).add("openHintOnHover", this._onOpenHintOnHoverChange, this)
        },
        _setupMapChangeListener: function() {
          this._collection.getObjectManager().events.add("mapchange", this._onMapChange, this)
        },
        _clearMapChangeListener: function() {
          this._collection.getObjectManager().events.remove("mapchange", this._onMapChange, this)
        },
        _onOpenHintOnHoverChange: function() {
          this._collection.options.get("openHintOnHover", !0) ? this._collection.events.add("mouseenter", this._onMouseEnter, this) : this._collection.events.remove("mouseenter", this._onMouseEnter, this)
        },
        _onClose: function() {
          var t = this._objectIdWithOpenHint;
          null !== t && "undefined" != typeof t && (t == this._activeObjectId && (this._activeObjectId = null), this._objectIdWithOpenHint = null, this._lastPosition = null, this.events.fire("close", {
            objectId: t
          }))
        },
        _setupDomEvents: function() {
          this._collection.options.get("openHintOnHover", !0) && this._collection.events.add("mouseenter", this._onMouseEnter, this)
        },
        _clearDomEvents: function() {
          this._collection.options.get("openHintOnHover", !0) && this._collection.events.remove("mouseenter", this._onMouseEnter, this)
        },
        _onMouseEnter: function(t) {
          if (!t.isDefaultPrevented()) {
            var e = t.get("objectId");
            e != this._objectIdWithOpenBalloon && this._getObjectOption(e, "openHintOnHover", !0) && (t.preventDefault(), this._enableHintMove = !0, this._lastPosition = t.get("globalPixels"), this._getObjectOption(e, "openEmptyHint", !1) ? this.open(e, this._lastPosition) : (this._isEmptyCheckCallback = f.create(function(t) {
              !t && this._collection.getById(e) && this._lastPosition && this.open(e, this._lastPosition)
            }, this), this.isEmpty(e).then(this._isEmptyCheckCallback)))
          }
        },
        _onOpen: function(t) {
          t != this._objectIdWithOpenHint && (this._objectIdWithOpenHint = t, this.events.fire("open", {
            objectId: t
          }))
        },
        _onOpenReject: function(t) {
          t == this._activeObjectId && (this._activeObjectId = null)
        },
        _onMapChange: function() {
          this._collection.getObjectManager().getMap() ? (this._setupSharingManager(), this._setupDomEvents(), this._setupCollectionEvents()) : (this._clearCollectionEvents(), this._clearDomEvents(), this.close(!0))
        },
        _setupSharingManager: function() {
          this._captor && (this._sharingManager = s.get(this._collection.getObjectManager().getMap()), this._captor.setSharingManager(this._sharingManager))
        },
        _setupCollectionEvents: function() {
          this._collectionEventListener = this._collection.events.group().add("mouseleave", this._onObjectMouseLeave, this).add("mousemove", this._onObjectMouseMove, this).add("overlayremove", this._onOverlayRemove, this).add("balloonopen", this._onBalloonOpen, this).add("balloonclose", this._onBalloonClose, this)
        },
        _clearCollectionEvents: function() {
          this._collectionEventListener && (this._collectionEventListener.removeAll(), this._collectionEventListener = null)
        },
        _onObjectMouseLeave: function() {
          this._isEmptyCheckCallback && (this._isEmptyCheckCallback.cancel(), this._isEmptyCheckCallback = null), null !== this._activeObjectId && "undefined" != typeof this._activeObjectId && (this._enableHintMove = !1, this._lastPosition = null, this.close())
        },
        _onObjectMouseMove: function(t) {
          this._enableHintMove && (this._captor && this._captor.setPosition(t.get("globalPixels")), this._lastPosition = t.get("globalPixels"))
        },
        _onBalloonOpen: function(t) {
          this._isEmptyCheckCallback && (this._isEmptyCheckCallback.cancel(), this._isEmptyCheckCallback = null);
          var e = t.get("objectId");
          e == this._activeObjectId && this.close(!0), this._objectIdWithOpenBalloon = e
        },
        _onBalloonClose: function() {
          this._objectIdWithOpenBalloon = null
        },
        _onOverlayRemove: function(t) {
          var e = t.get("objectId");
          e == this._activeObjectId && this.close(!0)
        },
        _createCaptor: function(t) {
          var e = this._collection.getObjectManager().getMap(),
            n = e && s.get(e),
            o = new i(this, this._collection, "hint", n);
          return o
        },
        _destroyCaptor: function(t) {
          t.close(!0), t.destroy()
        },
        _setupCaptorListeners: function(t) {
          this._captorListeners[b.get(t)] = t.events.group().add(["open", "close"], function(t) {
            t.stopImmediatePropagation()
          }).add("release", this._onClose, this).add("capture", function() {
            this.close(!0)
          }, this)
        },
        _clearCaptorListeners: function(t) {
          var e = b.get(t);
          this._captorListeners[e].removeAll(), delete this._captorListeners[e]
        },
        _specifyData: function(t) {
          return {
            collection: this._collection,
            properties: new g(t.properties),
            state: this._collection.state || new g,
            object: t
          }
        },
        _getObjectOption: function(t, e, n) {
          var i = this._collection.getById(t);
          if (!i) return null;
          var o = i.options ? i.options[e] : void 0;
          return "undefined" == typeof o ? this._collection.options.get(e, n) : o
        },
        _getCenter: function(t) {
          var e = this._collection.getById(t),
            n = this._collection.options.get("projection"),
            i = j(e, n),
            o = this._collection.getObjectManager().getMap();
          return i.setMap(o), M.getCenter(i.getPixelGeometry().getBounds())
        },
        _createPopupOptions: function(t) {
          return new l({}, new l(t.options ? h({}, C, t.options) : C, this._collection.options, null, c), "hint")
        }
      }), c.setRule({
        name: "hint",
        rule: "prefixed"
      }).setRule({
        name: "hint",
        key: "projection",
        rule: "plain"
      }), a.setRule({
        name: "hint",
        rule: "prefixed"
      }).setRule({
        name: "hint",
        key: "projection",
        rule: "plain"
      }), t(m)
    });
  }],
  ['!R', function(ym) {
    ym.modules.define("objectManager.ObjectCollection", ["util.defineClass", "component.collection.BaseCollection", "objectManager.OverlayCollection", "objectManager.objectCollection.optionMapper", "objectManager.parseData", "event.Manager", "event.Mapper", "objectManager.OverlayMappingTable", "Event", "option.Manager", "event.globalize", "util.extend"], function(e, t, n, o, i, s, r, a, c, h, d, l, v) {
      var g = function(e, t) {
          this._objectManager = e, this.events = new r({
            context: this
          }), this.events.addController(p), this.options = new d, this.options.events.add("change", function() {
            this.events.fire("optionschange")
          }, this), this.options.setMapper(i), this.options.setName("objectCollection"), this._collectionComponent = new n({
            onAdd: {
              callback: this._onAdd,
              context: this
            },
            onRemove: {
              callback: this._onRemove,
              context: this
            }
          }), this._objectsById = {}, this._overlayEditingEventManager = new r, this.overlays = new o(this._overlayEditingEventManager), this.overlays.options.setParent(this.options), this.overlays.events.setParent(new a(this.events, new c(this))), this._editingEventManager = t, this._editingEventManager.add("addoverlay", this._onOverlayAdd, this).add("removeoverlay", this._onOverlayRemove, this).add("removealloverlays", this._onOverlayRemoveAll, this), this.events.fire("create")
        },
        p = l(g);
      t(g, {
        getObjectManager: function() {
          return this._objectManager
        },
        add: function(e) {
          var t = s(e);
          return t = this._getNewObjects(t), this._addObjects(t), this
        },
        remove: function(e) {
          var t = this._getIdsArray(e),
            n = this._getAddedObjectsById(t);
          return this._removeObjects(n), this
        },
        removeAll: function() {
          var e = this.getAll();
          return this._objectsById = {}, this._collectionComponent.removeAll(), this.events.fire("objectsremove", new h({
            type: "objectsremove",
            target: this,
            objects: e
          })), this
        },
        getById: function(e) {
          return this._objectsById[e] || null
        },
        getLength: function() {
          return this._collectionComponent.getLength()
        },
        getIterator: function() {
          return this._collectionComponent.getIterator()
        },
        each: function(e, t) {
          this._collectionComponent.each(e, t)
        },
        getAll: function() {
          for (var e, t = this.getIterator(), n = [];
            (e = t.getNext()) != t.STOP_ITERATION;) n.push(e);
          return n
        },
        setObjectOptions: function(e, t) {
          var n = this.getById(e);
          return n && (n.options = n.options ? v(n.options, t) : t, this.events.fire("objectoptionschange", {
            objectId: e
          })), this
        },
        setObjectProperties: function(e, t) {
          var n = this.getById(e);
          n && (n.properties = n.properties ? v(n.properties, t) : t, this.events.fire("objectpropertieschange", {
            objectId: e
          }))
        },
        _getNewObjects: function(e) {
          for (var t = [], n = 0, o = e.length; n < o; n++) this.getById(e[n].id) || t.push(e[n]);
          return t
        },
        _addObjects: function(e) {
          for (var t = 0, n = e.length; t < n; t++) this._objectsById[e[t].id] = e[t], this._collectionComponent.add(e[t]);
          this.events.fire("objectsadd", new h({
            type: "objectsadd",
            target: this,
            objects: e
          }))
        },
        _removeObjects: function(e) {
          for (var t = 0, n = e.length; t < n; t++) delete this._objectsById[e[t].id], this._collectionComponent.remove(e[t]);
          this.events.fire("objectsremove", new h({
            type: "objectsremove",
            target: this,
            objects: e
          }))
        },
        _getIdsArray: function(e) {
          for (var t = s(e), n = [], o = 0, i = t.length; o < i; o++) "undefined" != typeof t[o].id ? n.push(t[o].id) : n.push(t[o]);
          return n
        },
        _getAddedObjectsById: function(e) {
          for (var t = [], n = 0, o = e.length; n < o; n++) e[n] in this._objectsById && t.push(this._objectsById[e[n]]);
          return t
        },
        _onAdd: function(e) {
          this.events.fire("add", new h({
            type: "add",
            target: this,
            child: e,
            objectId: e.id
          }))
        },
        _onRemove: function(e) {
          this.events.fire("remove", new h({
            type: "remove",
            target: this,
            child: e,
            objectId: e.id
          }))
        },
        _onOverlayAdd: function(e) {
          this._overlayEditingEventManager.fire("add", new h({
            type: "add",
            target: this,
            overlay: e.get("overlay"),
            objectId: e.get("objectId")
          }))
        },
        _onOverlayRemove: function(e) {
          this._overlayEditingEventManager.fire("remove", new h({
            type: "remove",
            target: this,
            overlay: e.get("overlay"),
            objectId: e.get("objectId")
          }))
        },
        _onOverlayRemoveAll: function(e) {
          this._overlayEditingEventManager.fire("removeall")
        }
      }), e(g)
    });
  }],
  [';v', function(ym) {
    ym.modules.define("objectManager.objectCollection.optionMapper", ["option.Mapper"], function(e, o) {
      e(new o)
    });
  }],
  [';w', function(ym) {
    ym.modules.define("objectManager.objectCollection.overlayOptionMapper", ["option.Mapper"], function(e, o) {
      e(new o)
    });
  }],
  ['6o', function(ym) {
    ym.modules.define("objectManager.optionMapper", ["option.Mapper"], function(e, n) {
      e(new n)
    });
  }],
  ['!S', function(ym) {
    ym.modules.define("objectManager.OverlayCollection", ["util.defineClass", "ReadOnlyCollection", "event.Manager", "Event", "option.Manager", "util.bind", "util.id", "constants.mapDomEvents", "objectManager.objectCollection.overlayOptionMapper", "geoObject.view.overlayMapping"], function(e, t, i, n, a, o, r, s, l, d, g) {
      for (var v = {}, y = 0, h = l.length; y < h; y++) v[l[y]] = !0;
      var c = function(e) {
        this._overlayEditingEventManager = new n, c.superclass.constructor.call(this, this._overlayEditingEventManager), this.options.setMapper(d), this._overlaysById = {}, this._idsByOverlay = {}, this._controller = {
          onAfterEventFiring: r(this._onAfterObjectEventFiring, this)
        }, this._editingEventManager = e, this._editingEventManager.add("add", this._onEditingManagerAddRequest, this).add("remove", this._onEditingManagerRemoveRequest, this).add("removeall", this._onEditingManagerRemoveAllRequest, this), this._mappingByOverlayName = {}
      };
      t(c, i, {
        getById: function(e) {
          return this._overlaysById[e] || null
        },
        getId: function(e) {
          var t = this._idsByOverlay[s.get(e)];
          return "undefined" == typeof t ? null : t
        },
        onChildAdd: function(e) {
          this._mappingByOverlayName[e.options.getName()] || (this._mappingByOverlayName[e.options.getName()] = !0, g.setupMapping(d, e.options.getName(), e.getGeometry().getType())), e.events.addController(this._controller), this.events.fire("add", new a({
            type: "add",
            target: this,
            overlay: e,
            objectId: this.getId(e)
          }))
        },
        onChildRemove: function(e) {
          var t = this.getId(e),
            i = s.get(e);
          e.events.removeController(this._controller), delete this._overlaysById[t], delete this._idsByOverlay[i], this.events.fire("remove", new a({
            type: "remove",
            target: this,
            overlay: e,
            objectId: t
          }))
        },
        _onEditingManagerAddRequest: function(e) {
          var t = e.get("overlay"),
            i = e.get("objectId");
          this._idsByOverlay[s.get(t)] = i, this._overlaysById[i] = t, this._overlayEditingEventManager.fire("add", new a({
            type: "add",
            target: this,
            object: t
          }))
        },
        _onEditingManagerRemoveRequest: function(e) {
          var t = e.get("overlay");
          this._overlayEditingEventManager.fire("remove", new a({
            type: "remove",
            target: this,
            object: t
          }))
        },
        _onEditingManagerRemoveAllRequest: function() {
          this._overlaysById = {}, this._idsByOverlay = {}, this._overlayEditingEventManager.fire("removeAll")
        },
        _onAfterObjectEventFiring: function(e, t, i) {
          if (t in v && !i.isImmediatePropagationStopped()) {
            var n = i.get("target");
            this.events.fire(t, {
              objectId: this.getId(n),
              overlay: n,
              pagePixels: i.get("pagePixels"),
              clientPixels: i.get("clientPixels"),
              globalPixels: i.get("globalPixels"),
              coords: i.get("coords"),
              domEvent: i.get("domEvent")
            })
          }
        }
      }), e(c)
    });
  }],
  [';x', function(ym) {
    ym.modules.define("objectManager.OverlayMappingTable", ["util.defineClass", "Event"], function(n, t, e) {
      var i = function(n) {
        this._context = n, this["*"] = this._defaultMappingFunction, this.add = this._addMappingFunction, this.remove = this._removeMappingFunction
      };
      t(i, {
        _defaultMappingFunction: function(n) {
          return new e({
            currentTarget: this._context
          }, n)
        },
        _addMappingFunction: function(n) {
          return new e({
            type: "overlayadd",
            currentTarget: this._context
          }, n)
        },
        _removeMappingFunction: function(n) {
          return new e({
            type: "overlayremove",
            currentTarget: this._context
          }, n)
        }
      }), n(i)
    });
  }],
  ['!8', function(ym) {
    ym.modules.define("objectManager.parseData", ["util.array", "util.json"], function(e, t, r) {
      function o(e) {
        return "string" == typeof e ? o(r.from(e)) : t.isArray(e) ? t.map(e, a) : "FeatureCollection" == e.type ? s(e) : "Feature" == e.type || "Cluster" == e.type ? [a(e)] : []
      }

      function s(e) {
        for (var t = [], r = 0, o = e.features.length; r < o; r++) {
          var a = e.features[r];
          switch (a.type) {
            case "FeatureCollection":
              t = t.concat(s(a));
              break;
            case "Cluster":
              a.properties && !a.properties.geoObjects && a.features && (a.properties.geoObjects = a.features.slice()), t.push(a);
              break;
            default:
              t.push(a)
          }
        }
        return t
      }

      function a(e) {
        return e.hasOwnProperty("options") || (e.options = {}), e.hasOwnProperty("properties") || (e.properties = {}), e
      }
      e(o)
    });
  }],
  ['6p', function(ym) {
    ym.modules.define("objectManager.util", [], function(r) {
      r({
        getTilesArrayFromTileBoundsArray: function(r, e, o) {
          for (var n, t = [], u = 0, a = r.length; u < a; u++) {
            n = r[u];
            for (var i = n[0][0]; o ? i <= n[1][0] : i < n[1][0]; i++)
              for (var f = n[0][1]; o ? f <= n[1][1] : f < n[1][1]; f++) t.push({
                tileNumber: [i, f],
                zoom: e
              })
          }
          return t
        }
      })
    });
  }],
  ['6s', function(ym) {
    ym.modules.define("option.Manager", ["util.defineClass", "util.extend", "util.objectKeys", "component.child.BaseChild", "option.presetStorage", "event.manager.Base", "Event", "option.manager.Monitor", "option.manager.LocalMonitor"], function(e, t, i, n, s, r, h, a, o, p) {
      var _ = {},
        f = t(function(e, t, i, n) {
          this._options = e || null, this._originalOptions = Boolean(this._options), this._baseItem = new s(this._parentChangeCallback, this), t && this._baseItem.setParent(t), this._name = i, this._mapper = null, this._cache = {}, this._frozen = !1, this._changed = !1, this._monitor = null, this.setMapper(n), this.events = new h
        }, {
          setParent: function(e) {
            return this._baseItem.setParent(e), this
          },
          getParent: function() {
            return this._baseItem.getParent()
          },
          setName: function(e) {
            this._name != e && (this._name = e, this._cache = {}, this._fire())
          },
          getName: function() {
            return this._name
          },
          setMapper: function(e) {
            this._getMapper() != e && (this._mapper && this._clearMapper(), this._mapper = e ? {
              mapper: e,
              active: !1
            } : null, this.getParent() && (this._mapper && this._setupMapper(), this.events && this._fire()))
          },
          _getMapper: function() {
            return this._mapper ? this._mapper.mapper : null
          },
          set: function(e, t) {
            var i = e;
            "string" == typeof e && (i = {}, i[e] = t);
            var s = n(i),
              r = this._getOptionsForChanging(),
              h = !1;
            i.hasOwnProperty("preset") && (this._cache = {});
            for (var a = 0, o = s.length; a < o; ++a) e = s[a], t = i[e], r[e] !== t && (this._cache[e] = t, r[e] = t, h = !0);
            return h && this._fire(), this
          },
          get: function(e, t) {
            if ("preset" == e) return this.getNative(e) || t;
            var i = this._cache[e];
            if ("undefined" == typeof i) {
              var n = this._find(e);
              i = this._cache[e] = "undefined" == typeof n ? _ : n
            }
            return i == _ ? t : i
          },
          getNative: function(e) {
            return this._options ? this._options[e] : void 0
          },
          getAll: function() {
            return this._getOptionsForChanging()
          },
          resolve: function(e, t) {
            if (this._mapper) {
              var i, n = this._mapper.mapper.resolve(e, t);
              if ("string" == typeof n) i = this.get(n);
              else
                for (var s = 0, r = n.length; s < r && (i = this.get(n[s]), "undefined" == typeof i); s++);
              return i
            }
            return this.get(e)
          },
          unset: function(e) {
            "string" == typeof e && (e = [e]);
            for (var t = this._getOptionsForChanging(), i = !0, n = !1, s = 0, r = e.length; s < r; s++) {
              var h = e[s];
              t.hasOwnProperty(h) && (i && ("preset" == h ? (this._cache = {}, i = !1) : delete this._cache[h]), delete t[h], n = !0)
            }
            return n && this._fire(), this
          },
          unsetAll: function() {
            return this._cache = {}, this._options = null, this._fire(), this
          },
          freeze: function() {
            return this._frozen = !0, this
          },
          unfreeze: function() {
            return this._frozen = !1, this._changed && (this._changed = !1, this._fire()), this
          },
          isFrozen: function() {
            return this._frozen
          },
          getMonitor: function(e) {
            var t = this._monitor || (this._monitor = new o(this));
            return e ? new p(t, e) : t
          },
          _setupMapper: function() {
            this._mapper.active || (this._mapper.mapper.events.add("rulechange", this._fire, this), this._mapper.active = !0)
          },
          _clearMapper: function() {
            this._mapper.active && (this._mapper.mapper.events.remove("rulechange", this._fire, this), this._mapper.active = !1)
          },
          _find: function(e) {
            var t;
            return this._options && (t = this._options[e], "undefined" == typeof t && "undefined" != typeof this._options.preset && (t = this._resolvePreset(this._options.preset, e))), "undefined" == typeof t && this._parent && (t = this._parent.resolve(e, this._name)), t
          },
          _resolvePreset: function(e, t) {
            var i;
            if (e instanceof Array)
              for (var n = 0; n < e.length && (i = this._resolveKey(e[n], t), "undefined" == typeof i); n++);
            else i = this._resolveKey(e, t);
            return i
          },
          _resolveKey: function(e, t) {
            var i;
            return e = r.get(e), "undefined" != typeof e && ("undefined" != typeof e[t] ? i = e[t] : "undefined" != typeof e.preset && (i = this._resolvePreset(e.preset, t))), i
          },
          _parentChangeCallback: function(e, t) {
            this._cache = {}, e && e.events.remove("change", this._onParentChange, this), t && t.events.add("change", this._onParentChange, this), this._parent = t, t ? this._mapper && this._setupMapper() : this._mapper && this._clearMapper(), this.events && (this.events.fire("parentchange", {
              target: this,
              oldParent: e,
              newParent: t
            }), this._fire())
          },
          _onParentChange: function() {
            this._cache = {}, this._fire()
          },
          _getOptionsForChanging: function() {
            return this._options ? this._originalOptions && (this._options = i({}, this._options), this._originalOptions = !1) : this._options = {}, this._options
          },
          _fire: function() {
            this._frozen ? this._changed = !0 : (this._monitor && this._monitor.checkChange(), this.events.fire("change", new a({
              target: this,
              type: "change"
            })))
          }
        });
      e(f)
    });
  }],
  ['!!', function(ym) {
    ym.modules.define("option.manager.LocalMonitor", ["util.defineClass"], function(t, i) {
      function e(t, i) {
        this._monitor = t, this._defaultValues = i
      }
      i(e, {
        add: function(t, i, e) {
          return this._monitor.add(t, i, e, this._defaultValues), this
        },
        remove: function(t, i, e) {
          return this._monitor.remove(t, i, e, this._defaultValues), this
        },
        get: function(t) {
          return this._monitor.get(t, this._defaultValues)
        }
      }), t(e)
    });
  }],
  ['!*', function(ym) {
    ym.modules.define("option.manager.Monitor", ["util.defineClass", "util.bind"], function(e, t, s) {
      function i(e) {
        this._optionManger = e, this._listeners = [], this._values = {}, this._nameCounters = {}, this._onCheckCounter = 0, this._needTrim = !1, this._trimTimeoutId = 0
      }

      function n(e, t, s) {
        return e == h ? s && "undefined" != typeof s[t] ? s[t] : r : e
      }
      var r, h = {};
      t(i, {
        add: function(e, t, s, i) {
          if (this._listeners.push(e, t, s, i), "string" == typeof e) this._addName(e);
          else
            for (var n = 0, r = e.length; n < r; n++) this._addName(e[n]);
          return this
        },
        remove: function(e, t, s, i) {
          var n = this._searchListener(e, t, s, i);
          if (n != -1)
            if (this._listeners[n] = null, this._needTrim = !0, "string" == typeof e) this._removeName(e);
            else
              for (var r = 0, h = e.length; r < h; r++) this._removeName(e[r]);
          return this._tryTrimListeners(), this
        },
        get: function(e, t) {
          return n(this._values[e], e, t)
        },
        checkChange: function() {
          this._onCheckCounter++;
          for (var e = {}, t = 0, s = this._listeners.length; t < s; t += 4) this._listeners[t] && this._checkListener(this._listeners[t], this._listeners[t + 1], this._listeners[t + 2], this._listeners[t + 3], e);
          this._onCheckCounter--, this._tryTrimListeners()
        },
        _checkListener: function(e, t, s, i, r) {
          if ("string" == typeof e) this._updateNameValue(e, r), r[e] != this._values[e] && this._callNameListener(t, s, n(this._values[e], e, i), n(r[e], e, i));
          else {
            this._updateNameValues(e, r);
            for (var h = 0, a = e.length; h < a; h++)
              if (r[e[h]] != this._values[e[h]]) {
                this._callNameListener(t, s, this._fixUndefForNames(this._values, e, i), this._fixUndefForNames(r, e, i));
                break
              }
          }
        },
        _updateNameValue: function(e, t) {
          "undefined" == typeof t[e] && (t[e] = this._values[e], this._values[e] = this._resolveNameValue(e))
        },
        _updateNameValues: function(e, t) {
          for (var s = 0, i = e.length; s < i; s++) this._updateNameValue(e[s], t)
        },
        _callNameListener: function(e, t, s, i) {
          t ? e.call(t, s, i) : e(s, i)
        },
        _searchListener: function(e, t, s, i) {
          for (var n = 0, r = this._listeners.length; n < r; n += 4)
            if (this._compareNames(this._listeners[n], e) && this._listeners[n + 1] == t && this._listeners[n + 2] == s && this._listeners[n + 3] == i) return n;
          return -1
        },
        _addName: function(e) {
          this._nameCounters[e] ? this._nameCounters[e]++ : (this._nameCounters[e] = 1, this._values[e] = this._resolveNameValue(e))
        },
        _removeName: function(e) {
          this._nameCounters[e]--, this._nameCounters[e] || delete this._values[e]
        },
        _resolveNameValue: function(e) {
          return this._optionManger.get(e, h)
        },
        _compareNames: function(e, t) {
          var s = typeof e;
          if (s == typeof t) {
            if ("string" == s) return e == t;
            var i = e.length;
            if (i == t.length) {
              for (var n = 0; n < i; n++)
                if (e[n] != t[n]) return !1;
              return !0
            }
          }
          return !1
        },
        _tryTrimListeners: function() {
          this._onCheckCounter || !this._needTrim || this._trimTimeoutId || (this._trimTimeoutId = setTimeout(s(function() {
            this._needTrim = !1, this._trimTimeoutId = 0, this._trimListeners()
          }, this), 0))
        },
        _trimListeners: function() {
          for (var e = [], t = 0, s = this._listeners.length; t < s; t += 4) this._listeners[t] && e.push(this._listeners[t], this._listeners[t + 1], this._listeners[t + 2], this._listeners[t + 3]);
          this._listeners = e
        },
        _fixUndefForNames: function(e, t, s) {
          for (var i = {}, r = 0, h = t.length; r < h; r++) {
            var a = t[r];
            i[a] = n(e[a], a, s)
          }
          return i
        }
      }), e(i)
    });
  }],
  ['6u', function(ym) {
    ym.modules.define("option.Mapper", ["event.Manager", "Event", "util.array"], function(e, n, t, l) {
      function r(e, n, t) {
        if (l.isArray(t)) {
          for (var r, a = 0, i = t.length; a < i; a++) {
            var s = u(e, n, t[a]);
            r ? "string" == typeof s ? r.push(s) : r = r.concat(s) : r = "string" == typeof s ? [s] : s.slice()
          }
          return r
        }
        return u(e, n, t)
      }

      function u(e, n, t) {
        return "plain" == t ? e : "prefixed" == t ? a(e, n) : t(e, n)
      }

      function a(e, n) {
        return n + e.slice(0, 1).toUpperCase() + e.slice(1)
      }
      var i = function(e) {
        this._defaultRule = e || null, this._rules = {
          nameRules: {},
          keyRules: {},
          keyNameRules: {}
        }, this.events = new n
      };
      i.addPrefix = function(e, n) {
        return n + e.slice(0, 1).toUpperCase() + e.slice(1)
      }, i.addOptionalPrefix = function(e, n) {
        return [i.addPrefix(e, n), e]
      }, i.addOptionalPrefixForBalloonHint = function(e, n) {
        return 0 == e.indexOf("balloon") || 0 == e.indexOf("hint") ? i.addOptionalPrefix(e, n) : i.addPrefix(e, n)
      }, i.prototype = {
        setRule: function(e) {
          e.rule || (e.rule = "plain");
          for (var n = [].concat(e.key), l = [].concat(e.name), r = 0, u = n.length; r < u; r++)
            for (var a = 0, i = l.length; a < i; a++) this._applyRule(n[r], l[a], e.rule);
          return this.events.fire("rulechange", new t({
            target: this,
            selector: e,
            rule: e.rule
          })), this
        },
        fireChange: function() {
          this.events.fire("rulechange")
        },
        _applyRule: function(e, n, t) {
          var l = this._rules;
          n && e ? (l.keyNameRules[e] || (l.keyNameRules[e] = {}))[n] = t : n ? l.nameRules[n] = t : e && (l.keyRules[e] = t)
        },
        unsetRule: function(e) {
          for (var n = [].concat(e.key), l = [].concat(e.name), r = 0, u = n.length; r < u; r++)
            for (var a = 0, i = l.length; a < i; a++) this._cleanRule(n[r], l[a]);
          return this.events.fire("rulechange", new t({
            target: this,
            selector: e,
            rule: null
          })), this
        },
        _cleanRule: function(e, n) {
          var t = this._rules;
          n && e ? t.keyNameRules[e] && delete t.keyNameRules[e][n] : n ? delete t.nameRules[n] : e && delete t.keyRules[e]
        },
        resolve: function(e, n) {
          var t = this._rules;
          return t.keyNameRules[e] && t.keyNameRules[e][n] ? r(e, n, t.keyNameRules[e][n]) : t.nameRules[n] ? r(e, n, t.nameRules[n]) : t.keyRules[e] ? r(e, n, t.keyRules[e]) : this._defaultRule ? r(e, n, this._defaultRule) : e
        }
      }, e(i)
    });
  }],
  ['6v', function(ym) {
    ym.modules.define("option.presetStorage", ["util.Storage"], function(e, o) {
      e(new o)
    });
  }],
  ['6x', function(ym) {
    ym.modules.define("option.Router", ["util.defineClass", "util.array", "event.manager.Base", "Event"], function(e, t, n, s, i) {
      var r = t(function(e) {
        this._parents = Array.prototype.slice.call(arguments), this._setupChangeListeners(this._parents), this.events = new s
      }, {
        getParentsLength: function() {
          return this._parents.length
        },
        indexOfParent: function(e) {
          return n.indexOf(this._parents, e)
        },
        spliceParents: function(e, t) {
          var n, s = arguments.length;
          return s > 2 ? (n = this._parents.splice.apply(this._parents, arguments), this._setupChangeListeners(this._parents.slice(e, (e || 0) + s - 2))) : n = this._parents.splice(e, t), this._clearChangeListeners(n), this._fireChange(), n
        },
        resolve: function(e, t) {
          for (var n, s = 0, i = this._parents.length; s < i && (n = this._parents[s].resolve(e, t), "undefined" == typeof n); s++);
          return n
        },
        _setupChangeListeners: function(e) {
          for (var t = 0, n = e.length; t < n; t++) e[t].events.add("change", this._fireChange, this)
        },
        _clearChangeListeners: function(e) {
          for (var t = 0, n = e.length; t < n; t++) e[t].events.remove("change", this._fireChange, this)
        },
        _fireChange: function() {
          this.events.fire("change", new i({
            target: this,
            type: "change"
          }))
        }
      });
      e(r)
    });
  }],
  ['6D', function(ym) {
    ym.modules.define("overlay.storage", ["util.AsyncStorage"], function(e, o) {
      e(new o("overlay"))
    });
  }],
  [';O', function(ym) {
    ym.modules.define("package.controls.predefinedSets", ["control.manager.predefinedSets", "map.metaOptions"], function(e, l, t) {
      function a(e) {
        var l = ["zoomControl", "searchControl", "typeSelector", "geolocationControl"],
          t = [];
        "small" != e && "medium" != e || l.push("fullscreenControl"), "medium" != e && "large" != e || l.push("trafficControl", "rulerControl"), "large" == e && l.push("routeEditor");
        for (var a = 0, o = l.length; a < o; a++) t.push("small" == e ? {
          type: l[a],
          options: {
            size: "small"
          }
        } : l[a]);
        return t
      }
      l.add("smallMapDefaultSet", a("small")), l.add("mediumMapDefaultSet", a("medium")), l.add("largeMapDefaultSet", a("large")), l.add("default", a("medium")), t.set("defaultControls", ["default"]), e(a)
    });
  }],
  ['*_', function(ym) {
    ym.modules.define("package.full", ["Balloon", "behavior.DblClickZoom", "behavior.Drag", "behavior.LeftMouseButtonMagnifier", "behavior.MultiTouch", "behavior.RightMouseButtonMagnifier", "behavior.RouteEditor", "behavior.Ruler", "behavior.ScrollZoom", "behavior.storage", "Circle", "Clusterer", "clusterer.addon.balloon", "clusterer.addon.hint", "ClusterPlacemark", "Collection", "collection.Item", "control.Button", "control.FullscreenControl", "control.GeolocationControl", "control.ListBox", "control.ListBoxItem", "control.Manager", "control.RouteEditor", "control.RulerControl", "control.SearchControl", "control.storage", "control.TrafficControl", "control.TypeSelector", "control.ZoomControl", "coordSystem.cartesian", "coordSystem.geo", "data.Manager", "DomEvent", "domEvent.manager", "domEvent.MultiPointer", "domEvent.MultiTouch", "domEvent.Pointer", "domEvent.Touch", "Event", "event.Group", "event.Manager", "event.Mapper", "formatter", "geocode", "geolocation", "geometry.base.Circle", "geometry.base.LinearRing", "geometry.base.LineString", "geometry.base.Point", "geometry.base.Polygon", "geometry.base.Rectangle", "geometry.Circle", "geometry.LineString", "geometry.pixel.Circle", "geometry.pixel.LineString", "geometry.pixel.MultiPolygon", "geometry.pixel.Point", "geometry.pixel.Polygon", "geometry.pixel.Rectangle", "geometry.Point", "geometry.Polygon", "geometry.Rectangle", "geometryEditor.LineString", "geometryEditor.Point", "geometryEditor.Polygon", "GeoObject", "geoObject.addon.balloon", "geoObject.addon.editor", "geoObject.addon.hint", "geoObject.Balloon", "geoObject.Hint", "GeoObjectArray", "GeoObjectCollection", "geoQuery", "GeoQueryResult", "geoXml.load", "getZoomRange", "Hint", "Hotspot", "hotspot.Manager", "hotspot.Container", "hotspot.Layer", "hotspot.layer.addon.balloon", "hotspot.layer.addon.hint", "hotspot.layer.Balloon", "hotspot.layer.Hint", "hotspot.layer.Object", "hotspot.loader", "hotspot.ObjectSource", "hotspot.layer.ObjectSource", "interactivityModel.geoObject", "interactivityModel.layer", "interactivityModel.opaque", "interactivityModel.silent", "interactivityModel.storage", "interactivityModel.transparent", "Layer", "layer.storage", "layer.tile.CanvasTile", "layer.tile.DomTile", "layer.tileContainer.CanvasContainer", "layer.tileContainer.DomContainer", "LayerCollection", "layout.Image", "layout.ImageWithContent", "layout.storage", "layout.templateBased.Base", "LoadingObjectManager", "Map", "map.action.Continuous", "map.action.Manager", "map.action.Single", "map.addon.balloon", "map.addon.hint", "map.Balloon", "map.behavior.Manager", "map.Container", "map.Converter", "map.Copyrights", "map.GeoObjects", "map.Hint", "map.layer.Manager", "map.margin.Manager", "map.margin.Accessor", "map.pane.Manager", "map.ZoomRange", "MapEvent", "MapType", "mapType.storage", "meta", "Monitor", "pane.EventsPane", "pane.MovablePane", "pane.StaticPane", "poi.dataSource", "multiRouter.MultiRouteModel", "multiRouter.MultiRoute", "multiRouter.editor.addon", "ObjectManager", "objectManager.addon.clustersBalloon", "objectManager.addon.clustersHint", "objectManager.addon.objectsBalloon", "objectManager.addon.objectsHint", "option.Manager", "option.presetStorage", "overlay.storage", "package.controls.predefinedSets", "Placemark", "Polygon", "Polyline", "Popup", "projection.Cartesian", "projection.sphericalMercator", "projection.wgs84Mercator", "Rectangle", "RemoteObjectManager", "regions", "util.requireCenterAndZoom", "route", "shape.Circle", "shape.LineString", "shape.MultiPolygon", "shape.Polygon", "shape.Rectangle", "shape.storage", "suggest", "SuggestView", "search", "Template", "template.filtersStorage", "templateLayoutFactory", "traffic.provider.Actual", "traffic.provider.Archive", "traffic.provider.Forecast", "traffic.provider.storage", "util.AsyncStorage", "util.augment", "util.bind", "util.bounds", "util.pixelBounds", "util.cursor.Accessor", "util.cursor.Manager", "util.defineClass", "util.Dragger", "util.extend", "util.math.areEqual", "util.math.cycleRestrict", "util.math.restrict", "util.Storage", "vow"], ym.modules.providePackage);
  }],
  ['*R', function(ym) {
    ym.modules.define("package.system", ["vow", "theme.browser.current", "system.settings", "package.yandex"], function(e) {
      e(!0)
    });
  }],
  ['*U', function(ym) {
    ym.modules.define("package.yandex", function(e) {
      var a = {
          map: "Map",
          sat: "Satellite",
          skl: "Skeleton"
        },
        r = {
          map: ["map"],
          satellite: ["sat"],
          hybrid: ["sat", "skl"]
        };
      if (e.env.restrictions && e.env.restrictions.prohibitedLayers)
        for (var t = e.env.restrictions.prohibitedLayers.split(","), n = 0, i = t.length; n < i; n++) delete a[t[n]];
      var s = ["yandex.mapType.metaOptions", "yandex.counterStorage"];
      for (var i in a) a.hasOwnProperty(i) && s.push("yandex.layer." + a[i]);
      for (var o in r)
        if (r.hasOwnProperty(o)) {
          for (var p = r[o], n = 0, i = p.length; n < i && a[p[n]]; n++);
          n == i && s.push("yandex.mapType." + o)
        }
      return s
    }, function(e) {
      e(!0)
    });
  }],
  ['.n', function(ym) {
    ym.modules.define('pane-controls-css', ['system.provideCss'], function(provide, provideCss) {
      provideCss("@media print{.ymaps-2-1-42-controls-pane{visibility:hidden}}", provide);
    });
  }],
  ['*!', function(ym) {
    ym.modules.define("pane.Base", ["util.defineClass", "util.extend", "util.dom.element", "util.dom.style", "util.dom.className", "event.Manager", "domEvent.manager", "constants.mapDomEvents", "MapEvent", "util.css"], function(e, t, n, i, o, s, a, m, h, l, r) {
      function c(e, t) {
        this._map = e, t = n({
          zIndex: 0,
          overflow: "hidden"
        }, t), this._zIndex = t.zIndex, this._overflow = t.overflow, this._checkContextMenuEvent = t.checkContextMenu, this._element = i.create({
          className: t.className,
          css: n({
            position: "absolute",
            left: 0,
            top: 0
          }, t.css),
          patch: t.patch
        });
        var l = ym.env.browser;
        "pointer" == l.eventMapper && s.add(this._element, r.addPrefix("touch-action-none")), "WebKit" == l.engine && "Safari" != l.name && "MobileSafari" != l.name && o.patch(this._element, {
          transform: {
            use3D: !0
          }
        }), this.events = new a({
          context: this
        }), m.add(this._element, h, this._onDomEvent, this)
      }
      t(c, {
        getMap: function() {
          return this._map
        },
        getElement: function() {
          return this._element
        },
        getZIndex: function() {
          return this._zIndex
        },
        getOverflow: function() {
          return this._overflow
        },
        destroy: function() {
          m.remove(this._element, h, this._onDomEvent, this)
        },
        _onDomEvent: function(e) {
          this._checkContextMenuEvent && "contextmenu" == e.get("type") && !this._map.options.get("enableContextMenu", !1) && e.callMethod("preventDefault");
          var t = e.get("type");
          this.events.fire(t, new l({
            type: t,
            target: this,
            map: this._map,
            domEvent: e
          }, e))
        }
      }), e(c)
    });
  }],
  ['**', function(ym) {
    ym.modules.define("pane.BaseContainer", ["util.defineClass", "util.extend", "pane.Base", "util.math.areEqual", "util.math.areEqualPaths"], function(i, t, e, n, a, s) {
      function r(i, t) {
        r.superclass.constructor.call(this, i, t), t = e({
          margin: 0
        }, t), this._margin = t.margin, this._mapSizeHalf = this._calcMapSizeHalf(), this._viewport = null, this._globalOriginOffset = this._calculateOriginOffset(i.getGlobalPixelCenter()), this._mapListeners = i.events.group().add("actionbegin", this.onActionBegin, this).add("actiontick", this.onActionTick, this).add("actionend", this.onActionEnd, this).add("actionrender", this.onActionRender, this).add("sizechange", this._onMapSizeChange, this)
      }
      t(r, n, {
        getMapSizeHalf: function() {
          return this._mapSizeHalf
        },
        getOriginOffset: function() {
          return this._globalOriginOffset
        },
        updateClientPixels: function(i) {
          var t = this._calculateOriginOffset(i);
          a(this._globalOriginOffset, t) || (this._globalOriginOffset = t, this.events.fire("clientpixelschange"))
        },
        getViewport: function() {
          return this._viewport || (this._viewport = this.calcViewport())
        },
        calcViewport: function() {
          return [
            [-this._margin, -this._margin],
            [2 * this._mapSizeHalf[0] + this._margin, 2 * this._mapSizeHalf[1] + this._margin]
          ]
        },
        updateViewport: function() {
          var i = this._viewport;
          this._viewport = this.calcViewport(), (i && !this._viewport || !i && this._viewport || i && this._viewport && !s(i, this._viewport)) && this.events.fire("viewportchange")
        },
        toClientPixels: function(i) {
          var t = this._globalOriginOffset;
          return [i[0] - t[0], i[1] - t[1]]
        },
        fromClientPixels: function(i) {
          var t = this._globalOriginOffset;
          return [i[0] + t[0], i[1] + t[1]]
        },
        destroy: function() {
          this._mapListeners.removeAll()
        },
        onActionRender: function() {},
        _onMapSizeChange: function() {
          this._mapSizeHalf = this._calcMapSizeHalf(), this.updateClientPixels(this.getMap().getGlobalPixelCenter()), this.updateViewport(), this.events.fire("panesizechange")
        },
        _calcMapSizeHalf: function() {
          var i = this.getMap().container.getSize();
          return [i[0] / 2, i[1] / 2]
        },
        _calculateOriginOffset: function(i) {
          return [Math.round(i[0]) - this._mapSizeHalf[0], Math.round(i[1]) - this._mapSizeHalf[1]]
        }
      }), i(r)
    });
  }],
  ['*)', function(ym) {
    ym.modules.define("pane.BaseMovableContainer", ["util.defineClass", "pane.BaseContainer"], function(e, n, s) {
      function t(e, n) {
        t.superclass.constructor.call(this, e, n)
      }
      n(t, s, {
        calcViewport: function() {
          var e = t.superclass.calcViewport.call(this),
            n = this.getOffset();
          return e[0][0] -= n[0], e[0][1] -= n[1], e[1][0] -= n[0], e[1][1] -= n[1], e
        }
      }), e(t)
    });
  }],
  ['08', function(ym) {
    ym.modules.define("pane.controls.css", ["pane-controls-css"], function(n) {
      n({})
    });
  }],
  ['6E', function(ym) {
    ym.modules.define("pane.EventsPane", function(e) {
      var t = ["util.defineClass", "util.extend", "util.dom.style", "util.cursor.Manager", "pane.Base", "interactivityModel.EventController", "interactivityModel.transparent", "util.css"];
      return (e.env.browser.isIE || e.env.browser.isEdge) && t.push("pane.eventsPane.ie.css"), t
    }, function(e, t, n, s, r, a, i, l, c) {
      function o(e, t) {
        t = n({
          className: c.addPrefix("events-pane"),
          css: {
            width: "100%",
            height: "100%"
          },
          patch: {
            selectable: !1
          },
          transparent: !1,
          checkContextMenu: !0
        }, t), o.superclass.constructor.call(this, e, t), this.cursors = new r(this.getElement()), t.transparent && this.events.addController(new i(l))
      }
      t(o, a), e(o)
    });
  }],
  ['*:', function(ym) {
    ym.modules.define("pane.movable.TransformPane", ["util.defineClass", "pane.BaseMovableContainer", "util.extend", "graphics.renderManager", "util.scheduler.manager", "util.scheduler.world", "util.tailThrottle"], function(t, e, i, s, o, n, r, h) {
      function a(t, e) {
        a.superclass.constructor.call(this, t, e), e = s({
          zoomSensitivity: 1e-5,
          zoomThreshold: .8
        }, e), this._zoomSensitivity = e.zoomSensitivity, this._zoomThreshold = e.zoomThreshold, this._zoom = t.getZoom(), this._actionStartZoom = 0, this._actionStartPosition = 0, this._position = t.getGlobalPixelCenter(), this._offset = [0, 0], this._shedulerProcess = null, this._renderManager = o.getContainer(this), this._restartDebounce1 = h(200, this._restartLayer, this), this._restartDebounce2 = h(600, this._restartLayer, this), this._longActionDebounce = h(2e3, this._restartLayer, this), this._updateviewportDebounce = h(200, this.updateViewport, this)
      }
      var c = .7;
      e(a, i, {
        getZoom: function() {
          return this._zoom
        },
        getOffset: function() {
          return this._offset
        },
        getPosition: function() {
          return this._position
        },
        onActionBegin: function() {
          this.events.fire("actionbegin")
        },
        onActionTick: function(t) {
          this._stopSheduler();
          var e = t.get("tick");
          e.duration ? this._shedulerProcess = n.schedule("processing", function() {
            this._applyTickState(this.getMap().action.getCurrentState(), !0), this._longActionDebounce(), this.events.fire("rendertick")
          }, this, {
            duration: e.duration
          }) : this._applyTickState(e)
        },
        onActionRender: function() {
          this.events.fire("rendertick")
        },
        updateClientPixels: function(t) {
          this._position = t, a.superclass.updateClientPixels.call(this, t)
        },
        onActionEnd: function(t) {
          this._stopSheduler(), this._resetOffset(), this._zoom = this.getMap().getZoom(), this.updateClientPixels(this.getMap().getGlobalPixelCenter()), this.updateViewport(), this.events.fire("actionend"), this.events.fire("rendertick")
        },
        _restart: function() {
          r.isStopped() ? this._restartDebounce2() : this._restartDebounce1()
        },
        _restartLayer: function() {
          this._actionStartZoom = 0, this._actionStartPosition = 0, this.events.fire("actionrestart")
        },
        destroy: function() {
          this._stopSheduler(), a.superclass.destroy.call(this)
        },
        _applyTickState: function(t, e) {
          Math.abs(t.zoom - this._zoom) < this._zoomSensitivity ? this._updateViewport(t, e) : this._updateZoom(t, e), this.events.fire("actiontick"), this.events.fire("rendertock")
        },
        _updateViewport: function(t, e) {
          var i = Math.pow(2, t.zoom - this._zoom),
            s = [t.globalPixelCenter[0] / i, t.globalPixelCenter[1] / i],
            o = this.getOriginOffset(),
            n = this.getMapSizeHalf(),
            r = [n[0] * c, n[1] * c],
            h = [o[0] + n[0] - s[0], o[1] + n[1] - s[1]],
            a = e ? 4 : 1,
            u = [Math.round(h[0] * a) / a, Math.round(h[1] * a) / a];
          this._actionStartPosition || (this._actionStartPosition = h), u[0] == this._offset[0] && u[1] == this._offset[1] || (this._offset = u, (Math.abs(this._actionStartPosition[0] - h[0]) > r[0] || Math.abs(this._actionStartPosition[1] - h[1]) > r[1]) && this._restart(), this._updateviewportDebounce())
        },
        _updateZoom: function(t) {
          this._resetOffset(), this._zoom = t.zoom, this.updateClientPixels(t.globalPixelCenter), this.events.fire("zoomchange"), this._actionStartZoom ? Math.abs(this._actionStartZoom - t.zoom) > this._zoomThreshold && this._restart() : this._actionStartZoom = t.zoom
        },
        _resetOffset: function() {
          (this._offset[0] || this._offset[1]) && (this._offset = [0, 0])
        },
        _stopSheduler: function() {
          this._shedulerProcess && (this._shedulerProcess.stop(), this._shedulerProcess = null)
        }
      }), t(a)
    });
  }],
  ['*@', function(ym) {
    ym.modules.define("pane.movable.TransitionPane", ["util.defineClass", "pane.BaseMovableContainer", "util.extend", "util.dom.style", "domEvent.manager"], function(t, i, n, e, s, o) {
      function a(t, i) {
        a.superclass.constructor.call(this, t, i), i = e({
          zoomSensitivity: 1e-5
        }, i), this._zoomSensitivity = i.zoomSensitivity, this._zoom = t.getZoom(), this._offset = [0, 0], this._inAction = !1, this._nowTransiting = !1, c || this._applyTransition({
          offset: [0, 0],
          use3D: !0
        }, 0), "Presto" == r.engine && this.stopTransition(), o.add(this.getElement(), "transitionend", this._onTransitionEnd, this)
      }
      var r = ym.env.browser,
        h = r.isMobile || r.isTablet,
        l = r.osFamily,
        c = "iOS" == l && h;
      i(a, n, {
        getZoom: function() {
          return this._zoom
        },
        getOffset: function() {
          return this._offset
        },
        destroy: function() {
          o.remove(this.getElement(), "transitionend", this._onTransitionEnd, this), a.superclass.destroy.call(this)
        },
        onActionBegin: function() {
          this._inAction = !0, this.events.fire("actionbegin")
        },
        onActionTick: function(t) {
          var i = t.get("tick");
          this._nowTransiting && this.stopTransition(), this._lastTick = i, this._applyTick(i), i.duration || this._check(), this.events.fire("actiontick"), this.events.fire("rendertick")
        },
        onActionEnd: function() {
          this._nowTransiting && this.stopTransition(), this._zoom = this.getMap().getZoom(), this._offset = [0, 0], "Presto" == r.engine && this.getMap().container.getElement().removeChild(this.getElement()), this._applyTransition({
            offset: [0, 0],
            use3D: !0
          }, 0), "Presto" == r.engine && this.getMap().container.getElement().appendChild(this.getElement()), this.updateClientPixels(this.getMap().getGlobalPixelCenter()), this.updateViewport(), this.events.fire("actionend"), this.events.fire("rendertick"), this._inAction = !1
        },
        stopTransition: function() {
          this._nowTransiting = !1, s.css(this.getElement(), {
            transitionProperty: "",
            transitionDuration: "0ms"
          });
          this.getElement().parentNode ? this.getElement().parentNode.clientLeft : 0
        },
        _applyTick: function(t) {
          this._applyTransition(this._animatorTransition(t), t.duration, t.timingFunction)
        },
        _animatorTransition: function(t) {
          var i = Math.pow(2, t.zoom - this._zoom),
            n = this.getOriginOffset(),
            e = this.getMapSizeHalf(),
            s = [t.globalPixelCenter[0] / i, t.globalPixelCenter[1] / i],
            o = [e[0] * i - e[0], e[1] * i - e[1]];
          return {
            offset: [Math.round(i * (n[0] + e[0] - s[0]) - o[0]), Math.round(i * (n[1] + e[1] - s[1]) - o[1])],
            scale: i,
            use3D: !0
          }
        },
        _applyTransition: function(t, i, n) {
          this.stopTransition(), i > 0 ? (this._nowTransiting = !0, s.patch(this.getElement(), {
            transform: t,
            transitionDuration: i + "ms",
            transitionProperty: ym.supports.css.checkTransitionProperty("transform"),
            transitionTimingFunction: n || "linear"
          })) : s.patch(this.getElement(), {
            transform: t,
            transitionDuration: i + "ms"
          })
        },
        _check: function() {
          if (this._inAction) {
            var t = this.getMap().action.getCurrentState(),
              i = this.getOriginOffset(),
              n = this.getMapSizeHalf(),
              e = t.globalPixelCenter,
              s = [i[0] + n[0] - e[0], i[1] + n[1] - e[1]],
              o = Math.floor(t.zoom) != Math.floor(this._zoom),
              a = Math.abs(s[0] - this._offset[0]) > this._margin || Math.abs(s[1] - this._offset[1]) > this._margin;
            a && !o && Math.abs(t.zoom - this._zoom) < this._zoomSensitivity && (this._offset = s, this.updateViewport())
          }
        },
        _onTransitionEnd: function(t) {
          t.get("target") == this.getElement() && (this._nowTransiting = !1, this._lastTick || this._check())
        }
      }), t(a)
    });
  }],
  ['6F', function(ym) {
    ym.modules.define("pane.MovablePane", function(n) {
      return ["util.defineClass", n.env.browser.transformTransition ? "pane.movable.TransitionPane" : "pane.movable.StepwisePane"]
    }, function(n, e, a) {
      function o(n, e) {
        o.superclass.constructor.call(this, n, e)
      }
      e(o, a), n(o)
    });
  }],
  ['6K', function(ym) {
    ym.modules.define("pane.StaticPane", ["util.defineClass", "pane.BaseContainer"], function(t, e, i) {
      function n(t, e) {
        n.superclass.constructor.call(this, t, e), this._zoom = t.getZoom()
      }
      e(n, i, {
        getZoom: function() {
          return this._zoom
        },
        onActionBegin: function() {
          this.events.fire("actionbegin")
        },
        onActionTick: function(t) {
          var e = t.get("tick");
          this._zoom != e.zoom && (this._zoom = e.zoom, this.events.fire("zoomchange"), this.updateClientPixels(e.globalPixelCenter)), this.events.fire("actiontick")
        },
        onActionEnd: function() {
          this._zoom = this.getMap().getZoom(), this.updateClientPixels(this.getMap().getGlobalPixelCenter()), this.events.fire("actionend")
        },
        destroy: function() {
          this.getMap().events.remove("boundschange", this._onMapBoundsChange, this), n.superclass.destroy.call(this)
        }
      }), t(n)
    });
  }],
  ['.v', function(ym) {
    ym.modules.define('placemark', ['system.provideCss'], function(provide, provideCss) {
      provideCss(".ymaps-2-1-42-placemark{position:absolute;z-index:1;display:block;height:28px;background-repeat:repeat-x;background-position:0 -60px;background-size:auto!important}.ymaps-2-1-42-placemark__content{position:relative;z-index:5;display:block;width:auto;height:27px;margin:0 -3px;text-align:center;white-space:nowrap;color:#000;font:13px Arial,sans-serif}.ymaps-2-1-42-placemark__content-inner{display:block;overflow:hidden;margin-top:6px;margin-left:5px;margin-right:5px;height:15px}.ymaps-2-1-42-placemark__content-inner>*{display:block}.ymaps-2-1-42-placemark_state_active .ymaps-2-1-42-placemark__content{margin-right:-9px}.ymaps-2-1-42-placemark__l{width:13px}.ymaps-2-1-42-placemark__l,.ymaps-2-1-42-placemark__r{position:absolute;z-index:4;display:block;height:27px}.ymaps-2-1-42-placemark__l{left:-13px;background-position:0 0}.ymaps-2-1-42-placemark__r{right:-14px;width:14px;background-position:-14px 0}.ymaps-2-1-42-placemark_state_active .ymaps-2-1-42-placemark__r{right:-26px;width:26px;height:41px;background-position:-80px 0}", provide);
    });
  }],
  ['$L', function(ym) {
    ym.modules.define("Placemark", ["util.defineClass", "GeoObject"], function(e, t, n) {
      function o(e, t, n) {
        o.superclass.constructor.call(this, {
          geometry: i(e),
          properties: t
        }, n)
      }

      function i(e) {
        return e && "undefined" == typeof e.length ? e : {
          type: "Point",
          coordinates: e
        }
      }
      t(o, n), e(o)
    });
  }],
  ['3)', function(ym) {
    ym.modules.define("placemark_theme", function(e) {
      return [this.name + (e.env.browser.oldIE ? ".ie8" : ".standards")]
    }, function(e) {
      e({})
    });
  }],
  ['.D', function(ym) {
    ym.modules.define('placemark_theme.standards', ['system.provideCss'], function(provide, provideCss) {
      provideCss(".ymaps-2-1-42-placemark_theme_black,.ymaps-2-1-42-placemark_theme_black .ymaps-2-1-42-placemark__l,.ymaps-2-1-42-placemark_type_blank.ymaps-2-1-42-placemark_theme_black .ymaps-2-1-42-placemark__r{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTIwIDEwMCI+PHN0eWxlPi53aGl0ZV9vcGFjaXR5e2ZpbGw6I2ZmZjtmaWxsLW9wYWNpdHk6Ljh9LmN1c3RvbV9jb2xvcl9zb2xpZHtmaWxsOiM1OTU5NTl9LndoaXRlX3NvbGlke2ZpbGw6I2ZmZn0uYmxhY2tfc29saWRfZmluaXNoLC5ibGFja19zb2xpZF9zdGFydHtzdG9wLWNvbG9yOiMwMDB9LmJsYWNrX3NvbGlkX2ZpbmlzaHtzdG9wLW9wYWNpdHk6MH0uc2hhZG93e29wYWNpdHk6LjV9PC9zdHlsZT48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgMTMuNUMwIDYgNiAwIDEzLjUgMFMyNyA2IDI3IDEzLjUgMjAuOTYgMjcgMTMuNSAyNyAwIDIxIDAgMTMuNXptMjIgMGE4LjUgOC41IDAgMSAwLTE2Ljk5LS4wMUE4LjUgOC41IDAgMCAwIDIyIDEzLjV6Ii8+PGNpcmNsZSBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBjeD0iMTMuNSIgY3k9IjEzLjUiIHI9IjExLjUiLz48Y2lyY2xlIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgY3g9IjEzLjUiIGN5PSIxMy41IiByPSI4LjUiLz48Zz48bGluZWFyR3JhZGllbnQgaWQ9InNoYWRvdy1ncmFkaWVudCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSItMzQwIiB5MT0iMzkxLjkiIHgyPSItMzM5LjEiIHkyPSIzOTIuNyIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgyMS4yMTYxIDAgMCAtMjEuNzg3OSA3MjYyLjA0IDg1NzUuMTEpIj48c3RvcCBvZmZzZXQ9IjAiIGNsYXNzPSJibGFja19zb2xpZF9zdGFydCIvPjxzdG9wIG9mZnNldD0iMSIgY2xhc3M9ImJsYWNrX3NvbGlkX2ZpbmlzaCIvPjwvbGluZWFyR3JhZGllbnQ+PHBhdGggY2xhc3M9InNoYWRvdyIgZmlsbD0idXJsKCNzaGFkb3ctZ3JhZGllbnQpIiBkPSJNNDguNzIgMzkuN2M0LjcxLTIuNCAxNy44Mi0xMS41MiAxOC4zLTExLjk4LjU2LS41MiAxLjA3LTEuMDYgMS41LTEuNjIgMy00IDEuMTEtNy42Mi00LjQ0LTguMDMtLjQ3LS4wMy0xLjA2LS4xLTEuNjgtLjE2LS45NiAzLjQzLTMuMjIgNy42LTYuNDMgMTIuMzNhMTE0LjEyIDExNC4xMiAwIDAgMS02LjE0IDguMmwtLjU0LjY3Yy0uMTIuMTUtLjI3LjMyLS40Ny41LS4wMy0uMDEtLjAyLS4wMS0uMTIuMDZoLjAyeiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNMzYgMTMuNUMzNiA2IDQyIDAgNDkuNSAwYTEzLjQ0IDEzLjQ0IDAgMCAxIDEzLjMgMTUuODJsLjAyLjE2LS4wNC4yM2MtLjYgMy43LTMuMDYgOC40Ny02LjggMTRhMTE4LjM0IDExOC4zNCAwIDAgMS02LjE0IDguMjJjLS4yNS4zLS40NC41Mi0uNTUuN2EzLjU5IDMuNTkgMCAwIDEtMS4yLjk3Yy0uNC4yLS44Ni4yNy0xLjQuMmwtLjIxLS4wNGEyLjI5IDIuMjkgMCAwIDEtMS42Ni0xLjY4Yy0uMS0uNDQtLjEtLjgyIDAtMS4xOSAwLS4wNy4wMi0uMTMuMDQtLjE5bDIuNzctMTAuMjZBMTMuNjEgMTMuNjEgMCAwIDEgMzYgMTMuNXoiLz48cGF0aCBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBkPSJNMzggMTMuNUMzOCA3LjEgNDMuMSAyIDQ5LjUgMmExMS40NCAxMS40NCAwIDAgMSAxMS4yOCAxMy43di4xNUM1OS41IDIzLjg1IDQ3LjcgMzcuOCA0Ny43IDM3LjhzLS4zOC41Mi0uNzMuNGMtLjM3LS4xLS4yLS41Ni0uMi0uNTZsMy40Mi0xMi43MWMtLjIxLjA3LS40OS4wNy0uNjkuMDdDNDMuMTUgMjUgMzggMTkuOSAzOCAxMy41eiIvPjxjaXJjbGUgY2xhc3M9IndoaXRlX3NvbGlkIiBjeD0iNDkuNSIgY3k9IjEzLjUiIHI9IjguNSIvPjwvZz48Zz48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgNjBoMTIwdjJIMHpNMCA4NWgxMjB2MkgweiIvPjxwYXRoIGNsYXNzPSJjdXN0b21fY29sb3Jfc29saWQiIGQ9Ik0wIDYyaDEyMHYzSDB6TTAgODJoMTIwdjNIMHoiLz48cGF0aCBjbGFzcz0id2hpdGVfc29saWQiIGQ9Ik0wIDY1aDEyMHYxN0gweiIvPjwvZz48L3N2Zz4=)}.ymaps-2-1-42-placemark_theme_black .ymaps-2-1-42-placemark__r{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTIwIDEwMCI+PHN0eWxlPi53aGl0ZV9vcGFjaXR5e2ZpbGw6I2ZmZjtmaWxsLW9wYWNpdHk6Ljh9LmN1c3RvbV9jb2xvcl9zb2xpZHtmaWxsOiM1OTU5NTl9LndoaXRlX3NvbGlke2ZpbGw6I2ZmZn0uYmxhY2tfc29saWRfZmluaXNoLC5ibGFja19zb2xpZF9zdGFydHtzdG9wLWNvbG9yOiMwMDB9LmJsYWNrX3NvbGlkX2ZpbmlzaHtzdG9wLW9wYWNpdHk6MH0uc2hhZG93e29wYWNpdHk6LjV9PC9zdHlsZT48bGluZWFyR3JhZGllbnQgaWQ9InNoYWRvdy1ncmFkaWVudDIiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iLTYwOC40IiB5MT0iMzU0LjEiIHgyPSItNjA3LjQiIHkyPSIzNTQuOSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgyMS4yMTYxIDAgMCAtMjEuNzg3OSAxMjk5MS4xNiA3NzUyLjY0KSI+PHN0b3Agb2Zmc2V0PSIwIiBjbGFzcz0iYmxhY2tfc29saWRfc3RhcnQiLz48c3RvcCBvZmZzZXQ9IjEiIGNsYXNzPSJibGFja19zb2xpZF9maW5pc2giLz48L2xpbmVhckdyYWRpZW50PjxwYXRoIGNsYXNzPSJzaGFkb3ciIGZpbGw9InVybCgjc2hhZG93LWdyYWRpZW50MikiIGQ9Ik04NC43MiAzOS43YzQuNy0yLjQgMTcuODItMTEuNTIgMTguMy0xMS45OGExMy44IDEzLjggMCAwIDAgMS41LTEuNjJjMy00IDEuMTEtNy42Mi00LjQ0LTguMDMtLjQ3LS4wMy0xLjA2LS4xLTEuNjgtLjE2LS45NiAzLjQzLTMuMjIgNy42LTYuNDMgMTIuMzNhMTE2Ljc5IDExNi43OSAwIDAgMS02LjE0IDguMmwtLjU1LjY3Yy0uMTEuMTUtLjI3LjMyLS40Ni41LS4wMy0uMDEtLjAyLS4wMS0uMTIuMDZoLjAyeiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNODAgMjV2MmgzLjZsLTIuNzQgMTAuMTNhMi41MyAyLjUzIDAgMCAwLS4wNSAxLjM4Yy4yLjguOCAxLjUgMS43IDEuNjhoLjJjLjU0LjEgMSAwIDEuNC0uMTcuMjYtLjEyLjUtLjI5LjczLS40OC4yLS4xNy4zNS0uMzQuNDYtLjVsLjU1LS42NWMuNDYtLjU3Ljk4LTEuMiAxLjUyLTEuOSAxLjU3LTIuMDIgMy4xNS00LjE1IDQuNjItNi4zMiAzLjc1LTUuNTIgNi4yMS0xMC4zIDYuOC0xNGwuMDQtLjIzLS4wMy0uMTJBMTMuNDQgMTMuNDQgMCAwIDAgODUuNSAwSDgwdjIiLz48cGF0aCBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBkPSJNODAgMjJ2M2g1LjVjLjI0IDAgLjQ4IDAgLjcxLS4wMmwtMy40MyAxMi43cy0uMTYuNS4yLjZjLjM1LjEuNzMtLjQuNzMtLjRTOTUuNTEgMjMuOSA5Ni44IDE1Ljg5bC0uMDItLjE1QTExLjQ0IDExLjQ0IDAgMCAwIDg1LjUgMkg4MHYzIi8+PHBhdGggY2xhc3M9IndoaXRlX3NvbGlkIiBkPSJNODUuNSA1SDgwdjE3aDUuNWE4LjUgOC41IDAgMCAwIDAtMTd6Ii8+PC9zdmc+)}.ymaps-2-1-42-placemark_theme_blue,.ymaps-2-1-42-placemark_theme_blue .ymaps-2-1-42-placemark__l,.ymaps-2-1-42-placemark_type_blank.ymaps-2-1-42-placemark_theme_blue .ymaps-2-1-42-placemark__r{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTIwIDEwMCI+PHN0eWxlPi53aGl0ZV9vcGFjaXR5e2ZpbGw6I2ZmZjtmaWxsLW9wYWNpdHk6Ljh9LmN1c3RvbV9jb2xvcl9zb2xpZHtmaWxsOiMxZTk4ZmZ9LndoaXRlX3NvbGlke2ZpbGw6I2ZmZn0uYmxhY2tfc29saWRfZmluaXNoLC5ibGFja19zb2xpZF9zdGFydHtzdG9wLWNvbG9yOiMwMDB9LmJsYWNrX3NvbGlkX2ZpbmlzaHtzdG9wLW9wYWNpdHk6MH0uc2hhZG93e29wYWNpdHk6LjV9PC9zdHlsZT48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgMTMuNUMwIDYgNiAwIDEzLjUgMFMyNyA2IDI3IDEzLjUgMjAuOTYgMjcgMTMuNSAyNyAwIDIxIDAgMTMuNXptMjIgMGE4LjUgOC41IDAgMSAwLTE2Ljk5LS4wMUE4LjUgOC41IDAgMCAwIDIyIDEzLjV6Ii8+PGNpcmNsZSBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBjeD0iMTMuNSIgY3k9IjEzLjUiIHI9IjExLjUiLz48Y2lyY2xlIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgY3g9IjEzLjUiIGN5PSIxMy41IiByPSI4LjUiLz48Zz48bGluZWFyR3JhZGllbnQgaWQ9InNoYWRvdy1ncmFkaWVudCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSItMzQwIiB5MT0iMzkxLjkiIHgyPSItMzM5LjEiIHkyPSIzOTIuNyIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgyMS4yMTYxIDAgMCAtMjEuNzg3OSA3MjYyLjA0IDg1NzUuMTEpIj48c3RvcCBvZmZzZXQ9IjAiIGNsYXNzPSJibGFja19zb2xpZF9zdGFydCIvPjxzdG9wIG9mZnNldD0iMSIgY2xhc3M9ImJsYWNrX3NvbGlkX2ZpbmlzaCIvPjwvbGluZWFyR3JhZGllbnQ+PHBhdGggY2xhc3M9InNoYWRvdyIgZmlsbD0idXJsKCNzaGFkb3ctZ3JhZGllbnQpIiBkPSJNNDguNzIgMzkuN2M0LjcxLTIuNCAxNy44Mi0xMS41MiAxOC4zLTExLjk4LjU2LS41MiAxLjA3LTEuMDYgMS41LTEuNjIgMy00IDEuMTEtNy42Mi00LjQ0LTguMDMtLjQ3LS4wMy0xLjA2LS4xLTEuNjgtLjE2LS45NiAzLjQzLTMuMjIgNy42LTYuNDMgMTIuMzNhMTE0LjEyIDExNC4xMiAwIDAgMS02LjE0IDguMmwtLjU0LjY3Yy0uMTIuMTUtLjI3LjMyLS40Ny41LS4wMy0uMDEtLjAyLS4wMS0uMTIuMDZoLjAyeiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNMzYgMTMuNUMzNiA2IDQyIDAgNDkuNSAwYTEzLjQ0IDEzLjQ0IDAgMCAxIDEzLjMgMTUuODJsLjAyLjE2LS4wNC4yM2MtLjYgMy43LTMuMDYgOC40Ny02LjggMTRhMTE4LjM0IDExOC4zNCAwIDAgMS02LjE0IDguMjJjLS4yNS4zLS40NC41Mi0uNTUuN2EzLjU5IDMuNTkgMCAwIDEtMS4yLjk3Yy0uNC4yLS44Ni4yNy0xLjQuMmwtLjIxLS4wNGEyLjI5IDIuMjkgMCAwIDEtMS42Ni0xLjY4Yy0uMS0uNDQtLjEtLjgyIDAtMS4xOSAwLS4wNy4wMi0uMTMuMDQtLjE5bDIuNzctMTAuMjZBMTMuNjEgMTMuNjEgMCAwIDEgMzYgMTMuNXoiLz48cGF0aCBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBkPSJNMzggMTMuNUMzOCA3LjEgNDMuMSAyIDQ5LjUgMmExMS40NCAxMS40NCAwIDAgMSAxMS4yOCAxMy43di4xNUM1OS41IDIzLjg1IDQ3LjcgMzcuOCA0Ny43IDM3LjhzLS4zOC41Mi0uNzMuNGMtLjM3LS4xLS4yLS41Ni0uMi0uNTZsMy40Mi0xMi43MWMtLjIxLjA3LS40OS4wNy0uNjkuMDdDNDMuMTUgMjUgMzggMTkuOSAzOCAxMy41eiIvPjxjaXJjbGUgY2xhc3M9IndoaXRlX3NvbGlkIiBjeD0iNDkuNSIgY3k9IjEzLjUiIHI9IjguNSIvPjwvZz48Zz48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgNjBoMTIwdjJIMHpNMCA4NWgxMjB2MkgweiIvPjxwYXRoIGNsYXNzPSJjdXN0b21fY29sb3Jfc29saWQiIGQ9Ik0wIDYyaDEyMHYzSDB6TTAgODJoMTIwdjNIMHoiLz48cGF0aCBjbGFzcz0id2hpdGVfc29saWQiIGQ9Ik0wIDY1aDEyMHYxN0gweiIvPjwvZz48L3N2Zz4=)}.ymaps-2-1-42-placemark_theme_blue .ymaps-2-1-42-placemark__r{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTIwIDEwMCI+PHN0eWxlPi53aGl0ZV9vcGFjaXR5e2ZpbGw6I2ZmZjtmaWxsLW9wYWNpdHk6Ljh9LmN1c3RvbV9jb2xvcl9zb2xpZHtmaWxsOiMxZTk4ZmZ9LndoaXRlX3NvbGlke2ZpbGw6I2ZmZn0uYmxhY2tfc29saWRfZmluaXNoLC5ibGFja19zb2xpZF9zdGFydHtzdG9wLWNvbG9yOiMwMDB9LmJsYWNrX3NvbGlkX2ZpbmlzaHtzdG9wLW9wYWNpdHk6MH0uc2hhZG93e29wYWNpdHk6LjV9PC9zdHlsZT48bGluZWFyR3JhZGllbnQgaWQ9InNoYWRvdy1ncmFkaWVudDIiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iLTYwOC40IiB5MT0iMzU0LjEiIHgyPSItNjA3LjQiIHkyPSIzNTQuOSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgyMS4yMTYxIDAgMCAtMjEuNzg3OSAxMjk5MS4xNiA3NzUyLjY0KSI+PHN0b3Agb2Zmc2V0PSIwIiBjbGFzcz0iYmxhY2tfc29saWRfc3RhcnQiLz48c3RvcCBvZmZzZXQ9IjEiIGNsYXNzPSJibGFja19zb2xpZF9maW5pc2giLz48L2xpbmVhckdyYWRpZW50PjxwYXRoIGNsYXNzPSJzaGFkb3ciIGZpbGw9InVybCgjc2hhZG93LWdyYWRpZW50MikiIGQ9Ik04NC43MiAzOS43YzQuNy0yLjQgMTcuODItMTEuNTIgMTguMy0xMS45OGExMy44IDEzLjggMCAwIDAgMS41LTEuNjJjMy00IDEuMTEtNy42Mi00LjQ0LTguMDMtLjQ3LS4wMy0xLjA2LS4xLTEuNjgtLjE2LS45NiAzLjQzLTMuMjIgNy42LTYuNDMgMTIuMzNhMTE2Ljc5IDExNi43OSAwIDAgMS02LjE0IDguMmwtLjU1LjY3Yy0uMTEuMTUtLjI3LjMyLS40Ni41LS4wMy0uMDEtLjAyLS4wMS0uMTIuMDZoLjAyeiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNODAgMjV2MmgzLjZsLTIuNzQgMTAuMTNhMi41MyAyLjUzIDAgMCAwLS4wNSAxLjM4Yy4yLjguOCAxLjUgMS43IDEuNjhoLjJjLjU0LjEgMSAwIDEuNC0uMTcuMjYtLjEyLjUtLjI5LjczLS40OC4yLS4xNy4zNS0uMzQuNDYtLjVsLjU1LS42NWMuNDYtLjU3Ljk4LTEuMiAxLjUyLTEuOSAxLjU3LTIuMDIgMy4xNS00LjE1IDQuNjItNi4zMiAzLjc1LTUuNTIgNi4yMS0xMC4zIDYuOC0xNGwuMDQtLjIzLS4wMy0uMTJBMTMuNDQgMTMuNDQgMCAwIDAgODUuNSAwSDgwdjIiLz48cGF0aCBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBkPSJNODAgMjJ2M2g1LjVjLjI0IDAgLjQ4IDAgLjcxLS4wMmwtMy40MyAxMi43cy0uMTYuNS4yLjZjLjM1LjEuNzMtLjQuNzMtLjRTOTUuNTEgMjMuOSA5Ni44IDE1Ljg5bC0uMDItLjE1QTExLjQ0IDExLjQ0IDAgMCAwIDg1LjUgMkg4MHYzIi8+PHBhdGggY2xhc3M9IndoaXRlX3NvbGlkIiBkPSJNODUuNSA1SDgwdjE3aDUuNWE4LjUgOC41IDAgMCAwIDAtMTd6Ii8+PC9zdmc+)}.ymaps-2-1-42-placemark_theme_brown,.ymaps-2-1-42-placemark_theme_brown .ymaps-2-1-42-placemark__l,.ymaps-2-1-42-placemark_type_blank.ymaps-2-1-42-placemark_theme_brown .ymaps-2-1-42-placemark__r{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTIwIDEwMCI+PHN0eWxlPi53aGl0ZV9vcGFjaXR5e2ZpbGw6I2ZmZjtmaWxsLW9wYWNpdHk6Ljh9LmN1c3RvbV9jb2xvcl9zb2xpZHtmaWxsOiM3OTNkMGV9LndoaXRlX3NvbGlke2ZpbGw6I2ZmZn0uYmxhY2tfc29saWRfZmluaXNoLC5ibGFja19zb2xpZF9zdGFydHtzdG9wLWNvbG9yOiMwMDB9LmJsYWNrX3NvbGlkX2ZpbmlzaHtzdG9wLW9wYWNpdHk6MH0uc2hhZG93e29wYWNpdHk6LjV9PC9zdHlsZT48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgMTMuNUMwIDYgNiAwIDEzLjUgMFMyNyA2IDI3IDEzLjUgMjAuOTYgMjcgMTMuNSAyNyAwIDIxIDAgMTMuNXptMjIgMGE4LjUgOC41IDAgMSAwLTE2Ljk5LS4wMUE4LjUgOC41IDAgMCAwIDIyIDEzLjV6Ii8+PGNpcmNsZSBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBjeD0iMTMuNSIgY3k9IjEzLjUiIHI9IjExLjUiLz48Y2lyY2xlIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgY3g9IjEzLjUiIGN5PSIxMy41IiByPSI4LjUiLz48Zz48bGluZWFyR3JhZGllbnQgaWQ9InNoYWRvdy1ncmFkaWVudCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSItMzQwIiB5MT0iMzkxLjkiIHgyPSItMzM5LjEiIHkyPSIzOTIuNyIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgyMS4yMTYxIDAgMCAtMjEuNzg3OSA3MjYyLjA0IDg1NzUuMTEpIj48c3RvcCBvZmZzZXQ9IjAiIGNsYXNzPSJibGFja19zb2xpZF9zdGFydCIvPjxzdG9wIG9mZnNldD0iMSIgY2xhc3M9ImJsYWNrX3NvbGlkX2ZpbmlzaCIvPjwvbGluZWFyR3JhZGllbnQ+PHBhdGggY2xhc3M9InNoYWRvdyIgZmlsbD0idXJsKCNzaGFkb3ctZ3JhZGllbnQpIiBkPSJNNDguNzIgMzkuN2M0LjcxLTIuNCAxNy44Mi0xMS41MiAxOC4zLTExLjk4LjU2LS41MiAxLjA3LTEuMDYgMS41LTEuNjIgMy00IDEuMTEtNy42Mi00LjQ0LTguMDMtLjQ3LS4wMy0xLjA2LS4xLTEuNjgtLjE2LS45NiAzLjQzLTMuMjIgNy42LTYuNDMgMTIuMzNhMTE0LjEyIDExNC4xMiAwIDAgMS02LjE0IDguMmwtLjU0LjY3Yy0uMTIuMTUtLjI3LjMyLS40Ny41LS4wMy0uMDEtLjAyLS4wMS0uMTIuMDZoLjAyeiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNMzYgMTMuNUMzNiA2IDQyIDAgNDkuNSAwYTEzLjQ0IDEzLjQ0IDAgMCAxIDEzLjMgMTUuODJsLjAyLjE2LS4wNC4yM2MtLjYgMy43LTMuMDYgOC40Ny02LjggMTRhMTE4LjM0IDExOC4zNCAwIDAgMS02LjE0IDguMjJjLS4yNS4zLS40NC41Mi0uNTUuN2EzLjU5IDMuNTkgMCAwIDEtMS4yLjk3Yy0uNC4yLS44Ni4yNy0xLjQuMmwtLjIxLS4wNGEyLjI5IDIuMjkgMCAwIDEtMS42Ni0xLjY4Yy0uMS0uNDQtLjEtLjgyIDAtMS4xOSAwLS4wNy4wMi0uMTMuMDQtLjE5bDIuNzctMTAuMjZBMTMuNjEgMTMuNjEgMCAwIDEgMzYgMTMuNXoiLz48cGF0aCBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBkPSJNMzggMTMuNUMzOCA3LjEgNDMuMSAyIDQ5LjUgMmExMS40NCAxMS40NCAwIDAgMSAxMS4yOCAxMy43di4xNUM1OS41IDIzLjg1IDQ3LjcgMzcuOCA0Ny43IDM3LjhzLS4zOC41Mi0uNzMuNGMtLjM3LS4xLS4yLS41Ni0uMi0uNTZsMy40Mi0xMi43MWMtLjIxLjA3LS40OS4wNy0uNjkuMDdDNDMuMTUgMjUgMzggMTkuOSAzOCAxMy41eiIvPjxjaXJjbGUgY2xhc3M9IndoaXRlX3NvbGlkIiBjeD0iNDkuNSIgY3k9IjEzLjUiIHI9IjguNSIvPjwvZz48Zz48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgNjBoMTIwdjJIMHpNMCA4NWgxMjB2MkgweiIvPjxwYXRoIGNsYXNzPSJjdXN0b21fY29sb3Jfc29saWQiIGQ9Ik0wIDYyaDEyMHYzSDB6TTAgODJoMTIwdjNIMHoiLz48cGF0aCBjbGFzcz0id2hpdGVfc29saWQiIGQ9Ik0wIDY1aDEyMHYxN0gweiIvPjwvZz48L3N2Zz4=)}.ymaps-2-1-42-placemark_theme_brown .ymaps-2-1-42-placemark__r{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTIwIDEwMCI+PHN0eWxlPi53aGl0ZV9vcGFjaXR5e2ZpbGw6I2ZmZjtmaWxsLW9wYWNpdHk6Ljh9LmN1c3RvbV9jb2xvcl9zb2xpZHtmaWxsOiM3OTNkMGV9LndoaXRlX3NvbGlke2ZpbGw6I2ZmZn0uYmxhY2tfc29saWRfZmluaXNoLC5ibGFja19zb2xpZF9zdGFydHtzdG9wLWNvbG9yOiMwMDB9LmJsYWNrX3NvbGlkX2ZpbmlzaHtzdG9wLW9wYWNpdHk6MH0uc2hhZG93e29wYWNpdHk6LjV9PC9zdHlsZT48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgMTMuNUMwIDYgNiAwIDEzLjUgMFMyNyA2IDI3IDEzLjUgMjAuOTYgMjcgMTMuNSAyNyAwIDIxIDAgMTMuNXptMjIgMGE4LjUgOC41IDAgMSAwLTE2Ljk5LS4wMUE4LjUgOC41IDAgMCAwIDIyIDEzLjV6Ii8+PGNpcmNsZSBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBjeD0iMTMuNSIgY3k9IjEzLjUiIHI9IjExLjUiLz48Y2lyY2xlIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgY3g9IjEzLjUiIGN5PSIxMy41IiByPSI4LjUiLz48Zz48bGluZWFyR3JhZGllbnQgaWQ9InNoYWRvdy1ncmFkaWVudDIiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iLTYwOC40IiB5MT0iMzU0LjEiIHgyPSItNjA3LjQiIHkyPSIzNTQuOSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgyMS4yMTYxIDAgMCAtMjEuNzg3OSAxMjk5MS4xNiA3NzUyLjY0KSI+PHN0b3Agb2Zmc2V0PSIwIiBjbGFzcz0iYmxhY2tfc29saWRfc3RhcnQiLz48c3RvcCBvZmZzZXQ9IjEiIGNsYXNzPSJibGFja19zb2xpZF9maW5pc2giLz48L2xpbmVhckdyYWRpZW50PjxwYXRoIGNsYXNzPSJzaGFkb3ciIGZpbGw9InVybCgjc2hhZG93LWdyYWRpZW50MikiIGQ9Ik04NC43MiAzOS43YzQuNy0yLjQgMTcuODItMTEuNTIgMTguMy0xMS45OGExMy44IDEzLjggMCAwIDAgMS41LTEuNjJjMy00IDEuMTEtNy42Mi00LjQ0LTguMDMtLjQ3LS4wMy0xLjA2LS4xLTEuNjgtLjE2LS45NiAzLjQzLTMuMjIgNy42LTYuNDMgMTIuMzNhMTE2Ljc5IDExNi43OSAwIDAgMS02LjE0IDguMmwtLjU1LjY3Yy0uMTEuMTUtLjI3LjMyLS40Ni41LS4wMy0uMDEtLjAyLS4wMS0uMTIuMDZoLjAyeiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNODAgMjV2MmgzLjZsLTIuNzQgMTAuMTNhMi41MyAyLjUzIDAgMCAwLS4wNSAxLjM4Yy4yLjguOCAxLjUgMS43IDEuNjhoLjJjLjU0LjEgMSAwIDEuNC0uMTcuMjYtLjEyLjUtLjI5LjczLS40OC4yLS4xNy4zNS0uMzQuNDYtLjVsLjU1LS42NWMuNDYtLjU3Ljk4LTEuMiAxLjUyLTEuOSAxLjU3LTIuMDIgMy4xNS00LjE1IDQuNjItNi4zMiAzLjc1LTUuNTIgNi4yMS0xMC4zIDYuOC0xNGwuMDQtLjIzLS4wMy0uMTJBMTMuNDQgMTMuNDQgMCAwIDAgODUuNSAwSDgwdjIiLz48cGF0aCBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBkPSJNODAgMjJ2M2g1LjVjLjI0IDAgLjQ4IDAgLjcxLS4wMmwtMy40MyAxMi43cy0uMTYuNS4yLjZjLjM1LjEuNzMtLjQuNzMtLjRTOTUuNTEgMjMuOSA5Ni44IDE1Ljg5bC0uMDItLjE1QTExLjQ0IDExLjQ0IDAgMCAwIDg1LjUgMkg4MHYzIi8+PHBhdGggY2xhc3M9IndoaXRlX3NvbGlkIiBkPSJNODUuNSA1SDgwdjE3aDUuNWE4LjUgOC41IDAgMCAwIDAtMTd6Ii8+PC9nPjxnPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNMCA2MGgxMjB2Mkgwek0wIDg1aDEyMHYySDB6Ii8+PHBhdGggY2xhc3M9ImN1c3RvbV9jb2xvcl9zb2xpZCIgZD0iTTAgNjJoMTIwdjNIMHpNMCA4MmgxMjB2M0gweiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgZD0iTTAgNjVoMTIwdjE3SDB6Ii8+PC9nPjwvc3ZnPg==)}.ymaps-2-1-42-placemark_theme_red,.ymaps-2-1-42-placemark_theme_red .ymaps-2-1-42-placemark__l,.ymaps-2-1-42-placemark_type_blank.ymaps-2-1-42-placemark_theme_red .ymaps-2-1-42-placemark__r{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTIwIDEwMCI+PHN0eWxlPi53aGl0ZV9vcGFjaXR5e2ZpbGw6I2ZmZjtmaWxsLW9wYWNpdHk6Ljh9LmN1c3RvbV9jb2xvcl9zb2xpZHtmaWxsOiNlZDQ1NDN9LndoaXRlX3NvbGlke2ZpbGw6I2ZmZn0uYmxhY2tfc29saWRfZmluaXNoLC5ibGFja19zb2xpZF9zdGFydHtzdG9wLWNvbG9yOiMwMDB9LmJsYWNrX3NvbGlkX2ZpbmlzaHtzdG9wLW9wYWNpdHk6MH0uc2hhZG93e29wYWNpdHk6LjV9PC9zdHlsZT48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgMTMuNUMwIDYgNiAwIDEzLjUgMFMyNyA2IDI3IDEzLjUgMjAuOTYgMjcgMTMuNSAyNyAwIDIxIDAgMTMuNXptMjIgMGE4LjUgOC41IDAgMSAwLTE2Ljk5LS4wMUE4LjUgOC41IDAgMCAwIDIyIDEzLjV6Ii8+PGNpcmNsZSBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBjeD0iMTMuNSIgY3k9IjEzLjUiIHI9IjExLjUiLz48Y2lyY2xlIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgY3g9IjEzLjUiIGN5PSIxMy41IiByPSI4LjUiLz48Zz48bGluZWFyR3JhZGllbnQgaWQ9InNoYWRvdy1ncmFkaWVudCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSItMzQwIiB5MT0iMzkxLjkiIHgyPSItMzM5LjEiIHkyPSIzOTIuNyIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgyMS4yMTYxIDAgMCAtMjEuNzg3OSA3MjYyLjA0IDg1NzUuMTEpIj48c3RvcCBvZmZzZXQ9IjAiIGNsYXNzPSJibGFja19zb2xpZF9zdGFydCIvPjxzdG9wIG9mZnNldD0iMSIgY2xhc3M9ImJsYWNrX3NvbGlkX2ZpbmlzaCIvPjwvbGluZWFyR3JhZGllbnQ+PHBhdGggY2xhc3M9InNoYWRvdyIgZmlsbD0idXJsKCNzaGFkb3ctZ3JhZGllbnQpIiBkPSJNNDguNzIgMzkuN2M0LjcxLTIuNCAxNy44Mi0xMS41MiAxOC4zLTExLjk4LjU2LS41MiAxLjA3LTEuMDYgMS41LTEuNjIgMy00IDEuMTEtNy42Mi00LjQ0LTguMDMtLjQ3LS4wMy0xLjA2LS4xLTEuNjgtLjE2LS45NiAzLjQzLTMuMjIgNy42LTYuNDMgMTIuMzNhMTE0LjEyIDExNC4xMiAwIDAgMS02LjE0IDguMmwtLjU0LjY3Yy0uMTIuMTUtLjI3LjMyLS40Ny41LS4wMy0uMDEtLjAyLS4wMS0uMTIuMDZoLjAyeiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNMzYgMTMuNUMzNiA2IDQyIDAgNDkuNSAwYTEzLjQ0IDEzLjQ0IDAgMCAxIDEzLjMgMTUuODJsLjAyLjE2LS4wNC4yM2MtLjYgMy43LTMuMDYgOC40Ny02LjggMTRhMTE4LjM0IDExOC4zNCAwIDAgMS02LjE0IDguMjJjLS4yNS4zLS40NC41Mi0uNTUuN2EzLjU5IDMuNTkgMCAwIDEtMS4yLjk3Yy0uNC4yLS44Ni4yNy0xLjQuMmwtLjIxLS4wNGEyLjI5IDIuMjkgMCAwIDEtMS42Ni0xLjY4Yy0uMS0uNDQtLjEtLjgyIDAtMS4xOSAwLS4wNy4wMi0uMTMuMDQtLjE5bDIuNzctMTAuMjZBMTMuNjEgMTMuNjEgMCAwIDEgMzYgMTMuNXoiLz48cGF0aCBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBkPSJNMzggMTMuNUMzOCA3LjEgNDMuMSAyIDQ5LjUgMmExMS40NCAxMS40NCAwIDAgMSAxMS4yOCAxMy43di4xNUM1OS41IDIzLjg1IDQ3LjcgMzcuOCA0Ny43IDM3LjhzLS4zOC41Mi0uNzMuNGMtLjM3LS4xLS4yLS41Ni0uMi0uNTZsMy40Mi0xMi43MWMtLjIxLjA3LS40OS4wNy0uNjkuMDdDNDMuMTUgMjUgMzggMTkuOSAzOCAxMy41eiIvPjxjaXJjbGUgY2xhc3M9IndoaXRlX3NvbGlkIiBjeD0iNDkuNSIgY3k9IjEzLjUiIHI9IjguNSIvPjwvZz48Zz48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgNjBoMTIwdjJIMHpNMCA4NWgxMjB2MkgweiIvPjxwYXRoIGNsYXNzPSJjdXN0b21fY29sb3Jfc29saWQiIGQ9Ik0wIDYyaDEyMHYzSDB6TTAgODJoMTIwdjNIMHoiLz48cGF0aCBjbGFzcz0id2hpdGVfc29saWQiIGQ9Ik0wIDY1aDEyMHYxN0gweiIvPjwvZz48L3N2Zz4=)}.ymaps-2-1-42-placemark_theme_red .ymaps-2-1-42-placemark__r{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTIwIDEwMCI+PHN0eWxlPi53aGl0ZV9vcGFjaXR5e2ZpbGw6I2ZmZjtmaWxsLW9wYWNpdHk6Ljh9LmN1c3RvbV9jb2xvcl9zb2xpZHtmaWxsOiNlZDQ1NDN9LndoaXRlX3NvbGlke2ZpbGw6I2ZmZn0uYmxhY2tfc29saWRfZmluaXNoLC5ibGFja19zb2xpZF9zdGFydHtzdG9wLWNvbG9yOiMwMDB9LmJsYWNrX3NvbGlkX2ZpbmlzaHtzdG9wLW9wYWNpdHk6MH0uc2hhZG93e29wYWNpdHk6LjV9PC9zdHlsZT48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgMTMuNUMwIDYgNiAwIDEzLjUgMFMyNyA2IDI3IDEzLjUgMjAuOTYgMjcgMTMuNSAyNyAwIDIxIDAgMTMuNXptMjIgMGE4LjUgOC41IDAgMSAwLTE2Ljk5LS4wMUE4LjUgOC41IDAgMCAwIDIyIDEzLjV6Ii8+PGNpcmNsZSBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBjeD0iMTMuNSIgY3k9IjEzLjUiIHI9IjExLjUiLz48Y2lyY2xlIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgY3g9IjEzLjUiIGN5PSIxMy41IiByPSI4LjUiLz48Zz48bGluZWFyR3JhZGllbnQgaWQ9InNoYWRvdy1ncmFkaWVudDIiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iLTYwOC40IiB5MT0iMzU0LjEiIHgyPSItNjA3LjQiIHkyPSIzNTQuOSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgyMS4yMTYxIDAgMCAtMjEuNzg3OSAxMjk5MS4xNiA3NzUyLjY0KSI+PHN0b3Agb2Zmc2V0PSIwIiBjbGFzcz0iYmxhY2tfc29saWRfc3RhcnQiLz48c3RvcCBvZmZzZXQ9IjEiIGNsYXNzPSJibGFja19zb2xpZF9maW5pc2giLz48L2xpbmVhckdyYWRpZW50PjxwYXRoIGNsYXNzPSJzaGFkb3ciIGZpbGw9InVybCgjc2hhZG93LWdyYWRpZW50MikiIGQ9Ik04NC43MiAzOS43YzQuNy0yLjQgMTcuODItMTEuNTIgMTguMy0xMS45OGExMy44IDEzLjggMCAwIDAgMS41LTEuNjJjMy00IDEuMTEtNy42Mi00LjQ0LTguMDMtLjQ3LS4wMy0xLjA2LS4xLTEuNjgtLjE2LS45NiAzLjQzLTMuMjIgNy42LTYuNDMgMTIuMzNhMTE2Ljc5IDExNi43OSAwIDAgMS02LjE0IDguMmwtLjU1LjY3Yy0uMTEuMTUtLjI3LjMyLS40Ni41LS4wMy0uMDEtLjAyLS4wMS0uMTIuMDZoLjAyeiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNODAgMjV2MmgzLjZsLTIuNzQgMTAuMTNhMi41MyAyLjUzIDAgMCAwLS4wNSAxLjM4Yy4yLjguOCAxLjUgMS43IDEuNjhoLjJjLjU0LjEgMSAwIDEuNC0uMTcuMjYtLjEyLjUtLjI5LjczLS40OC4yLS4xNy4zNS0uMzQuNDYtLjVsLjU1LS42NWMuNDYtLjU3Ljk4LTEuMiAxLjUyLTEuOSAxLjU3LTIuMDIgMy4xNS00LjE1IDQuNjItNi4zMiAzLjc1LTUuNTIgNi4yMS0xMC4zIDYuOC0xNGwuMDQtLjIzLS4wMy0uMTJBMTMuNDQgMTMuNDQgMCAwIDAgODUuNSAwSDgwdjIiLz48cGF0aCBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBkPSJNODAgMjJ2M2g1LjVjLjI0IDAgLjQ4IDAgLjcxLS4wMmwtMy40MyAxMi43cy0uMTYuNS4yLjZjLjM1LjEuNzMtLjQuNzMtLjRTOTUuNTEgMjMuOSA5Ni44IDE1Ljg5bC0uMDItLjE1QTExLjQ0IDExLjQ0IDAgMCAwIDg1LjUgMkg4MHYzIi8+PHBhdGggY2xhc3M9IndoaXRlX3NvbGlkIiBkPSJNODUuNSA1SDgwdjE3aDUuNWE4LjUgOC41IDAgMCAwIDAtMTd6Ii8+PC9nPjxnPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNMCA2MGgxMjB2Mkgwek0wIDg1aDEyMHYySDB6Ii8+PHBhdGggY2xhc3M9ImN1c3RvbV9jb2xvcl9zb2xpZCIgZD0iTTAgNjJoMTIwdjNIMHpNMCA4MmgxMjB2M0gweiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgZD0iTTAgNjVoMTIwdjE3SDB6Ii8+PC9nPjwvc3ZnPg==)}.ymaps-2-1-42-placemark_theme_darkblue,.ymaps-2-1-42-placemark_theme_darkblue .ymaps-2-1-42-placemark__l,.ymaps-2-1-42-placemark_type_blank.ymaps-2-1-42-placemark_theme_darkblue .ymaps-2-1-42-placemark__r{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTIwIDEwMCI+PHN0eWxlPi53aGl0ZV9vcGFjaXR5e2ZpbGw6I2ZmZjtmaWxsLW9wYWNpdHk6Ljh9LmN1c3RvbV9jb2xvcl9zb2xpZHtmaWxsOiMxNzdiYzl9LndoaXRlX3NvbGlke2ZpbGw6I2ZmZn0uYmxhY2tfc29saWRfZmluaXNoLC5ibGFja19zb2xpZF9zdGFydHtzdG9wLWNvbG9yOiMwMDB9LmJsYWNrX3NvbGlkX2ZpbmlzaHtzdG9wLW9wYWNpdHk6MH0uc2hhZG93e29wYWNpdHk6LjV9PC9zdHlsZT48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgMTMuNUMwIDYgNiAwIDEzLjUgMFMyNyA2IDI3IDEzLjUgMjAuOTYgMjcgMTMuNSAyNyAwIDIxIDAgMTMuNXptMjIgMGE4LjUgOC41IDAgMSAwLTE2Ljk5LS4wMUE4LjUgOC41IDAgMCAwIDIyIDEzLjV6Ii8+PGNpcmNsZSBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBjeD0iMTMuNSIgY3k9IjEzLjUiIHI9IjExLjUiLz48Y2lyY2xlIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgY3g9IjEzLjUiIGN5PSIxMy41IiByPSI4LjUiLz48Zz48bGluZWFyR3JhZGllbnQgaWQ9InNoYWRvdy1ncmFkaWVudCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSItMzQwIiB5MT0iMzkxLjkiIHgyPSItMzM5LjEiIHkyPSIzOTIuNyIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgyMS4yMTYxIDAgMCAtMjEuNzg3OSA3MjYyLjA0IDg1NzUuMTEpIj48c3RvcCBvZmZzZXQ9IjAiIGNsYXNzPSJibGFja19zb2xpZF9zdGFydCIvPjxzdG9wIG9mZnNldD0iMSIgY2xhc3M9ImJsYWNrX3NvbGlkX2ZpbmlzaCIvPjwvbGluZWFyR3JhZGllbnQ+PHBhdGggY2xhc3M9InNoYWRvdyIgZmlsbD0idXJsKCNzaGFkb3ctZ3JhZGllbnQpIiBkPSJNNDguNzIgMzkuN2M0LjcxLTIuNCAxNy44Mi0xMS41MiAxOC4zLTExLjk4LjU2LS41MiAxLjA3LTEuMDYgMS41LTEuNjIgMy00IDEuMTEtNy42Mi00LjQ0LTguMDMtLjQ3LS4wMy0xLjA2LS4xLTEuNjgtLjE2LS45NiAzLjQzLTMuMjIgNy42LTYuNDMgMTIuMzNhMTE0LjEyIDExNC4xMiAwIDAgMS02LjE0IDguMmwtLjU0LjY3Yy0uMTIuMTUtLjI3LjMyLS40Ny41LS4wMy0uMDEtLjAyLS4wMS0uMTIuMDZoLjAyeiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNMzYgMTMuNUMzNiA2IDQyIDAgNDkuNSAwYTEzLjQ0IDEzLjQ0IDAgMCAxIDEzLjMgMTUuODJsLjAyLjE2LS4wNC4yM2MtLjYgMy43LTMuMDYgOC40Ny02LjggMTRhMTE4LjM0IDExOC4zNCAwIDAgMS02LjE0IDguMjJjLS4yNS4zLS40NC41Mi0uNTUuN2EzLjU5IDMuNTkgMCAwIDEtMS4yLjk3Yy0uNC4yLS44Ni4yNy0xLjQuMmwtLjIxLS4wNGEyLjI5IDIuMjkgMCAwIDEtMS42Ni0xLjY4Yy0uMS0uNDQtLjEtLjgyIDAtMS4xOSAwLS4wNy4wMi0uMTMuMDQtLjE5bDIuNzctMTAuMjZBMTMuNjEgMTMuNjEgMCAwIDEgMzYgMTMuNXoiLz48cGF0aCBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBkPSJNMzggMTMuNUMzOCA3LjEgNDMuMSAyIDQ5LjUgMmExMS40NCAxMS40NCAwIDAgMSAxMS4yOCAxMy43di4xNUM1OS41IDIzLjg1IDQ3LjcgMzcuOCA0Ny43IDM3LjhzLS4zOC41Mi0uNzMuNGMtLjM3LS4xLS4yLS41Ni0uMi0uNTZsMy40Mi0xMi43MWMtLjIxLjA3LS40OS4wNy0uNjkuMDdDNDMuMTUgMjUgMzggMTkuOSAzOCAxMy41eiIvPjxjaXJjbGUgY2xhc3M9IndoaXRlX3NvbGlkIiBjeD0iNDkuNSIgY3k9IjEzLjUiIHI9IjguNSIvPjwvZz48Zz48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgNjBoMTIwdjJIMHpNMCA4NWgxMjB2MkgweiIvPjxwYXRoIGNsYXNzPSJjdXN0b21fY29sb3Jfc29saWQiIGQ9Ik0wIDYyaDEyMHYzSDB6TTAgODJoMTIwdjNIMHoiLz48cGF0aCBjbGFzcz0id2hpdGVfc29saWQiIGQ9Ik0wIDY1aDEyMHYxN0gweiIvPjwvZz48L3N2Zz4=)}.ymaps-2-1-42-placemark_theme_darkblue .ymaps-2-1-42-placemark__r{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTIwIDEwMCI+PHN0eWxlPi53aGl0ZV9vcGFjaXR5e2ZpbGw6I2ZmZjtmaWxsLW9wYWNpdHk6Ljh9LmN1c3RvbV9jb2xvcl9zb2xpZHtmaWxsOiMxNzdiYzl9LndoaXRlX3NvbGlke2ZpbGw6I2ZmZn0uYmxhY2tfc29saWRfZmluaXNoLC5ibGFja19zb2xpZF9zdGFydHtzdG9wLWNvbG9yOiMwMDB9LmJsYWNrX3NvbGlkX2ZpbmlzaHtzdG9wLW9wYWNpdHk6MH0uc2hhZG93e29wYWNpdHk6LjV9PC9zdHlsZT48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgMTMuNUMwIDYgNiAwIDEzLjUgMFMyNyA2IDI3IDEzLjUgMjAuOTYgMjcgMTMuNSAyNyAwIDIxIDAgMTMuNXptMjIgMGE4LjUgOC41IDAgMSAwLTE2Ljk5LS4wMUE4LjUgOC41IDAgMCAwIDIyIDEzLjV6Ii8+PGNpcmNsZSBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBjeD0iMTMuNSIgY3k9IjEzLjUiIHI9IjExLjUiLz48Y2lyY2xlIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgY3g9IjEzLjUiIGN5PSIxMy41IiByPSI4LjUiLz48Zz48bGluZWFyR3JhZGllbnQgaWQ9InNoYWRvdy1ncmFkaWVudDIiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iLTYwOC40IiB5MT0iMzU0LjEiIHgyPSItNjA3LjQiIHkyPSIzNTQuOSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgyMS4yMTYxIDAgMCAtMjEuNzg3OSAxMjk5MS4xNiA3NzUyLjY0KSI+PHN0b3Agb2Zmc2V0PSIwIiBjbGFzcz0iYmxhY2tfc29saWRfc3RhcnQiLz48c3RvcCBvZmZzZXQ9IjEiIGNsYXNzPSJibGFja19zb2xpZF9maW5pc2giLz48L2xpbmVhckdyYWRpZW50PjxwYXRoIGNsYXNzPSJzaGFkb3ciIGZpbGw9InVybCgjc2hhZG93LWdyYWRpZW50MikiIGQ9Ik04NC43MiAzOS43YzQuNy0yLjQgMTcuODItMTEuNTIgMTguMy0xMS45OGExMy44IDEzLjggMCAwIDAgMS41LTEuNjJjMy00IDEuMTEtNy42Mi00LjQ0LTguMDMtLjQ3LS4wMy0xLjA2LS4xLTEuNjgtLjE2LS45NiAzLjQzLTMuMjIgNy42LTYuNDMgMTIuMzNhMTE2Ljc5IDExNi43OSAwIDAgMS02LjE0IDguMmwtLjU1LjY3Yy0uMTEuMTUtLjI3LjMyLS40Ni41LS4wMy0uMDEtLjAyLS4wMS0uMTIuMDZoLjAyeiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNODAgMjV2MmgzLjZsLTIuNzQgMTAuMTNhMi41MyAyLjUzIDAgMCAwLS4wNSAxLjM4Yy4yLjguOCAxLjUgMS43IDEuNjhoLjJjLjU0LjEgMSAwIDEuNC0uMTcuMjYtLjEyLjUtLjI5LjczLS40OC4yLS4xNy4zNS0uMzQuNDYtLjVsLjU1LS42NWMuNDYtLjU3Ljk4LTEuMiAxLjUyLTEuOSAxLjU3LTIuMDIgMy4xNS00LjE1IDQuNjItNi4zMiAzLjc1LTUuNTIgNi4yMS0xMC4zIDYuOC0xNGwuMDQtLjIzLS4wMy0uMTJBMTMuNDQgMTMuNDQgMCAwIDAgODUuNSAwSDgwdjIiLz48cGF0aCBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBkPSJNODAgMjJ2M2g1LjVjLjI0IDAgLjQ4IDAgLjcxLS4wMmwtMy40MyAxMi43cy0uMTYuNS4yLjZjLjM1LjEuNzMtLjQuNzMtLjRTOTUuNTEgMjMuOSA5Ni44IDE1Ljg5bC0uMDItLjE1QTExLjQ0IDExLjQ0IDAgMCAwIDg1LjUgMkg4MHYzIi8+PHBhdGggY2xhc3M9IndoaXRlX3NvbGlkIiBkPSJNODUuNSA1SDgwdjE3aDUuNWE4LjUgOC41IDAgMCAwIDAtMTd6Ii8+PC9nPjxnPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNMCA2MGgxMjB2Mkgwek0wIDg1aDEyMHYySDB6Ii8+PHBhdGggY2xhc3M9ImN1c3RvbV9jb2xvcl9zb2xpZCIgZD0iTTAgNjJoMTIwdjNIMHpNMCA4MmgxMjB2M0gweiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgZD0iTTAgNjVoMTIwdjE3SDB6Ii8+PC9nPjwvc3ZnPg==)}.ymaps-2-1-42-placemark_theme_darkorange,.ymaps-2-1-42-placemark_theme_darkorange .ymaps-2-1-42-placemark__l,.ymaps-2-1-42-placemark_type_blank.ymaps-2-1-42-placemark_theme_darkorange .ymaps-2-1-42-placemark__r{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTIwIDEwMCI+PHN0eWxlPi53aGl0ZV9vcGFjaXR5e2ZpbGw6I2ZmZjtmaWxsLW9wYWNpdHk6Ljh9LmN1c3RvbV9jb2xvcl9zb2xpZHtmaWxsOiNlNjc2MWJ9LndoaXRlX3NvbGlke2ZpbGw6I2ZmZn0uYmxhY2tfc29saWRfZmluaXNoLC5ibGFja19zb2xpZF9zdGFydHtzdG9wLWNvbG9yOiMwMDB9LmJsYWNrX3NvbGlkX2ZpbmlzaHtzdG9wLW9wYWNpdHk6MH0uc2hhZG93e29wYWNpdHk6LjV9PC9zdHlsZT48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgMTMuNUMwIDYgNiAwIDEzLjUgMFMyNyA2IDI3IDEzLjUgMjAuOTYgMjcgMTMuNSAyNyAwIDIxIDAgMTMuNXptMjIgMGE4LjUgOC41IDAgMSAwLTE2Ljk5LS4wMUE4LjUgOC41IDAgMCAwIDIyIDEzLjV6Ii8+PGNpcmNsZSBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBjeD0iMTMuNSIgY3k9IjEzLjUiIHI9IjExLjUiLz48Y2lyY2xlIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgY3g9IjEzLjUiIGN5PSIxMy41IiByPSI4LjUiLz48Zz48bGluZWFyR3JhZGllbnQgaWQ9InNoYWRvdy1ncmFkaWVudCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSItMzQwIiB5MT0iMzkxLjkiIHgyPSItMzM5LjEiIHkyPSIzOTIuNyIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgyMS4yMTYxIDAgMCAtMjEuNzg3OSA3MjYyLjA0IDg1NzUuMTEpIj48c3RvcCBvZmZzZXQ9IjAiIGNsYXNzPSJibGFja19zb2xpZF9zdGFydCIvPjxzdG9wIG9mZnNldD0iMSIgY2xhc3M9ImJsYWNrX3NvbGlkX2ZpbmlzaCIvPjwvbGluZWFyR3JhZGllbnQ+PHBhdGggY2xhc3M9InNoYWRvdyIgZmlsbD0idXJsKCNzaGFkb3ctZ3JhZGllbnQpIiBkPSJNNDguNzIgMzkuN2M0LjcxLTIuNCAxNy44Mi0xMS41MiAxOC4zLTExLjk4LjU2LS41MiAxLjA3LTEuMDYgMS41LTEuNjIgMy00IDEuMTEtNy42Mi00LjQ0LTguMDMtLjQ3LS4wMy0xLjA2LS4xLTEuNjgtLjE2LS45NiAzLjQzLTMuMjIgNy42LTYuNDMgMTIuMzNhMTE0LjEyIDExNC4xMiAwIDAgMS02LjE0IDguMmwtLjU0LjY3Yy0uMTIuMTUtLjI3LjMyLS40Ny41LS4wMy0uMDEtLjAyLS4wMS0uMTIuMDZoLjAyeiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNMzYgMTMuNUMzNiA2IDQyIDAgNDkuNSAwYTEzLjQ0IDEzLjQ0IDAgMCAxIDEzLjMgMTUuODJsLjAyLjE2LS4wNC4yM2MtLjYgMy43LTMuMDYgOC40Ny02LjggMTRhMTE4LjM0IDExOC4zNCAwIDAgMS02LjE0IDguMjJjLS4yNS4zLS40NC41Mi0uNTUuN2EzLjU5IDMuNTkgMCAwIDEtMS4yLjk3Yy0uNC4yLS44Ni4yNy0xLjQuMmwtLjIxLS4wNGEyLjI5IDIuMjkgMCAwIDEtMS42Ni0xLjY4Yy0uMS0uNDQtLjEtLjgyIDAtMS4xOSAwLS4wNy4wMi0uMTMuMDQtLjE5bDIuNzctMTAuMjZBMTMuNjEgMTMuNjEgMCAwIDEgMzYgMTMuNXoiLz48cGF0aCBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBkPSJNMzggMTMuNUMzOCA3LjEgNDMuMSAyIDQ5LjUgMmExMS40NCAxMS40NCAwIDAgMSAxMS4yOCAxMy43di4xNUM1OS41IDIzLjg1IDQ3LjcgMzcuOCA0Ny43IDM3LjhzLS4zOC41Mi0uNzMuNGMtLjM3LS4xLS4yLS41Ni0uMi0uNTZsMy40Mi0xMi43MWMtLjIxLjA3LS40OS4wNy0uNjkuMDdDNDMuMTUgMjUgMzggMTkuOSAzOCAxMy41eiIvPjxjaXJjbGUgY2xhc3M9IndoaXRlX3NvbGlkIiBjeD0iNDkuNSIgY3k9IjEzLjUiIHI9IjguNSIvPjwvZz48Zz48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgNjBoMTIwdjJIMHpNMCA4NWgxMjB2MkgweiIvPjxwYXRoIGNsYXNzPSJjdXN0b21fY29sb3Jfc29saWQiIGQ9Ik0wIDYyaDEyMHYzSDB6TTAgODJoMTIwdjNIMHoiLz48cGF0aCBjbGFzcz0id2hpdGVfc29saWQiIGQ9Ik0wIDY1aDEyMHYxN0gweiIvPjwvZz48L3N2Zz4=)}.ymaps-2-1-42-placemark_theme_darkorange .ymaps-2-1-42-placemark__r{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTIwIDEwMCI+PHN0eWxlPi53aGl0ZV9vcGFjaXR5e2ZpbGw6I2ZmZjtmaWxsLW9wYWNpdHk6Ljh9LmN1c3RvbV9jb2xvcl9zb2xpZHtmaWxsOiNlNjc2MWJ9LndoaXRlX3NvbGlke2ZpbGw6I2ZmZn0uYmxhY2tfc29saWRfZmluaXNoLC5ibGFja19zb2xpZF9zdGFydHtzdG9wLWNvbG9yOiMwMDB9LmJsYWNrX3NvbGlkX2ZpbmlzaHtzdG9wLW9wYWNpdHk6MH0uc2hhZG93e29wYWNpdHk6LjV9PC9zdHlsZT48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgMTMuNUMwIDYgNiAwIDEzLjUgMFMyNyA2IDI3IDEzLjUgMjAuOTYgMjcgMTMuNSAyNyAwIDIxIDAgMTMuNXptMjIgMGE4LjUgOC41IDAgMSAwLTE2Ljk5LS4wMUE4LjUgOC41IDAgMCAwIDIyIDEzLjV6Ii8+PGNpcmNsZSBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBjeD0iMTMuNSIgY3k9IjEzLjUiIHI9IjExLjUiLz48Y2lyY2xlIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgY3g9IjEzLjUiIGN5PSIxMy41IiByPSI4LjUiLz48Zz48bGluZWFyR3JhZGllbnQgaWQ9InNoYWRvdy1ncmFkaWVudDIiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iLTYwOC40IiB5MT0iMzU0LjEiIHgyPSItNjA3LjQiIHkyPSIzNTQuOSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgyMS4yMTYxIDAgMCAtMjEuNzg3OSAxMjk5MS4xNiA3NzUyLjY0KSI+PHN0b3Agb2Zmc2V0PSIwIiBjbGFzcz0iYmxhY2tfc29saWRfc3RhcnQiLz48c3RvcCBvZmZzZXQ9IjEiIGNsYXNzPSJibGFja19zb2xpZF9maW5pc2giLz48L2xpbmVhckdyYWRpZW50PjxwYXRoIGNsYXNzPSJzaGFkb3ciIGZpbGw9InVybCgjc2hhZG93LWdyYWRpZW50MikiIGQ9Ik04NC43MiAzOS43YzQuNy0yLjQgMTcuODItMTEuNTIgMTguMy0xMS45OGExMy44IDEzLjggMCAwIDAgMS41LTEuNjJjMy00IDEuMTEtNy42Mi00LjQ0LTguMDMtLjQ3LS4wMy0xLjA2LS4xLTEuNjgtLjE2LS45NiAzLjQzLTMuMjIgNy42LTYuNDMgMTIuMzNhMTE2Ljc5IDExNi43OSAwIDAgMS02LjE0IDguMmwtLjU1LjY3Yy0uMTEuMTUtLjI3LjMyLS40Ni41LS4wMy0uMDEtLjAyLS4wMS0uMTIuMDZoLjAyeiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNODAgMjV2MmgzLjZsLTIuNzQgMTAuMTNhMi41MyAyLjUzIDAgMCAwLS4wNSAxLjM4Yy4yLjguOCAxLjUgMS43IDEuNjhoLjJjLjU0LjEgMSAwIDEuNC0uMTcuMjYtLjEyLjUtLjI5LjczLS40OC4yLS4xNy4zNS0uMzQuNDYtLjVsLjU1LS42NWMuNDYtLjU3Ljk4LTEuMiAxLjUyLTEuOSAxLjU3LTIuMDIgMy4xNS00LjE1IDQuNjItNi4zMiAzLjc1LTUuNTIgNi4yMS0xMC4zIDYuOC0xNGwuMDQtLjIzLS4wMy0uMTJBMTMuNDQgMTMuNDQgMCAwIDAgODUuNSAwSDgwdjIiLz48cGF0aCBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBkPSJNODAgMjJ2M2g1LjVjLjI0IDAgLjQ4IDAgLjcxLS4wMmwtMy40MyAxMi43cy0uMTYuNS4yLjZjLjM1LjEuNzMtLjQuNzMtLjRTOTUuNTEgMjMuOSA5Ni44IDE1Ljg5bC0uMDItLjE1QTExLjQ0IDExLjQ0IDAgMCAwIDg1LjUgMkg4MHYzIi8+PHBhdGggY2xhc3M9IndoaXRlX3NvbGlkIiBkPSJNODUuNSA1SDgwdjE3aDUuNWE4LjUgOC41IDAgMCAwIDAtMTd6Ii8+PC9nPjxnPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNMCA2MGgxMjB2Mkgwek0wIDg1aDEyMHYySDB6Ii8+PHBhdGggY2xhc3M9ImN1c3RvbV9jb2xvcl9zb2xpZCIgZD0iTTAgNjJoMTIwdjNIMHpNMCA4MmgxMjB2M0gweiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgZD0iTTAgNjVoMTIwdjE3SDB6Ii8+PC9nPjwvc3ZnPg==)}.ymaps-2-1-42-placemark_theme_night,.ymaps-2-1-42-placemark_theme_night .ymaps-2-1-42-placemark__l,.ymaps-2-1-42-placemark_type_blank.ymaps-2-1-42-placemark_theme_night .ymaps-2-1-42-placemark__r{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTIwIDEwMCI+PHN0eWxlPi53aGl0ZV9vcGFjaXR5e2ZpbGw6I2ZmZjtmaWxsLW9wYWNpdHk6Ljh9LmN1c3RvbV9jb2xvcl9zb2xpZHtmaWxsOiMwZTQ3Nzl9LndoaXRlX3NvbGlke2ZpbGw6I2ZmZn0uYmxhY2tfc29saWRfZmluaXNoLC5ibGFja19zb2xpZF9zdGFydHtzdG9wLWNvbG9yOiMwMDB9LmJsYWNrX3NvbGlkX2ZpbmlzaHtzdG9wLW9wYWNpdHk6MH0uc2hhZG93e29wYWNpdHk6LjV9PC9zdHlsZT48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgMTMuNUMwIDYgNiAwIDEzLjUgMFMyNyA2IDI3IDEzLjUgMjAuOTYgMjcgMTMuNSAyNyAwIDIxIDAgMTMuNXptMjIgMGE4LjUgOC41IDAgMSAwLTE2Ljk5LS4wMUE4LjUgOC41IDAgMCAwIDIyIDEzLjV6Ii8+PGNpcmNsZSBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBjeD0iMTMuNSIgY3k9IjEzLjUiIHI9IjExLjUiLz48Y2lyY2xlIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgY3g9IjEzLjUiIGN5PSIxMy41IiByPSI4LjUiLz48Zz48bGluZWFyR3JhZGllbnQgaWQ9InNoYWRvdy1ncmFkaWVudCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSItMzQwIiB5MT0iMzkxLjkiIHgyPSItMzM5LjEiIHkyPSIzOTIuNyIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgyMS4yMTYxIDAgMCAtMjEuNzg3OSA3MjYyLjA0IDg1NzUuMTEpIj48c3RvcCBvZmZzZXQ9IjAiIGNsYXNzPSJibGFja19zb2xpZF9zdGFydCIvPjxzdG9wIG9mZnNldD0iMSIgY2xhc3M9ImJsYWNrX3NvbGlkX2ZpbmlzaCIvPjwvbGluZWFyR3JhZGllbnQ+PHBhdGggY2xhc3M9InNoYWRvdyIgZmlsbD0idXJsKCNzaGFkb3ctZ3JhZGllbnQpIiBkPSJNNDguNzIgMzkuN2M0LjcxLTIuNCAxNy44Mi0xMS41MiAxOC4zLTExLjk4LjU2LS41MiAxLjA3LTEuMDYgMS41LTEuNjIgMy00IDEuMTEtNy42Mi00LjQ0LTguMDMtLjQ3LS4wMy0xLjA2LS4xLTEuNjgtLjE2LS45NiAzLjQzLTMuMjIgNy42LTYuNDMgMTIuMzNhMTE0LjEyIDExNC4xMiAwIDAgMS02LjE0IDguMmwtLjU0LjY3Yy0uMTIuMTUtLjI3LjMyLS40Ny41LS4wMy0uMDEtLjAyLS4wMS0uMTIuMDZoLjAyeiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNMzYgMTMuNUMzNiA2IDQyIDAgNDkuNSAwYTEzLjQ0IDEzLjQ0IDAgMCAxIDEzLjMgMTUuODJsLjAyLjE2LS4wNC4yM2MtLjYgMy43LTMuMDYgOC40Ny02LjggMTRhMTE4LjM0IDExOC4zNCAwIDAgMS02LjE0IDguMjJjLS4yNS4zLS40NC41Mi0uNTUuN2EzLjU5IDMuNTkgMCAwIDEtMS4yLjk3Yy0uNC4yLS44Ni4yNy0xLjQuMmwtLjIxLS4wNGEyLjI5IDIuMjkgMCAwIDEtMS42Ni0xLjY4Yy0uMS0uNDQtLjEtLjgyIDAtMS4xOSAwLS4wNy4wMi0uMTMuMDQtLjE5bDIuNzctMTAuMjZBMTMuNjEgMTMuNjEgMCAwIDEgMzYgMTMuNXoiLz48cGF0aCBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBkPSJNMzggMTMuNUMzOCA3LjEgNDMuMSAyIDQ5LjUgMmExMS40NCAxMS40NCAwIDAgMSAxMS4yOCAxMy43di4xNUM1OS41IDIzLjg1IDQ3LjcgMzcuOCA0Ny43IDM3LjhzLS4zOC41Mi0uNzMuNGMtLjM3LS4xLS4yLS41Ni0uMi0uNTZsMy40Mi0xMi43MWMtLjIxLjA3LS40OS4wNy0uNjkuMDdDNDMuMTUgMjUgMzggMTkuOSAzOCAxMy41eiIvPjxjaXJjbGUgY2xhc3M9IndoaXRlX3NvbGlkIiBjeD0iNDkuNSIgY3k9IjEzLjUiIHI9IjguNSIvPjwvZz48Zz48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgNjBoMTIwdjJIMHpNMCA4NWgxMjB2MkgweiIvPjxwYXRoIGNsYXNzPSJjdXN0b21fY29sb3Jfc29saWQiIGQ9Ik0wIDYyaDEyMHYzSDB6TTAgODJoMTIwdjNIMHoiLz48cGF0aCBjbGFzcz0id2hpdGVfc29saWQiIGQ9Ik0wIDY1aDEyMHYxN0gweiIvPjwvZz48L3N2Zz4=)}.ymaps-2-1-42-placemark_theme_night .ymaps-2-1-42-placemark__r{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTIwIDEwMCI+PHN0eWxlPi53aGl0ZV9vcGFjaXR5e2ZpbGw6I2ZmZjtmaWxsLW9wYWNpdHk6Ljh9LmN1c3RvbV9jb2xvcl9zb2xpZHtmaWxsOiMwZTQ3Nzl9LndoaXRlX3NvbGlke2ZpbGw6I2ZmZn0uYmxhY2tfc29saWRfZmluaXNoLC5ibGFja19zb2xpZF9zdGFydHtzdG9wLWNvbG9yOiMwMDB9LmJsYWNrX3NvbGlkX2ZpbmlzaHtzdG9wLW9wYWNpdHk6MH0uc2hhZG93e29wYWNpdHk6LjV9PC9zdHlsZT48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgMTMuNUMwIDYgNiAwIDEzLjUgMFMyNyA2IDI3IDEzLjUgMjAuOTYgMjcgMTMuNSAyNyAwIDIxIDAgMTMuNXptMjIgMGE4LjUgOC41IDAgMSAwLTE2Ljk5LS4wMUE4LjUgOC41IDAgMCAwIDIyIDEzLjV6Ii8+PGNpcmNsZSBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBjeD0iMTMuNSIgY3k9IjEzLjUiIHI9IjExLjUiLz48Y2lyY2xlIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgY3g9IjEzLjUiIGN5PSIxMy41IiByPSI4LjUiLz48Zz48bGluZWFyR3JhZGllbnQgaWQ9InNoYWRvdy1ncmFkaWVudDIiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iLTYwOC40IiB5MT0iMzU0LjEiIHgyPSItNjA3LjQiIHkyPSIzNTQuOSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgyMS4yMTYxIDAgMCAtMjEuNzg3OSAxMjk5MS4xNiA3NzUyLjY0KSI+PHN0b3Agb2Zmc2V0PSIwIiBjbGFzcz0iYmxhY2tfc29saWRfc3RhcnQiLz48c3RvcCBvZmZzZXQ9IjEiIGNsYXNzPSJibGFja19zb2xpZF9maW5pc2giLz48L2xpbmVhckdyYWRpZW50PjxwYXRoIGNsYXNzPSJzaGFkb3ciIGZpbGw9InVybCgjc2hhZG93LWdyYWRpZW50MikiIGQ9Ik04NC43MiAzOS43YzQuNy0yLjQgMTcuODItMTEuNTIgMTguMy0xMS45OGExMy44IDEzLjggMCAwIDAgMS41LTEuNjJjMy00IDEuMTEtNy42Mi00LjQ0LTguMDMtLjQ3LS4wMy0xLjA2LS4xLTEuNjgtLjE2LS45NiAzLjQzLTMuMjIgNy42LTYuNDMgMTIuMzNhMTE2Ljc5IDExNi43OSAwIDAgMS02LjE0IDguMmwtLjU1LjY3Yy0uMTEuMTUtLjI3LjMyLS40Ni41LS4wMy0uMDEtLjAyLS4wMS0uMTIuMDZoLjAyeiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNODAgMjV2MmgzLjZsLTIuNzQgMTAuMTNhMi41MyAyLjUzIDAgMCAwLS4wNSAxLjM4Yy4yLjguOCAxLjUgMS43IDEuNjhoLjJjLjU0LjEgMSAwIDEuNC0uMTcuMjYtLjEyLjUtLjI5LjczLS40OC4yLS4xNy4zNS0uMzQuNDYtLjVsLjU1LS42NWMuNDYtLjU3Ljk4LTEuMiAxLjUyLTEuOSAxLjU3LTIuMDIgMy4xNS00LjE1IDQuNjItNi4zMiAzLjc1LTUuNTIgNi4yMS0xMC4zIDYuOC0xNGwuMDQtLjIzLS4wMy0uMTJBMTMuNDQgMTMuNDQgMCAwIDAgODUuNSAwSDgwdjIiLz48cGF0aCBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBkPSJNODAgMjJ2M2g1LjVjLjI0IDAgLjQ4IDAgLjcxLS4wMmwtMy40MyAxMi43cy0uMTYuNS4yLjZjLjM1LjEuNzMtLjQuNzMtLjRTOTUuNTEgMjMuOSA5Ni44IDE1Ljg5bC0uMDItLjE1QTExLjQ0IDExLjQ0IDAgMCAwIDg1LjUgMkg4MHYzIi8+PHBhdGggY2xhc3M9IndoaXRlX3NvbGlkIiBkPSJNODUuNSA1SDgwdjE3aDUuNWE4LjUgOC41IDAgMCAwIDAtMTd6Ii8+PC9nPjxnPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNMCA2MGgxMjB2Mkgwek0wIDg1aDEyMHYySDB6Ii8+PHBhdGggY2xhc3M9ImN1c3RvbV9jb2xvcl9zb2xpZCIgZD0iTTAgNjJoMTIwdjNIMHpNMCA4MmgxMjB2M0gweiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgZD0iTTAgNjVoMTIwdjE3SDB6Ii8+PC9nPjwvc3ZnPg==)}.ymaps-2-1-42-placemark_theme_pink,.ymaps-2-1-42-placemark_theme_pink .ymaps-2-1-42-placemark__l,.ymaps-2-1-42-placemark_type_blank.ymaps-2-1-42-placemark_theme_pink .ymaps-2-1-42-placemark__r{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTIwIDEwMCI+PHN0eWxlPi53aGl0ZV9vcGFjaXR5e2ZpbGw6I2ZmZjtmaWxsLW9wYWNpdHk6Ljh9LmN1c3RvbV9jb2xvcl9zb2xpZHtmaWxsOiNmMzcxZDF9LndoaXRlX3NvbGlke2ZpbGw6I2ZmZn0uYmxhY2tfc29saWRfZmluaXNoLC5ibGFja19zb2xpZF9zdGFydHtzdG9wLWNvbG9yOiMwMDB9LmJsYWNrX3NvbGlkX2ZpbmlzaHtzdG9wLW9wYWNpdHk6MH0uc2hhZG93e29wYWNpdHk6LjV9PC9zdHlsZT48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgMTMuNUMwIDYgNiAwIDEzLjUgMFMyNyA2IDI3IDEzLjUgMjAuOTYgMjcgMTMuNSAyNyAwIDIxIDAgMTMuNXptMjIgMGE4LjUgOC41IDAgMSAwLTE2Ljk5LS4wMUE4LjUgOC41IDAgMCAwIDIyIDEzLjV6Ii8+PGNpcmNsZSBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBjeD0iMTMuNSIgY3k9IjEzLjUiIHI9IjExLjUiLz48Y2lyY2xlIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgY3g9IjEzLjUiIGN5PSIxMy41IiByPSI4LjUiLz48Zz48bGluZWFyR3JhZGllbnQgaWQ9InNoYWRvdy1ncmFkaWVudCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSItMzQwIiB5MT0iMzkxLjkiIHgyPSItMzM5LjEiIHkyPSIzOTIuNyIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgyMS4yMTYxIDAgMCAtMjEuNzg3OSA3MjYyLjA0IDg1NzUuMTEpIj48c3RvcCBvZmZzZXQ9IjAiIGNsYXNzPSJibGFja19zb2xpZF9zdGFydCIvPjxzdG9wIG9mZnNldD0iMSIgY2xhc3M9ImJsYWNrX3NvbGlkX2ZpbmlzaCIvPjwvbGluZWFyR3JhZGllbnQ+PHBhdGggY2xhc3M9InNoYWRvdyIgZmlsbD0idXJsKCNzaGFkb3ctZ3JhZGllbnQpIiBkPSJNNDguNzIgMzkuN2M0LjcxLTIuNCAxNy44Mi0xMS41MiAxOC4zLTExLjk4LjU2LS41MiAxLjA3LTEuMDYgMS41LTEuNjIgMy00IDEuMTEtNy42Mi00LjQ0LTguMDMtLjQ3LS4wMy0xLjA2LS4xLTEuNjgtLjE2LS45NiAzLjQzLTMuMjIgNy42LTYuNDMgMTIuMzNhMTE0LjEyIDExNC4xMiAwIDAgMS02LjE0IDguMmwtLjU0LjY3Yy0uMTIuMTUtLjI3LjMyLS40Ny41LS4wMy0uMDEtLjAyLS4wMS0uMTIuMDZoLjAyeiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNMzYgMTMuNUMzNiA2IDQyIDAgNDkuNSAwYTEzLjQ0IDEzLjQ0IDAgMCAxIDEzLjMgMTUuODJsLjAyLjE2LS4wNC4yM2MtLjYgMy43LTMuMDYgOC40Ny02LjggMTRhMTE4LjM0IDExOC4zNCAwIDAgMS02LjE0IDguMjJjLS4yNS4zLS40NC41Mi0uNTUuN2EzLjU5IDMuNTkgMCAwIDEtMS4yLjk3Yy0uNC4yLS44Ni4yNy0xLjQuMmwtLjIxLS4wNGEyLjI5IDIuMjkgMCAwIDEtMS42Ni0xLjY4Yy0uMS0uNDQtLjEtLjgyIDAtMS4xOSAwLS4wNy4wMi0uMTMuMDQtLjE5bDIuNzctMTAuMjZBMTMuNjEgMTMuNjEgMCAwIDEgMzYgMTMuNXoiLz48cGF0aCBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBkPSJNMzggMTMuNUMzOCA3LjEgNDMuMSAyIDQ5LjUgMmExMS40NCAxMS40NCAwIDAgMSAxMS4yOCAxMy43di4xNUM1OS41IDIzLjg1IDQ3LjcgMzcuOCA0Ny43IDM3LjhzLS4zOC41Mi0uNzMuNGMtLjM3LS4xLS4yLS41Ni0uMi0uNTZsMy40Mi0xMi43MWMtLjIxLjA3LS40OS4wNy0uNjkuMDdDNDMuMTUgMjUgMzggMTkuOSAzOCAxMy41eiIvPjxjaXJjbGUgY2xhc3M9IndoaXRlX3NvbGlkIiBjeD0iNDkuNSIgY3k9IjEzLjUiIHI9IjguNSIvPjwvZz48Zz48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgNjBoMTIwdjJIMHpNMCA4NWgxMjB2MkgweiIvPjxwYXRoIGNsYXNzPSJjdXN0b21fY29sb3Jfc29saWQiIGQ9Ik0wIDYyaDEyMHYzSDB6TTAgODJoMTIwdjNIMHoiLz48cGF0aCBjbGFzcz0id2hpdGVfc29saWQiIGQ9Ik0wIDY1aDEyMHYxN0gweiIvPjwvZz48L3N2Zz4=)}.ymaps-2-1-42-placemark_theme_pink .ymaps-2-1-42-placemark__r{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTIwIDEwMCI+PHN0eWxlPi53aGl0ZV9vcGFjaXR5e2ZpbGw6I2ZmZjtmaWxsLW9wYWNpdHk6Ljh9LmN1c3RvbV9jb2xvcl9zb2xpZHtmaWxsOiNmMzcxZDF9LndoaXRlX3NvbGlke2ZpbGw6I2ZmZn0uYmxhY2tfc29saWRfZmluaXNoLC5ibGFja19zb2xpZF9zdGFydHtzdG9wLWNvbG9yOiMwMDB9LmJsYWNrX3NvbGlkX2ZpbmlzaHtzdG9wLW9wYWNpdHk6MH0uc2hhZG93e29wYWNpdHk6LjV9PC9zdHlsZT48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgMTMuNUMwIDYgNiAwIDEzLjUgMFMyNyA2IDI3IDEzLjUgMjAuOTYgMjcgMTMuNSAyNyAwIDIxIDAgMTMuNXptMjIgMGE4LjUgOC41IDAgMSAwLTE2Ljk5LS4wMUE4LjUgOC41IDAgMCAwIDIyIDEzLjV6Ii8+PGNpcmNsZSBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBjeD0iMTMuNSIgY3k9IjEzLjUiIHI9IjExLjUiLz48Y2lyY2xlIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgY3g9IjEzLjUiIGN5PSIxMy41IiByPSI4LjUiLz48Zz48bGluZWFyR3JhZGllbnQgaWQ9InNoYWRvdy1ncmFkaWVudDIiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iLTYwOC40IiB5MT0iMzU0LjEiIHgyPSItNjA3LjQiIHkyPSIzNTQuOSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgyMS4yMTYxIDAgMCAtMjEuNzg3OSAxMjk5MS4xNiA3NzUyLjY0KSI+PHN0b3Agb2Zmc2V0PSIwIiBjbGFzcz0iYmxhY2tfc29saWRfc3RhcnQiLz48c3RvcCBvZmZzZXQ9IjEiIGNsYXNzPSJibGFja19zb2xpZF9maW5pc2giLz48L2xpbmVhckdyYWRpZW50PjxwYXRoIGNsYXNzPSJzaGFkb3ciIGZpbGw9InVybCgjc2hhZG93LWdyYWRpZW50MikiIGQ9Ik04NC43MiAzOS43YzQuNy0yLjQgMTcuODItMTEuNTIgMTguMy0xMS45OGExMy44IDEzLjggMCAwIDAgMS41LTEuNjJjMy00IDEuMTEtNy42Mi00LjQ0LTguMDMtLjQ3LS4wMy0xLjA2LS4xLTEuNjgtLjE2LS45NiAzLjQzLTMuMjIgNy42LTYuNDMgMTIuMzNhMTE2Ljc5IDExNi43OSAwIDAgMS02LjE0IDguMmwtLjU1LjY3Yy0uMTEuMTUtLjI3LjMyLS40Ni41LS4wMy0uMDEtLjAyLS4wMS0uMTIuMDZoLjAyeiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNODAgMjV2MmgzLjZsLTIuNzQgMTAuMTNhMi41MyAyLjUzIDAgMCAwLS4wNSAxLjM4Yy4yLjguOCAxLjUgMS43IDEuNjhoLjJjLjU0LjEgMSAwIDEuNC0uMTcuMjYtLjEyLjUtLjI5LjczLS40OC4yLS4xNy4zNS0uMzQuNDYtLjVsLjU1LS42NWMuNDYtLjU3Ljk4LTEuMiAxLjUyLTEuOSAxLjU3LTIuMDIgMy4xNS00LjE1IDQuNjItNi4zMiAzLjc1LTUuNTIgNi4yMS0xMC4zIDYuOC0xNGwuMDQtLjIzLS4wMy0uMTJBMTMuNDQgMTMuNDQgMCAwIDAgODUuNSAwSDgwdjIiLz48cGF0aCBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBkPSJNODAgMjJ2M2g1LjVjLjI0IDAgLjQ4IDAgLjcxLS4wMmwtMy40MyAxMi43cy0uMTYuNS4yLjZjLjM1LjEuNzMtLjQuNzMtLjRTOTUuNTEgMjMuOSA5Ni44IDE1Ljg5bC0uMDItLjE1QTExLjQ0IDExLjQ0IDAgMCAwIDg1LjUgMkg4MHYzIi8+PHBhdGggY2xhc3M9IndoaXRlX3NvbGlkIiBkPSJNODUuNSA1SDgwdjE3aDUuNWE4LjUgOC41IDAgMCAwIDAtMTd6Ii8+PC9nPjxnPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNMCA2MGgxMjB2Mkgwek0wIDg1aDEyMHYySDB6Ii8+PHBhdGggY2xhc3M9ImN1c3RvbV9jb2xvcl9zb2xpZCIgZD0iTTAgNjJoMTIwdjNIMHpNMCA4MmgxMjB2M0gweiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgZD0iTTAgNjVoMTIwdjE3SDB6Ii8+PC9nPjwvc3ZnPg==)}.ymaps-2-1-42-placemark_theme_gray,.ymaps-2-1-42-placemark_theme_gray .ymaps-2-1-42-placemark__l,.ymaps-2-1-42-placemark_theme_grey,.ymaps-2-1-42-placemark_type_blank.ymaps-2-1-42-placemark_theme_gray .ymaps-2-1-42-placemark__r{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTIwIDEwMCI+PHN0eWxlPi53aGl0ZV9vcGFjaXR5e2ZpbGw6I2ZmZjtmaWxsLW9wYWNpdHk6Ljh9LmN1c3RvbV9jb2xvcl9zb2xpZHtmaWxsOiNiM2IzYjN9LndoaXRlX3NvbGlke2ZpbGw6I2ZmZn0uYmxhY2tfc29saWRfZmluaXNoLC5ibGFja19zb2xpZF9zdGFydHtzdG9wLWNvbG9yOiMwMDB9LmJsYWNrX3NvbGlkX2ZpbmlzaHtzdG9wLW9wYWNpdHk6MH0uc2hhZG93e29wYWNpdHk6LjV9PC9zdHlsZT48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgMTMuNUMwIDYgNiAwIDEzLjUgMFMyNyA2IDI3IDEzLjUgMjAuOTYgMjcgMTMuNSAyNyAwIDIxIDAgMTMuNXptMjIgMGE4LjUgOC41IDAgMSAwLTE2Ljk5LS4wMUE4LjUgOC41IDAgMCAwIDIyIDEzLjV6Ii8+PGNpcmNsZSBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBjeD0iMTMuNSIgY3k9IjEzLjUiIHI9IjExLjUiLz48Y2lyY2xlIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgY3g9IjEzLjUiIGN5PSIxMy41IiByPSI4LjUiLz48Zz48bGluZWFyR3JhZGllbnQgaWQ9InNoYWRvdy1ncmFkaWVudCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSItMzQwIiB5MT0iMzkxLjkiIHgyPSItMzM5LjEiIHkyPSIzOTIuNyIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgyMS4yMTYxIDAgMCAtMjEuNzg3OSA3MjYyLjA0IDg1NzUuMTEpIj48c3RvcCBvZmZzZXQ9IjAiIGNsYXNzPSJibGFja19zb2xpZF9zdGFydCIvPjxzdG9wIG9mZnNldD0iMSIgY2xhc3M9ImJsYWNrX3NvbGlkX2ZpbmlzaCIvPjwvbGluZWFyR3JhZGllbnQ+PHBhdGggY2xhc3M9InNoYWRvdyIgZmlsbD0idXJsKCNzaGFkb3ctZ3JhZGllbnQpIiBkPSJNNDguNzIgMzkuN2M0LjcxLTIuNCAxNy44Mi0xMS41MiAxOC4zLTExLjk4LjU2LS41MiAxLjA3LTEuMDYgMS41LTEuNjIgMy00IDEuMTEtNy42Mi00LjQ0LTguMDMtLjQ3LS4wMy0xLjA2LS4xLTEuNjgtLjE2LS45NiAzLjQzLTMuMjIgNy42LTYuNDMgMTIuMzNhMTE0LjEyIDExNC4xMiAwIDAgMS02LjE0IDguMmwtLjU0LjY3Yy0uMTIuMTUtLjI3LjMyLS40Ny41LS4wMy0uMDEtLjAyLS4wMS0uMTIuMDZoLjAyeiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNMzYgMTMuNUMzNiA2IDQyIDAgNDkuNSAwYTEzLjQ0IDEzLjQ0IDAgMCAxIDEzLjMgMTUuODJsLjAyLjE2LS4wNC4yM2MtLjYgMy43LTMuMDYgOC40Ny02LjggMTRhMTE4LjM0IDExOC4zNCAwIDAgMS02LjE0IDguMjJjLS4yNS4zLS40NC41Mi0uNTUuN2EzLjU5IDMuNTkgMCAwIDEtMS4yLjk3Yy0uNC4yLS44Ni4yNy0xLjQuMmwtLjIxLS4wNGEyLjI5IDIuMjkgMCAwIDEtMS42Ni0xLjY4Yy0uMS0uNDQtLjEtLjgyIDAtMS4xOSAwLS4wNy4wMi0uMTMuMDQtLjE5bDIuNzctMTAuMjZBMTMuNjEgMTMuNjEgMCAwIDEgMzYgMTMuNXoiLz48cGF0aCBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBkPSJNMzggMTMuNUMzOCA3LjEgNDMuMSAyIDQ5LjUgMmExMS40NCAxMS40NCAwIDAgMSAxMS4yOCAxMy43di4xNUM1OS41IDIzLjg1IDQ3LjcgMzcuOCA0Ny43IDM3LjhzLS4zOC41Mi0uNzMuNGMtLjM3LS4xLS4yLS41Ni0uMi0uNTZsMy40Mi0xMi43MWMtLjIxLjA3LS40OS4wNy0uNjkuMDdDNDMuMTUgMjUgMzggMTkuOSAzOCAxMy41eiIvPjxjaXJjbGUgY2xhc3M9IndoaXRlX3NvbGlkIiBjeD0iNDkuNSIgY3k9IjEzLjUiIHI9IjguNSIvPjwvZz48Zz48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgNjBoMTIwdjJIMHpNMCA4NWgxMjB2MkgweiIvPjxwYXRoIGNsYXNzPSJjdXN0b21fY29sb3Jfc29saWQiIGQ9Ik0wIDYyaDEyMHYzSDB6TTAgODJoMTIwdjNIMHoiLz48cGF0aCBjbGFzcz0id2hpdGVfc29saWQiIGQ9Ik0wIDY1aDEyMHYxN0gweiIvPjwvZz48L3N2Zz4=)}.ymaps-2-1-42-placemark_theme_gray .ymaps-2-1-42-placemark__r{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTIwIDEwMCI+PHN0eWxlPi53aGl0ZV9vcGFjaXR5e2ZpbGw6I2ZmZjtmaWxsLW9wYWNpdHk6Ljh9LmN1c3RvbV9jb2xvcl9zb2xpZHtmaWxsOiNiM2IzYjN9LndoaXRlX3NvbGlke2ZpbGw6I2ZmZn0uYmxhY2tfc29saWRfZmluaXNoLC5ibGFja19zb2xpZF9zdGFydHtzdG9wLWNvbG9yOiMwMDB9LmJsYWNrX3NvbGlkX2ZpbmlzaHtzdG9wLW9wYWNpdHk6MH0uc2hhZG93e29wYWNpdHk6LjV9PC9zdHlsZT48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgMTMuNUMwIDYgNiAwIDEzLjUgMFMyNyA2IDI3IDEzLjUgMjAuOTYgMjcgMTMuNSAyNyAwIDIxIDAgMTMuNXptMjIgMGE4LjUgOC41IDAgMSAwLTE2Ljk5LS4wMUE4LjUgOC41IDAgMCAwIDIyIDEzLjV6Ii8+PGNpcmNsZSBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBjeD0iMTMuNSIgY3k9IjEzLjUiIHI9IjExLjUiLz48Y2lyY2xlIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgY3g9IjEzLjUiIGN5PSIxMy41IiByPSI4LjUiLz48Zz48bGluZWFyR3JhZGllbnQgaWQ9InNoYWRvdy1ncmFkaWVudDIiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iLTYwOC40IiB5MT0iMzU0LjEiIHgyPSItNjA3LjQiIHkyPSIzNTQuOSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgyMS4yMTYxIDAgMCAtMjEuNzg3OSAxMjk5MS4xNiA3NzUyLjY0KSI+PHN0b3Agb2Zmc2V0PSIwIiBjbGFzcz0iYmxhY2tfc29saWRfc3RhcnQiLz48c3RvcCBvZmZzZXQ9IjEiIGNsYXNzPSJibGFja19zb2xpZF9maW5pc2giLz48L2xpbmVhckdyYWRpZW50PjxwYXRoIGNsYXNzPSJzaGFkb3ciIGZpbGw9InVybCgjc2hhZG93LWdyYWRpZW50MikiIGQ9Ik04NC43MiAzOS43YzQuNy0yLjQgMTcuODItMTEuNTIgMTguMy0xMS45OGExMy44IDEzLjggMCAwIDAgMS41LTEuNjJjMy00IDEuMTEtNy42Mi00LjQ0LTguMDMtLjQ3LS4wMy0xLjA2LS4xLTEuNjgtLjE2LS45NiAzLjQzLTMuMjIgNy42LTYuNDMgMTIuMzNhMTE2Ljc5IDExNi43OSAwIDAgMS02LjE0IDguMmwtLjU1LjY3Yy0uMTEuMTUtLjI3LjMyLS40Ni41LS4wMy0uMDEtLjAyLS4wMS0uMTIuMDZoLjAyeiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNODAgMjV2MmgzLjZsLTIuNzQgMTAuMTNhMi41MyAyLjUzIDAgMCAwLS4wNSAxLjM4Yy4yLjguOCAxLjUgMS43IDEuNjhoLjJjLjU0LjEgMSAwIDEuNC0uMTcuMjYtLjEyLjUtLjI5LjczLS40OC4yLS4xNy4zNS0uMzQuNDYtLjVsLjU1LS42NWMuNDYtLjU3Ljk4LTEuMiAxLjUyLTEuOSAxLjU3LTIuMDIgMy4xNS00LjE1IDQuNjItNi4zMiAzLjc1LTUuNTIgNi4yMS0xMC4zIDYuOC0xNGwuMDQtLjIzLS4wMy0uMTJBMTMuNDQgMTMuNDQgMCAwIDAgODUuNSAwSDgwdjIiLz48cGF0aCBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBkPSJNODAgMjJ2M2g1LjVjLjI0IDAgLjQ4IDAgLjcxLS4wMmwtMy40MyAxMi43cy0uMTYuNS4yLjZjLjM1LjEuNzMtLjQuNzMtLjRTOTUuNTEgMjMuOSA5Ni44IDE1Ljg5bC0uMDItLjE1QTExLjQ0IDExLjQ0IDAgMCAwIDg1LjUgMkg4MHYzIi8+PHBhdGggY2xhc3M9IndoaXRlX3NvbGlkIiBkPSJNODUuNSA1SDgwdjE3aDUuNWE4LjUgOC41IDAgMCAwIDAtMTd6Ii8+PC9nPjxnPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNMCA2MGgxMjB2Mkgwek0wIDg1aDEyMHYySDB6Ii8+PHBhdGggY2xhc3M9ImN1c3RvbV9jb2xvcl9zb2xpZCIgZD0iTTAgNjJoMTIwdjNIMHpNMCA4MmgxMjB2M0gweiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgZD0iTTAgNjVoMTIwdjE3SDB6Ii8+PC9nPjwvc3ZnPg==)}.ymaps-2-1-42-placemark_theme_grey .ymaps-2-1-42-placemark__l,.ymaps-2-1-42-placemark_type_blank.ymaps-2-1-42-placemark_theme_grey .ymaps-2-1-42-placemark__r{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTIwIDEwMCI+PHN0eWxlPi53aGl0ZV9vcGFjaXR5e2ZpbGw6I2ZmZjtmaWxsLW9wYWNpdHk6Ljh9LmN1c3RvbV9jb2xvcl9zb2xpZHtmaWxsOiNiM2IzYjN9LndoaXRlX3NvbGlke2ZpbGw6I2ZmZn0uYmxhY2tfc29saWRfZmluaXNoLC5ibGFja19zb2xpZF9zdGFydHtzdG9wLWNvbG9yOiMwMDB9LmJsYWNrX3NvbGlkX2ZpbmlzaHtzdG9wLW9wYWNpdHk6MH0uc2hhZG93e29wYWNpdHk6LjV9PC9zdHlsZT48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgMTMuNUMwIDYgNiAwIDEzLjUgMFMyNyA2IDI3IDEzLjUgMjAuOTYgMjcgMTMuNSAyNyAwIDIxIDAgMTMuNXptMjIgMGE4LjUgOC41IDAgMSAwLTE2Ljk5LS4wMUE4LjUgOC41IDAgMCAwIDIyIDEzLjV6Ii8+PGNpcmNsZSBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBjeD0iMTMuNSIgY3k9IjEzLjUiIHI9IjExLjUiLz48Y2lyY2xlIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgY3g9IjEzLjUiIGN5PSIxMy41IiByPSI4LjUiLz48Zz48bGluZWFyR3JhZGllbnQgaWQ9InNoYWRvdy1ncmFkaWVudCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSItMzQwIiB5MT0iMzkxLjkiIHgyPSItMzM5LjEiIHkyPSIzOTIuNyIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgyMS4yMTYxIDAgMCAtMjEuNzg3OSA3MjYyLjA0IDg1NzUuMTEpIj48c3RvcCBvZmZzZXQ9IjAiIGNsYXNzPSJibGFja19zb2xpZF9zdGFydCIvPjxzdG9wIG9mZnNldD0iMSIgY2xhc3M9ImJsYWNrX3NvbGlkX2ZpbmlzaCIvPjwvbGluZWFyR3JhZGllbnQ+PHBhdGggY2xhc3M9InNoYWRvdyIgZmlsbD0idXJsKCNzaGFkb3ctZ3JhZGllbnQpIiBkPSJNNDguNzIgMzkuN2M0LjcxLTIuNCAxNy44Mi0xMS41MiAxOC4zLTExLjk4LjU2LS41MiAxLjA3LTEuMDYgMS41LTEuNjIgMy00IDEuMTEtNy42Mi00LjQ0LTguMDMtLjQ3LS4wMy0xLjA2LS4xLTEuNjgtLjE2LS45NiAzLjQzLTMuMjIgNy42LTYuNDMgMTIuMzNhMTE0LjEyIDExNC4xMiAwIDAgMS02LjE0IDguMmwtLjU0LjY3Yy0uMTIuMTUtLjI3LjMyLS40Ny41LS4wMy0uMDEtLjAyLS4wMS0uMTIuMDZoLjAyeiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNMzYgMTMuNUMzNiA2IDQyIDAgNDkuNSAwYTEzLjQ0IDEzLjQ0IDAgMCAxIDEzLjMgMTUuODJsLjAyLjE2LS4wNC4yM2MtLjYgMy43LTMuMDYgOC40Ny02LjggMTRhMTE4LjM0IDExOC4zNCAwIDAgMS02LjE0IDguMjJjLS4yNS4zLS40NC41Mi0uNTUuN2EzLjU5IDMuNTkgMCAwIDEtMS4yLjk3Yy0uNC4yLS44Ni4yNy0xLjQuMmwtLjIxLS4wNGEyLjI5IDIuMjkgMCAwIDEtMS42Ni0xLjY4Yy0uMS0uNDQtLjEtLjgyIDAtMS4xOSAwLS4wNy4wMi0uMTMuMDQtLjE5bDIuNzctMTAuMjZBMTMuNjEgMTMuNjEgMCAwIDEgMzYgMTMuNXoiLz48cGF0aCBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBkPSJNMzggMTMuNUMzOCA3LjEgNDMuMSAyIDQ5LjUgMmExMS40NCAxMS40NCAwIDAgMSAxMS4yOCAxMy43di4xNUM1OS41IDIzLjg1IDQ3LjcgMzcuOCA0Ny43IDM3LjhzLS4zOC41Mi0uNzMuNGMtLjM3LS4xLS4yLS41Ni0uMi0uNTZsMy40Mi0xMi43MWMtLjIxLjA3LS40OS4wNy0uNjkuMDdDNDMuMTUgMjUgMzggMTkuOSAzOCAxMy41eiIvPjxjaXJjbGUgY2xhc3M9IndoaXRlX3NvbGlkIiBjeD0iNDkuNSIgY3k9IjEzLjUiIHI9IjguNSIvPjwvZz48Zz48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgNjBoMTIwdjJIMHpNMCA4NWgxMjB2MkgweiIvPjxwYXRoIGNsYXNzPSJjdXN0b21fY29sb3Jfc29saWQiIGQ9Ik0wIDYyaDEyMHYzSDB6TTAgODJoMTIwdjNIMHoiLz48cGF0aCBjbGFzcz0id2hpdGVfc29saWQiIGQ9Ik0wIDY1aDEyMHYxN0gweiIvPjwvZz48L3N2Zz4=)}.ymaps-2-1-42-placemark_theme_grey .ymaps-2-1-42-placemark__r{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTIwIDEwMCI+PHN0eWxlPi53aGl0ZV9vcGFjaXR5e2ZpbGw6I2ZmZjtmaWxsLW9wYWNpdHk6Ljh9LmN1c3RvbV9jb2xvcl9zb2xpZHtmaWxsOiNiM2IzYjN9LndoaXRlX3NvbGlke2ZpbGw6I2ZmZn0uYmxhY2tfc29saWRfZmluaXNoLC5ibGFja19zb2xpZF9zdGFydHtzdG9wLWNvbG9yOiMwMDB9LmJsYWNrX3NvbGlkX2ZpbmlzaHtzdG9wLW9wYWNpdHk6MH0uc2hhZG93e29wYWNpdHk6LjV9PC9zdHlsZT48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgMTMuNUMwIDYgNiAwIDEzLjUgMFMyNyA2IDI3IDEzLjUgMjAuOTYgMjcgMTMuNSAyNyAwIDIxIDAgMTMuNXptMjIgMGE4LjUgOC41IDAgMSAwLTE2Ljk5LS4wMUE4LjUgOC41IDAgMCAwIDIyIDEzLjV6Ii8+PGNpcmNsZSBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBjeD0iMTMuNSIgY3k9IjEzLjUiIHI9IjExLjUiLz48Y2lyY2xlIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgY3g9IjEzLjUiIGN5PSIxMy41IiByPSI4LjUiLz48Zz48bGluZWFyR3JhZGllbnQgaWQ9InNoYWRvdy1ncmFkaWVudDIiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iLTYwOC40IiB5MT0iMzU0LjEiIHgyPSItNjA3LjQiIHkyPSIzNTQuOSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgyMS4yMTYxIDAgMCAtMjEuNzg3OSAxMjk5MS4xNiA3NzUyLjY0KSI+PHN0b3Agb2Zmc2V0PSIwIiBjbGFzcz0iYmxhY2tfc29saWRfc3RhcnQiLz48c3RvcCBvZmZzZXQ9IjEiIGNsYXNzPSJibGFja19zb2xpZF9maW5pc2giLz48L2xpbmVhckdyYWRpZW50PjxwYXRoIGNsYXNzPSJzaGFkb3ciIGZpbGw9InVybCgjc2hhZG93LWdyYWRpZW50MikiIGQ9Ik04NC43MiAzOS43YzQuNy0yLjQgMTcuODItMTEuNTIgMTguMy0xMS45OGExMy44IDEzLjggMCAwIDAgMS41LTEuNjJjMy00IDEuMTEtNy42Mi00LjQ0LTguMDMtLjQ3LS4wMy0xLjA2LS4xLTEuNjgtLjE2LS45NiAzLjQzLTMuMjIgNy42LTYuNDMgMTIuMzNhMTE2Ljc5IDExNi43OSAwIDAgMS02LjE0IDguMmwtLjU1LjY3Yy0uMTEuMTUtLjI3LjMyLS40Ni41LS4wMy0uMDEtLjAyLS4wMS0uMTIuMDZoLjAyeiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNODAgMjV2MmgzLjZsLTIuNzQgMTAuMTNhMi41MyAyLjUzIDAgMCAwLS4wNSAxLjM4Yy4yLjguOCAxLjUgMS43IDEuNjhoLjJjLjU0LjEgMSAwIDEuNC0uMTcuMjYtLjEyLjUtLjI5LjczLS40OC4yLS4xNy4zNS0uMzQuNDYtLjVsLjU1LS42NWMuNDYtLjU3Ljk4LTEuMiAxLjUyLTEuOSAxLjU3LTIuMDIgMy4xNS00LjE1IDQuNjItNi4zMiAzLjc1LTUuNTIgNi4yMS0xMC4zIDYuOC0xNGwuMDQtLjIzLS4wMy0uMTJBMTMuNDQgMTMuNDQgMCAwIDAgODUuNSAwSDgwdjIiLz48cGF0aCBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBkPSJNODAgMjJ2M2g1LjVjLjI0IDAgLjQ4IDAgLjcxLS4wMmwtMy40MyAxMi43cy0uMTYuNS4yLjZjLjM1LjEuNzMtLjQuNzMtLjRTOTUuNTEgMjMuOSA5Ni44IDE1Ljg5bC0uMDItLjE1QTExLjQ0IDExLjQ0IDAgMCAwIDg1LjUgMkg4MHYzIi8+PHBhdGggY2xhc3M9IndoaXRlX3NvbGlkIiBkPSJNODUuNSA1SDgwdjE3aDUuNWE4LjUgOC41IDAgMCAwIDAtMTd6Ii8+PC9nPjxnPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNMCA2MGgxMjB2Mkgwek0wIDg1aDEyMHYySDB6Ii8+PHBhdGggY2xhc3M9ImN1c3RvbV9jb2xvcl9zb2xpZCIgZD0iTTAgNjJoMTIwdjNIMHpNMCA4MmgxMjB2M0gweiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgZD0iTTAgNjVoMTIwdjE3SDB6Ii8+PC9nPjwvc3ZnPg==)}.ymaps-2-1-42-placemark_theme_darkgreen,.ymaps-2-1-42-placemark_theme_darkgreen .ymaps-2-1-42-placemark__l,.ymaps-2-1-42-placemark_type_blank.ymaps-2-1-42-placemark_theme_darkgreen .ymaps-2-1-42-placemark__r{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTIwIDEwMCI+PHN0eWxlPi53aGl0ZV9vcGFjaXR5e2ZpbGw6I2ZmZjtmaWxsLW9wYWNpdHk6Ljh9LmN1c3RvbV9jb2xvcl9zb2xpZHtmaWxsOiMxYmFkMDN9LndoaXRlX3NvbGlke2ZpbGw6I2ZmZn0uYmxhY2tfc29saWRfZmluaXNoLC5ibGFja19zb2xpZF9zdGFydHtzdG9wLWNvbG9yOiMwMDB9LmJsYWNrX3NvbGlkX2ZpbmlzaHtzdG9wLW9wYWNpdHk6MH0uc2hhZG93e29wYWNpdHk6LjV9PC9zdHlsZT48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgMTMuNUMwIDYgNiAwIDEzLjUgMFMyNyA2IDI3IDEzLjUgMjAuOTYgMjcgMTMuNSAyNyAwIDIxIDAgMTMuNXptMjIgMGE4LjUgOC41IDAgMSAwLTE2Ljk5LS4wMUE4LjUgOC41IDAgMCAwIDIyIDEzLjV6Ii8+PGNpcmNsZSBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBjeD0iMTMuNSIgY3k9IjEzLjUiIHI9IjExLjUiLz48Y2lyY2xlIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgY3g9IjEzLjUiIGN5PSIxMy41IiByPSI4LjUiLz48Zz48bGluZWFyR3JhZGllbnQgaWQ9InNoYWRvdy1ncmFkaWVudCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSItMzQwIiB5MT0iMzkxLjkiIHgyPSItMzM5LjEiIHkyPSIzOTIuNyIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgyMS4yMTYxIDAgMCAtMjEuNzg3OSA3MjYyLjA0IDg1NzUuMTEpIj48c3RvcCBvZmZzZXQ9IjAiIGNsYXNzPSJibGFja19zb2xpZF9zdGFydCIvPjxzdG9wIG9mZnNldD0iMSIgY2xhc3M9ImJsYWNrX3NvbGlkX2ZpbmlzaCIvPjwvbGluZWFyR3JhZGllbnQ+PHBhdGggY2xhc3M9InNoYWRvdyIgZmlsbD0idXJsKCNzaGFkb3ctZ3JhZGllbnQpIiBkPSJNNDguNzIgMzkuN2M0LjcxLTIuNCAxNy44Mi0xMS41MiAxOC4zLTExLjk4LjU2LS41MiAxLjA3LTEuMDYgMS41LTEuNjIgMy00IDEuMTEtNy42Mi00LjQ0LTguMDMtLjQ3LS4wMy0xLjA2LS4xLTEuNjgtLjE2LS45NiAzLjQzLTMuMjIgNy42LTYuNDMgMTIuMzNhMTE0LjEyIDExNC4xMiAwIDAgMS02LjE0IDguMmwtLjU0LjY3Yy0uMTIuMTUtLjI3LjMyLS40Ny41LS4wMy0uMDEtLjAyLS4wMS0uMTIuMDZoLjAyeiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNMzYgMTMuNUMzNiA2IDQyIDAgNDkuNSAwYTEzLjQ0IDEzLjQ0IDAgMCAxIDEzLjMgMTUuODJsLjAyLjE2LS4wNC4yM2MtLjYgMy43LTMuMDYgOC40Ny02LjggMTRhMTE4LjM0IDExOC4zNCAwIDAgMS02LjE0IDguMjJjLS4yNS4zLS40NC41Mi0uNTUuN2EzLjU5IDMuNTkgMCAwIDEtMS4yLjk3Yy0uNC4yLS44Ni4yNy0xLjQuMmwtLjIxLS4wNGEyLjI5IDIuMjkgMCAwIDEtMS42Ni0xLjY4Yy0uMS0uNDQtLjEtLjgyIDAtMS4xOSAwLS4wNy4wMi0uMTMuMDQtLjE5bDIuNzctMTAuMjZBMTMuNjEgMTMuNjEgMCAwIDEgMzYgMTMuNXoiLz48cGF0aCBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBkPSJNMzggMTMuNUMzOCA3LjEgNDMuMSAyIDQ5LjUgMmExMS40NCAxMS40NCAwIDAgMSAxMS4yOCAxMy43di4xNUM1OS41IDIzLjg1IDQ3LjcgMzcuOCA0Ny43IDM3LjhzLS4zOC41Mi0uNzMuNGMtLjM3LS4xLS4yLS41Ni0uMi0uNTZsMy40Mi0xMi43MWMtLjIxLjA3LS40OS4wNy0uNjkuMDdDNDMuMTUgMjUgMzggMTkuOSAzOCAxMy41eiIvPjxjaXJjbGUgY2xhc3M9IndoaXRlX3NvbGlkIiBjeD0iNDkuNSIgY3k9IjEzLjUiIHI9IjguNSIvPjwvZz48Zz48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgNjBoMTIwdjJIMHpNMCA4NWgxMjB2MkgweiIvPjxwYXRoIGNsYXNzPSJjdXN0b21fY29sb3Jfc29saWQiIGQ9Ik0wIDYyaDEyMHYzSDB6TTAgODJoMTIwdjNIMHoiLz48cGF0aCBjbGFzcz0id2hpdGVfc29saWQiIGQ9Ik0wIDY1aDEyMHYxN0gweiIvPjwvZz48L3N2Zz4=)}.ymaps-2-1-42-placemark_theme_darkgreen .ymaps-2-1-42-placemark__r{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTIwIDEwMCI+PHN0eWxlPi53aGl0ZV9vcGFjaXR5e2ZpbGw6I2ZmZjtmaWxsLW9wYWNpdHk6Ljh9LmN1c3RvbV9jb2xvcl9zb2xpZHtmaWxsOiMxYmFkMDN9LndoaXRlX3NvbGlke2ZpbGw6I2ZmZn0uYmxhY2tfc29saWRfZmluaXNoLC5ibGFja19zb2xpZF9zdGFydHtzdG9wLWNvbG9yOiMwMDB9LmJsYWNrX3NvbGlkX2ZpbmlzaHtzdG9wLW9wYWNpdHk6MH0uc2hhZG93e29wYWNpdHk6LjV9PC9zdHlsZT48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgMTMuNUMwIDYgNiAwIDEzLjUgMFMyNyA2IDI3IDEzLjUgMjAuOTYgMjcgMTMuNSAyNyAwIDIxIDAgMTMuNXptMjIgMGE4LjUgOC41IDAgMSAwLTE2Ljk5LS4wMUE4LjUgOC41IDAgMCAwIDIyIDEzLjV6Ii8+PGNpcmNsZSBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBjeD0iMTMuNSIgY3k9IjEzLjUiIHI9IjExLjUiLz48Y2lyY2xlIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgY3g9IjEzLjUiIGN5PSIxMy41IiByPSI4LjUiLz48Zz48bGluZWFyR3JhZGllbnQgaWQ9InNoYWRvdy1ncmFkaWVudDIiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iLTYwOC40IiB5MT0iMzU0LjEiIHgyPSItNjA3LjQiIHkyPSIzNTQuOSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgyMS4yMTYxIDAgMCAtMjEuNzg3OSAxMjk5MS4xNiA3NzUyLjY0KSI+PHN0b3Agb2Zmc2V0PSIwIiBjbGFzcz0iYmxhY2tfc29saWRfc3RhcnQiLz48c3RvcCBvZmZzZXQ9IjEiIGNsYXNzPSJibGFja19zb2xpZF9maW5pc2giLz48L2xpbmVhckdyYWRpZW50PjxwYXRoIGNsYXNzPSJzaGFkb3ciIGZpbGw9InVybCgjc2hhZG93LWdyYWRpZW50MikiIGQ9Ik04NC43MiAzOS43YzQuNy0yLjQgMTcuODItMTEuNTIgMTguMy0xMS45OGExMy44IDEzLjggMCAwIDAgMS41LTEuNjJjMy00IDEuMTEtNy42Mi00LjQ0LTguMDMtLjQ3LS4wMy0xLjA2LS4xLTEuNjgtLjE2LS45NiAzLjQzLTMuMjIgNy42LTYuNDMgMTIuMzNhMTE2Ljc5IDExNi43OSAwIDAgMS02LjE0IDguMmwtLjU1LjY3Yy0uMTEuMTUtLjI3LjMyLS40Ni41LS4wMy0uMDEtLjAyLS4wMS0uMTIuMDZoLjAyeiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNODAgMjV2MmgzLjZsLTIuNzQgMTAuMTNhMi41MyAyLjUzIDAgMCAwLS4wNSAxLjM4Yy4yLjguOCAxLjUgMS43IDEuNjhoLjJjLjU0LjEgMSAwIDEuNC0uMTcuMjYtLjEyLjUtLjI5LjczLS40OC4yLS4xNy4zNS0uMzQuNDYtLjVsLjU1LS42NWMuNDYtLjU3Ljk4LTEuMiAxLjUyLTEuOSAxLjU3LTIuMDIgMy4xNS00LjE1IDQuNjItNi4zMiAzLjc1LTUuNTIgNi4yMS0xMC4zIDYuOC0xNGwuMDQtLjIzLS4wMy0uMTJBMTMuNDQgMTMuNDQgMCAwIDAgODUuNSAwSDgwdjIiLz48cGF0aCBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBkPSJNODAgMjJ2M2g1LjVjLjI0IDAgLjQ4IDAgLjcxLS4wMmwtMy40MyAxMi43cy0uMTYuNS4yLjZjLjM1LjEuNzMtLjQuNzMtLjRTOTUuNTEgMjMuOSA5Ni44IDE1Ljg5bC0uMDItLjE1QTExLjQ0IDExLjQ0IDAgMCAwIDg1LjUgMkg4MHYzIi8+PHBhdGggY2xhc3M9IndoaXRlX3NvbGlkIiBkPSJNODUuNSA1SDgwdjE3aDUuNWE4LjUgOC41IDAgMCAwIDAtMTd6Ii8+PC9nPjxnPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNMCA2MGgxMjB2Mkgwek0wIDg1aDEyMHYySDB6Ii8+PHBhdGggY2xhc3M9ImN1c3RvbV9jb2xvcl9zb2xpZCIgZD0iTTAgNjJoMTIwdjNIMHpNMCA4MmgxMjB2M0gweiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgZD0iTTAgNjVoMTIwdjE3SDB6Ii8+PC9nPjwvc3ZnPg==)}.ymaps-2-1-42-placemark_theme_violet,.ymaps-2-1-42-placemark_theme_violet .ymaps-2-1-42-placemark__l,.ymaps-2-1-42-placemark_type_blank.ymaps-2-1-42-placemark_theme_violet .ymaps-2-1-42-placemark__r{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTIwIDEwMCI+PHN0eWxlPi53aGl0ZV9vcGFjaXR5e2ZpbGw6I2ZmZjtmaWxsLW9wYWNpdHk6Ljh9LmN1c3RvbV9jb2xvcl9zb2xpZHtmaWxsOiNiNTFlZmZ9LndoaXRlX3NvbGlke2ZpbGw6I2ZmZn0uYmxhY2tfc29saWRfZmluaXNoLC5ibGFja19zb2xpZF9zdGFydHtzdG9wLWNvbG9yOiMwMDB9LmJsYWNrX3NvbGlkX2ZpbmlzaHtzdG9wLW9wYWNpdHk6MH0uc2hhZG93e29wYWNpdHk6LjV9PC9zdHlsZT48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgMTMuNUMwIDYgNiAwIDEzLjUgMFMyNyA2IDI3IDEzLjUgMjAuOTYgMjcgMTMuNSAyNyAwIDIxIDAgMTMuNXptMjIgMGE4LjUgOC41IDAgMSAwLTE2Ljk5LS4wMUE4LjUgOC41IDAgMCAwIDIyIDEzLjV6Ii8+PGNpcmNsZSBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBjeD0iMTMuNSIgY3k9IjEzLjUiIHI9IjExLjUiLz48Y2lyY2xlIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgY3g9IjEzLjUiIGN5PSIxMy41IiByPSI4LjUiLz48Zz48bGluZWFyR3JhZGllbnQgaWQ9InNoYWRvdy1ncmFkaWVudCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSItMzQwIiB5MT0iMzkxLjkiIHgyPSItMzM5LjEiIHkyPSIzOTIuNyIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgyMS4yMTYxIDAgMCAtMjEuNzg3OSA3MjYyLjA0IDg1NzUuMTEpIj48c3RvcCBvZmZzZXQ9IjAiIGNsYXNzPSJibGFja19zb2xpZF9zdGFydCIvPjxzdG9wIG9mZnNldD0iMSIgY2xhc3M9ImJsYWNrX3NvbGlkX2ZpbmlzaCIvPjwvbGluZWFyR3JhZGllbnQ+PHBhdGggY2xhc3M9InNoYWRvdyIgZmlsbD0idXJsKCNzaGFkb3ctZ3JhZGllbnQpIiBkPSJNNDguNzIgMzkuN2M0LjcxLTIuNCAxNy44Mi0xMS41MiAxOC4zLTExLjk4LjU2LS41MiAxLjA3LTEuMDYgMS41LTEuNjIgMy00IDEuMTEtNy42Mi00LjQ0LTguMDMtLjQ3LS4wMy0xLjA2LS4xLTEuNjgtLjE2LS45NiAzLjQzLTMuMjIgNy42LTYuNDMgMTIuMzNhMTE0LjEyIDExNC4xMiAwIDAgMS02LjE0IDguMmwtLjU0LjY3Yy0uMTIuMTUtLjI3LjMyLS40Ny41LS4wMy0uMDEtLjAyLS4wMS0uMTIuMDZoLjAyeiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNMzYgMTMuNUMzNiA2IDQyIDAgNDkuNSAwYTEzLjQ0IDEzLjQ0IDAgMCAxIDEzLjMgMTUuODJsLjAyLjE2LS4wNC4yM2MtLjYgMy43LTMuMDYgOC40Ny02LjggMTRhMTE4LjM0IDExOC4zNCAwIDAgMS02LjE0IDguMjJjLS4yNS4zLS40NC41Mi0uNTUuN2EzLjU5IDMuNTkgMCAwIDEtMS4yLjk3Yy0uNC4yLS44Ni4yNy0xLjQuMmwtLjIxLS4wNGEyLjI5IDIuMjkgMCAwIDEtMS42Ni0xLjY4Yy0uMS0uNDQtLjEtLjgyIDAtMS4xOSAwLS4wNy4wMi0uMTMuMDQtLjE5bDIuNzctMTAuMjZBMTMuNjEgMTMuNjEgMCAwIDEgMzYgMTMuNXoiLz48cGF0aCBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBkPSJNMzggMTMuNUMzOCA3LjEgNDMuMSAyIDQ5LjUgMmExMS40NCAxMS40NCAwIDAgMSAxMS4yOCAxMy43di4xNUM1OS41IDIzLjg1IDQ3LjcgMzcuOCA0Ny43IDM3LjhzLS4zOC41Mi0uNzMuNGMtLjM3LS4xLS4yLS41Ni0uMi0uNTZsMy40Mi0xMi43MWMtLjIxLjA3LS40OS4wNy0uNjkuMDdDNDMuMTUgMjUgMzggMTkuOSAzOCAxMy41eiIvPjxjaXJjbGUgY2xhc3M9IndoaXRlX3NvbGlkIiBjeD0iNDkuNSIgY3k9IjEzLjUiIHI9IjguNSIvPjwvZz48Zz48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgNjBoMTIwdjJIMHpNMCA4NWgxMjB2MkgweiIvPjxwYXRoIGNsYXNzPSJjdXN0b21fY29sb3Jfc29saWQiIGQ9Ik0wIDYyaDEyMHYzSDB6TTAgODJoMTIwdjNIMHoiLz48cGF0aCBjbGFzcz0id2hpdGVfc29saWQiIGQ9Ik0wIDY1aDEyMHYxN0gweiIvPjwvZz48L3N2Zz4=)}.ymaps-2-1-42-placemark_theme_violet .ymaps-2-1-42-placemark__r{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTIwIDEwMCI+PHN0eWxlPi53aGl0ZV9vcGFjaXR5e2ZpbGw6I2ZmZjtmaWxsLW9wYWNpdHk6Ljh9LmN1c3RvbV9jb2xvcl9zb2xpZHtmaWxsOiNiNTFlZmZ9LndoaXRlX3NvbGlke2ZpbGw6I2ZmZn0uYmxhY2tfc29saWRfZmluaXNoLC5ibGFja19zb2xpZF9zdGFydHtzdG9wLWNvbG9yOiMwMDB9LmJsYWNrX3NvbGlkX2ZpbmlzaHtzdG9wLW9wYWNpdHk6MH0uc2hhZG93e29wYWNpdHk6LjV9PC9zdHlsZT48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgMTMuNUMwIDYgNiAwIDEzLjUgMFMyNyA2IDI3IDEzLjUgMjAuOTYgMjcgMTMuNSAyNyAwIDIxIDAgMTMuNXptMjIgMGE4LjUgOC41IDAgMSAwLTE2Ljk5LS4wMUE4LjUgOC41IDAgMCAwIDIyIDEzLjV6Ii8+PGNpcmNsZSBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBjeD0iMTMuNSIgY3k9IjEzLjUiIHI9IjExLjUiLz48Y2lyY2xlIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgY3g9IjEzLjUiIGN5PSIxMy41IiByPSI4LjUiLz48Zz48bGluZWFyR3JhZGllbnQgaWQ9InNoYWRvdy1ncmFkaWVudDIiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iLTYwOC40IiB5MT0iMzU0LjEiIHgyPSItNjA3LjQiIHkyPSIzNTQuOSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgyMS4yMTYxIDAgMCAtMjEuNzg3OSAxMjk5MS4xNiA3NzUyLjY0KSI+PHN0b3Agb2Zmc2V0PSIwIiBjbGFzcz0iYmxhY2tfc29saWRfc3RhcnQiLz48c3RvcCBvZmZzZXQ9IjEiIGNsYXNzPSJibGFja19zb2xpZF9maW5pc2giLz48L2xpbmVhckdyYWRpZW50PjxwYXRoIGNsYXNzPSJzaGFkb3ciIGZpbGw9InVybCgjc2hhZG93LWdyYWRpZW50MikiIGQ9Ik04NC43MiAzOS43YzQuNy0yLjQgMTcuODItMTEuNTIgMTguMy0xMS45OGExMy44IDEzLjggMCAwIDAgMS41LTEuNjJjMy00IDEuMTEtNy42Mi00LjQ0LTguMDMtLjQ3LS4wMy0xLjA2LS4xLTEuNjgtLjE2LS45NiAzLjQzLTMuMjIgNy42LTYuNDMgMTIuMzNhMTE2Ljc5IDExNi43OSAwIDAgMS02LjE0IDguMmwtLjU1LjY3Yy0uMTEuMTUtLjI3LjMyLS40Ni41LS4wMy0uMDEtLjAyLS4wMS0uMTIuMDZoLjAyeiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNODAgMjV2MmgzLjZsLTIuNzQgMTAuMTNhMi41MyAyLjUzIDAgMCAwLS4wNSAxLjM4Yy4yLjguOCAxLjUgMS43IDEuNjhoLjJjLjU0LjEgMSAwIDEuNC0uMTcuMjYtLjEyLjUtLjI5LjczLS40OC4yLS4xNy4zNS0uMzQuNDYtLjVsLjU1LS42NWMuNDYtLjU3Ljk4LTEuMiAxLjUyLTEuOSAxLjU3LTIuMDIgMy4xNS00LjE1IDQuNjItNi4zMiAzLjc1LTUuNTIgNi4yMS0xMC4zIDYuOC0xNGwuMDQtLjIzLS4wMy0uMTJBMTMuNDQgMTMuNDQgMCAwIDAgODUuNSAwSDgwdjIiLz48cGF0aCBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBkPSJNODAgMjJ2M2g1LjVjLjI0IDAgLjQ4IDAgLjcxLS4wMmwtMy40MyAxMi43cy0uMTYuNS4yLjZjLjM1LjEuNzMtLjQuNzMtLjRTOTUuNTEgMjMuOSA5Ni44IDE1Ljg5bC0uMDItLjE1QTExLjQ0IDExLjQ0IDAgMCAwIDg1LjUgMkg4MHYzIi8+PHBhdGggY2xhc3M9IndoaXRlX3NvbGlkIiBkPSJNODUuNSA1SDgwdjE3aDUuNWE4LjUgOC41IDAgMCAwIDAtMTd6Ii8+PC9nPjxnPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNMCA2MGgxMjB2Mkgwek0wIDg1aDEyMHYySDB6Ii8+PHBhdGggY2xhc3M9ImN1c3RvbV9jb2xvcl9zb2xpZCIgZD0iTTAgNjJoMTIwdjNIMHpNMCA4MmgxMjB2M0gweiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgZD0iTTAgNjVoMTIwdjE3SDB6Ii8+PC9nPjwvc3ZnPg==)}.ymaps-2-1-42-placemark_theme_yellow,.ymaps-2-1-42-placemark_theme_yellow .ymaps-2-1-42-placemark__l,.ymaps-2-1-42-placemark_type_blank.ymaps-2-1-42-placemark_theme_yellow .ymaps-2-1-42-placemark__r{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTIwIDEwMCI+PHN0eWxlPi53aGl0ZV9vcGFjaXR5e2ZpbGw6I2ZmZjtmaWxsLW9wYWNpdHk6Ljh9LmN1c3RvbV9jb2xvcl9zb2xpZHtmaWxsOiNmZmQyMWV9LndoaXRlX3NvbGlke2ZpbGw6I2ZmZn0uYmxhY2tfc29saWRfZmluaXNoLC5ibGFja19zb2xpZF9zdGFydHtzdG9wLWNvbG9yOiMwMDB9LmJsYWNrX3NvbGlkX2ZpbmlzaHtzdG9wLW9wYWNpdHk6MH0uc2hhZG93e29wYWNpdHk6LjV9PC9zdHlsZT48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgMTMuNUMwIDYgNiAwIDEzLjUgMFMyNyA2IDI3IDEzLjUgMjAuOTYgMjcgMTMuNSAyNyAwIDIxIDAgMTMuNXptMjIgMGE4LjUgOC41IDAgMSAwLTE2Ljk5LS4wMUE4LjUgOC41IDAgMCAwIDIyIDEzLjV6Ii8+PGNpcmNsZSBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBjeD0iMTMuNSIgY3k9IjEzLjUiIHI9IjExLjUiLz48Y2lyY2xlIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgY3g9IjEzLjUiIGN5PSIxMy41IiByPSI4LjUiLz48Zz48bGluZWFyR3JhZGllbnQgaWQ9InNoYWRvdy1ncmFkaWVudCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSItMzQwIiB5MT0iMzkxLjkiIHgyPSItMzM5LjEiIHkyPSIzOTIuNyIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgyMS4yMTYxIDAgMCAtMjEuNzg3OSA3MjYyLjA0IDg1NzUuMTEpIj48c3RvcCBvZmZzZXQ9IjAiIGNsYXNzPSJibGFja19zb2xpZF9zdGFydCIvPjxzdG9wIG9mZnNldD0iMSIgY2xhc3M9ImJsYWNrX3NvbGlkX2ZpbmlzaCIvPjwvbGluZWFyR3JhZGllbnQ+PHBhdGggY2xhc3M9InNoYWRvdyIgZmlsbD0idXJsKCNzaGFkb3ctZ3JhZGllbnQpIiBkPSJNNDguNzIgMzkuN2M0LjcxLTIuNCAxNy44Mi0xMS41MiAxOC4zLTExLjk4LjU2LS41MiAxLjA3LTEuMDYgMS41LTEuNjIgMy00IDEuMTEtNy42Mi00LjQ0LTguMDMtLjQ3LS4wMy0xLjA2LS4xLTEuNjgtLjE2LS45NiAzLjQzLTMuMjIgNy42LTYuNDMgMTIuMzNhMTE0LjEyIDExNC4xMiAwIDAgMS02LjE0IDguMmwtLjU0LjY3Yy0uMTIuMTUtLjI3LjMyLS40Ny41LS4wMy0uMDEtLjAyLS4wMS0uMTIuMDZoLjAyeiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNMzYgMTMuNUMzNiA2IDQyIDAgNDkuNSAwYTEzLjQ0IDEzLjQ0IDAgMCAxIDEzLjMgMTUuODJsLjAyLjE2LS4wNC4yM2MtLjYgMy43LTMuMDYgOC40Ny02LjggMTRhMTE4LjM0IDExOC4zNCAwIDAgMS02LjE0IDguMjJjLS4yNS4zLS40NC41Mi0uNTUuN2EzLjU5IDMuNTkgMCAwIDEtMS4yLjk3Yy0uNC4yLS44Ni4yNy0xLjQuMmwtLjIxLS4wNGEyLjI5IDIuMjkgMCAwIDEtMS42Ni0xLjY4Yy0uMS0uNDQtLjEtLjgyIDAtMS4xOSAwLS4wNy4wMi0uMTMuMDQtLjE5bDIuNzctMTAuMjZBMTMuNjEgMTMuNjEgMCAwIDEgMzYgMTMuNXoiLz48cGF0aCBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBkPSJNMzggMTMuNUMzOCA3LjEgNDMuMSAyIDQ5LjUgMmExMS40NCAxMS40NCAwIDAgMSAxMS4yOCAxMy43di4xNUM1OS41IDIzLjg1IDQ3LjcgMzcuOCA0Ny43IDM3LjhzLS4zOC41Mi0uNzMuNGMtLjM3LS4xLS4yLS41Ni0uMi0uNTZsMy40Mi0xMi43MWMtLjIxLjA3LS40OS4wNy0uNjkuMDdDNDMuMTUgMjUgMzggMTkuOSAzOCAxMy41eiIvPjxjaXJjbGUgY2xhc3M9IndoaXRlX3NvbGlkIiBjeD0iNDkuNSIgY3k9IjEzLjUiIHI9IjguNSIvPjwvZz48Zz48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgNjBoMTIwdjJIMHpNMCA4NWgxMjB2MkgweiIvPjxwYXRoIGNsYXNzPSJjdXN0b21fY29sb3Jfc29saWQiIGQ9Ik0wIDYyaDEyMHYzSDB6TTAgODJoMTIwdjNIMHoiLz48cGF0aCBjbGFzcz0id2hpdGVfc29saWQiIGQ9Ik0wIDY1aDEyMHYxN0gweiIvPjwvZz48L3N2Zz4=)}.ymaps-2-1-42-placemark_theme_yellow .ymaps-2-1-42-placemark__r{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTIwIDEwMCI+PHN0eWxlPi53aGl0ZV9vcGFjaXR5e2ZpbGw6I2ZmZjtmaWxsLW9wYWNpdHk6Ljh9LmN1c3RvbV9jb2xvcl9zb2xpZHtmaWxsOiNmZmQyMWV9LndoaXRlX3NvbGlke2ZpbGw6I2ZmZn0uYmxhY2tfc29saWRfZmluaXNoLC5ibGFja19zb2xpZF9zdGFydHtzdG9wLWNvbG9yOiMwMDB9LmJsYWNrX3NvbGlkX2ZpbmlzaHtzdG9wLW9wYWNpdHk6MH0uc2hhZG93e29wYWNpdHk6LjV9PC9zdHlsZT48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgMTMuNUMwIDYgNiAwIDEzLjUgMFMyNyA2IDI3IDEzLjUgMjAuOTYgMjcgMTMuNSAyNyAwIDIxIDAgMTMuNXptMjIgMGE4LjUgOC41IDAgMSAwLTE2Ljk5LS4wMUE4LjUgOC41IDAgMCAwIDIyIDEzLjV6Ii8+PGNpcmNsZSBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBjeD0iMTMuNSIgY3k9IjEzLjUiIHI9IjExLjUiLz48Y2lyY2xlIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgY3g9IjEzLjUiIGN5PSIxMy41IiByPSI4LjUiLz48Zz48bGluZWFyR3JhZGllbnQgaWQ9InNoYWRvdy1ncmFkaWVudDIiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iLTYwOC40IiB5MT0iMzU0LjEiIHgyPSItNjA3LjQiIHkyPSIzNTQuOSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgyMS4yMTYxIDAgMCAtMjEuNzg3OSAxMjk5MS4xNiA3NzUyLjY0KSI+PHN0b3Agb2Zmc2V0PSIwIiBjbGFzcz0iYmxhY2tfc29saWRfc3RhcnQiLz48c3RvcCBvZmZzZXQ9IjEiIGNsYXNzPSJibGFja19zb2xpZF9maW5pc2giLz48L2xpbmVhckdyYWRpZW50PjxwYXRoIGNsYXNzPSJzaGFkb3ciIGZpbGw9InVybCgjc2hhZG93LWdyYWRpZW50MikiIGQ9Ik04NC43MiAzOS43YzQuNy0yLjQgMTcuODItMTEuNTIgMTguMy0xMS45OGExMy44IDEzLjggMCAwIDAgMS41LTEuNjJjMy00IDEuMTEtNy42Mi00LjQ0LTguMDMtLjQ3LS4wMy0xLjA2LS4xLTEuNjgtLjE2LS45NiAzLjQzLTMuMjIgNy42LTYuNDMgMTIuMzNhMTE2Ljc5IDExNi43OSAwIDAgMS02LjE0IDguMmwtLjU1LjY3Yy0uMTEuMTUtLjI3LjMyLS40Ni41LS4wMy0uMDEtLjAyLS4wMS0uMTIuMDZoLjAyeiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNODAgMjV2MmgzLjZsLTIuNzQgMTAuMTNhMi41MyAyLjUzIDAgMCAwLS4wNSAxLjM4Yy4yLjguOCAxLjUgMS43IDEuNjhoLjJjLjU0LjEgMSAwIDEuNC0uMTcuMjYtLjEyLjUtLjI5LjczLS40OC4yLS4xNy4zNS0uMzQuNDYtLjVsLjU1LS42NWMuNDYtLjU3Ljk4LTEuMiAxLjUyLTEuOSAxLjU3LTIuMDIgMy4xNS00LjE1IDQuNjItNi4zMiAzLjc1LTUuNTIgNi4yMS0xMC4zIDYuOC0xNGwuMDQtLjIzLS4wMy0uMTJBMTMuNDQgMTMuNDQgMCAwIDAgODUuNSAwSDgwdjIiLz48cGF0aCBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBkPSJNODAgMjJ2M2g1LjVjLjI0IDAgLjQ4IDAgLjcxLS4wMmwtMy40MyAxMi43cy0uMTYuNS4yLjZjLjM1LjEuNzMtLjQuNzMtLjRTOTUuNTEgMjMuOSA5Ni44IDE1Ljg5bC0uMDItLjE1QTExLjQ0IDExLjQ0IDAgMCAwIDg1LjUgMkg4MHYzIi8+PHBhdGggY2xhc3M9IndoaXRlX3NvbGlkIiBkPSJNODUuNSA1SDgwdjE3aDUuNWE4LjUgOC41IDAgMCAwIDAtMTd6Ii8+PC9nPjxnPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNMCA2MGgxMjB2Mkgwek0wIDg1aDEyMHYySDB6Ii8+PHBhdGggY2xhc3M9ImN1c3RvbV9jb2xvcl9zb2xpZCIgZD0iTTAgNjJoMTIwdjNIMHpNMCA4MmgxMjB2M0gweiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgZD0iTTAgNjVoMTIwdjE3SDB6Ii8+PC9nPjwvc3ZnPg==)}.ymaps-2-1-42-placemark_theme_green,.ymaps-2-1-42-placemark_theme_green .ymaps-2-1-42-placemark__l,.ymaps-2-1-42-placemark_type_blank.ymaps-2-1-42-placemark_theme_green .ymaps-2-1-42-placemark__r{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTIwIDEwMCI+PHN0eWxlPi53aGl0ZV9vcGFjaXR5e2ZpbGw6I2ZmZjtmaWxsLW9wYWNpdHk6Ljh9LmN1c3RvbV9jb2xvcl9zb2xpZHtmaWxsOiM1NmRiNDB9LndoaXRlX3NvbGlke2ZpbGw6I2ZmZn0uYmxhY2tfc29saWRfZmluaXNoLC5ibGFja19zb2xpZF9zdGFydHtzdG9wLWNvbG9yOiMwMDB9LmJsYWNrX3NvbGlkX2ZpbmlzaHtzdG9wLW9wYWNpdHk6MH0uc2hhZG93e29wYWNpdHk6LjV9PC9zdHlsZT48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgMTMuNUMwIDYgNiAwIDEzLjUgMFMyNyA2IDI3IDEzLjUgMjAuOTYgMjcgMTMuNSAyNyAwIDIxIDAgMTMuNXptMjIgMGE4LjUgOC41IDAgMSAwLTE2Ljk5LS4wMUE4LjUgOC41IDAgMCAwIDIyIDEzLjV6Ii8+PGNpcmNsZSBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBjeD0iMTMuNSIgY3k9IjEzLjUiIHI9IjExLjUiLz48Y2lyY2xlIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgY3g9IjEzLjUiIGN5PSIxMy41IiByPSI4LjUiLz48Zz48bGluZWFyR3JhZGllbnQgaWQ9InNoYWRvdy1ncmFkaWVudCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSItMzQwIiB5MT0iMzkxLjkiIHgyPSItMzM5LjEiIHkyPSIzOTIuNyIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgyMS4yMTYxIDAgMCAtMjEuNzg3OSA3MjYyLjA0IDg1NzUuMTEpIj48c3RvcCBvZmZzZXQ9IjAiIGNsYXNzPSJibGFja19zb2xpZF9zdGFydCIvPjxzdG9wIG9mZnNldD0iMSIgY2xhc3M9ImJsYWNrX3NvbGlkX2ZpbmlzaCIvPjwvbGluZWFyR3JhZGllbnQ+PHBhdGggY2xhc3M9InNoYWRvdyIgZmlsbD0idXJsKCNzaGFkb3ctZ3JhZGllbnQpIiBkPSJNNDguNzIgMzkuN2M0LjcxLTIuNCAxNy44Mi0xMS41MiAxOC4zLTExLjk4LjU2LS41MiAxLjA3LTEuMDYgMS41LTEuNjIgMy00IDEuMTEtNy42Mi00LjQ0LTguMDMtLjQ3LS4wMy0xLjA2LS4xLTEuNjgtLjE2LS45NiAzLjQzLTMuMjIgNy42LTYuNDMgMTIuMzNhMTE0LjEyIDExNC4xMiAwIDAgMS02LjE0IDguMmwtLjU0LjY3Yy0uMTIuMTUtLjI3LjMyLS40Ny41LS4wMy0uMDEtLjAyLS4wMS0uMTIuMDZoLjAyeiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNMzYgMTMuNUMzNiA2IDQyIDAgNDkuNSAwYTEzLjQ0IDEzLjQ0IDAgMCAxIDEzLjMgMTUuODJsLjAyLjE2LS4wNC4yM2MtLjYgMy43LTMuMDYgOC40Ny02LjggMTRhMTE4LjM0IDExOC4zNCAwIDAgMS02LjE0IDguMjJjLS4yNS4zLS40NC41Mi0uNTUuN2EzLjU5IDMuNTkgMCAwIDEtMS4yLjk3Yy0uNC4yLS44Ni4yNy0xLjQuMmwtLjIxLS4wNGEyLjI5IDIuMjkgMCAwIDEtMS42Ni0xLjY4Yy0uMS0uNDQtLjEtLjgyIDAtMS4xOSAwLS4wNy4wMi0uMTMuMDQtLjE5bDIuNzctMTAuMjZBMTMuNjEgMTMuNjEgMCAwIDEgMzYgMTMuNXoiLz48cGF0aCBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBkPSJNMzggMTMuNUMzOCA3LjEgNDMuMSAyIDQ5LjUgMmExMS40NCAxMS40NCAwIDAgMSAxMS4yOCAxMy43di4xNUM1OS41IDIzLjg1IDQ3LjcgMzcuOCA0Ny43IDM3LjhzLS4zOC41Mi0uNzMuNGMtLjM3LS4xLS4yLS41Ni0uMi0uNTZsMy40Mi0xMi43MWMtLjIxLjA3LS40OS4wNy0uNjkuMDdDNDMuMTUgMjUgMzggMTkuOSAzOCAxMy41eiIvPjxjaXJjbGUgY2xhc3M9IndoaXRlX3NvbGlkIiBjeD0iNDkuNSIgY3k9IjEzLjUiIHI9IjguNSIvPjwvZz48Zz48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgNjBoMTIwdjJIMHpNMCA4NWgxMjB2MkgweiIvPjxwYXRoIGNsYXNzPSJjdXN0b21fY29sb3Jfc29saWQiIGQ9Ik0wIDYyaDEyMHYzSDB6TTAgODJoMTIwdjNIMHoiLz48cGF0aCBjbGFzcz0id2hpdGVfc29saWQiIGQ9Ik0wIDY1aDEyMHYxN0gweiIvPjwvZz48L3N2Zz4=)}.ymaps-2-1-42-placemark_theme_green .ymaps-2-1-42-placemark__r{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTIwIDEwMCI+PHN0eWxlPi53aGl0ZV9vcGFjaXR5e2ZpbGw6I2ZmZjtmaWxsLW9wYWNpdHk6Ljh9LmN1c3RvbV9jb2xvcl9zb2xpZHtmaWxsOiM1NmRiNDB9LndoaXRlX3NvbGlke2ZpbGw6I2ZmZn0uYmxhY2tfc29saWRfZmluaXNoLC5ibGFja19zb2xpZF9zdGFydHtzdG9wLWNvbG9yOiMwMDB9LmJsYWNrX3NvbGlkX2ZpbmlzaHtzdG9wLW9wYWNpdHk6MH0uc2hhZG93e29wYWNpdHk6LjV9PC9zdHlsZT48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgMTMuNUMwIDYgNiAwIDEzLjUgMFMyNyA2IDI3IDEzLjUgMjAuOTYgMjcgMTMuNSAyNyAwIDIxIDAgMTMuNXptMjIgMGE4LjUgOC41IDAgMSAwLTE2Ljk5LS4wMUE4LjUgOC41IDAgMCAwIDIyIDEzLjV6Ii8+PGNpcmNsZSBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBjeD0iMTMuNSIgY3k9IjEzLjUiIHI9IjExLjUiLz48Y2lyY2xlIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgY3g9IjEzLjUiIGN5PSIxMy41IiByPSI4LjUiLz48Zz48bGluZWFyR3JhZGllbnQgaWQ9InNoYWRvdy1ncmFkaWVudDIiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iLTYwOC40IiB5MT0iMzU0LjEiIHgyPSItNjA3LjQiIHkyPSIzNTQuOSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgyMS4yMTYxIDAgMCAtMjEuNzg3OSAxMjk5MS4xNiA3NzUyLjY0KSI+PHN0b3Agb2Zmc2V0PSIwIiBjbGFzcz0iYmxhY2tfc29saWRfc3RhcnQiLz48c3RvcCBvZmZzZXQ9IjEiIGNsYXNzPSJibGFja19zb2xpZF9maW5pc2giLz48L2xpbmVhckdyYWRpZW50PjxwYXRoIGNsYXNzPSJzaGFkb3ciIGZpbGw9InVybCgjc2hhZG93LWdyYWRpZW50MikiIGQ9Ik04NC43MiAzOS43YzQuNy0yLjQgMTcuODItMTEuNTIgMTguMy0xMS45OGExMy44IDEzLjggMCAwIDAgMS41LTEuNjJjMy00IDEuMTEtNy42Mi00LjQ0LTguMDMtLjQ3LS4wMy0xLjA2LS4xLTEuNjgtLjE2LS45NiAzLjQzLTMuMjIgNy42LTYuNDMgMTIuMzNhMTE2Ljc5IDExNi43OSAwIDAgMS02LjE0IDguMmwtLjU1LjY3Yy0uMTEuMTUtLjI3LjMyLS40Ni41LS4wMy0uMDEtLjAyLS4wMS0uMTIuMDZoLjAyeiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNODAgMjV2MmgzLjZsLTIuNzQgMTAuMTNhMi41MyAyLjUzIDAgMCAwLS4wNSAxLjM4Yy4yLjguOCAxLjUgMS43IDEuNjhoLjJjLjU0LjEgMSAwIDEuNC0uMTcuMjYtLjEyLjUtLjI5LjczLS40OC4yLS4xNy4zNS0uMzQuNDYtLjVsLjU1LS42NWMuNDYtLjU3Ljk4LTEuMiAxLjUyLTEuOSAxLjU3LTIuMDIgMy4xNS00LjE1IDQuNjItNi4zMiAzLjc1LTUuNTIgNi4yMS0xMC4zIDYuOC0xNGwuMDQtLjIzLS4wMy0uMTJBMTMuNDQgMTMuNDQgMCAwIDAgODUuNSAwSDgwdjIiLz48cGF0aCBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBkPSJNODAgMjJ2M2g1LjVjLjI0IDAgLjQ4IDAgLjcxLS4wMmwtMy40MyAxMi43cy0uMTYuNS4yLjZjLjM1LjEuNzMtLjQuNzMtLjRTOTUuNTEgMjMuOSA5Ni44IDE1Ljg5bC0uMDItLjE1QTExLjQ0IDExLjQ0IDAgMCAwIDg1LjUgMkg4MHYzIi8+PHBhdGggY2xhc3M9IndoaXRlX3NvbGlkIiBkPSJNODUuNSA1SDgwdjE3aDUuNWE4LjUgOC41IDAgMCAwIDAtMTd6Ii8+PC9nPjxnPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNMCA2MGgxMjB2Mkgwek0wIDg1aDEyMHYySDB6Ii8+PHBhdGggY2xhc3M9ImN1c3RvbV9jb2xvcl9zb2xpZCIgZD0iTTAgNjJoMTIwdjNIMHpNMCA4MmgxMjB2M0gweiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgZD0iTTAgNjVoMTIwdjE3SDB6Ii8+PC9nPjwvc3ZnPg==)}.ymaps-2-1-42-placemark_theme_orange,.ymaps-2-1-42-placemark_theme_orange .ymaps-2-1-42-placemark__l,.ymaps-2-1-42-placemark_type_blank.ymaps-2-1-42-placemark_theme_orange .ymaps-2-1-42-placemark__r{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTIwIDEwMCI+PHN0eWxlPi53aGl0ZV9vcGFjaXR5e2ZpbGw6I2ZmZjtmaWxsLW9wYWNpdHk6Ljh9LmN1c3RvbV9jb2xvcl9zb2xpZHtmaWxsOiNmZjkzMWV9LndoaXRlX3NvbGlke2ZpbGw6I2ZmZn0uYmxhY2tfc29saWRfZmluaXNoLC5ibGFja19zb2xpZF9zdGFydHtzdG9wLWNvbG9yOiMwMDB9LmJsYWNrX3NvbGlkX2ZpbmlzaHtzdG9wLW9wYWNpdHk6MH0uc2hhZG93e29wYWNpdHk6LjV9PC9zdHlsZT48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgMTMuNUMwIDYgNiAwIDEzLjUgMFMyNyA2IDI3IDEzLjUgMjAuOTYgMjcgMTMuNSAyNyAwIDIxIDAgMTMuNXptMjIgMGE4LjUgOC41IDAgMSAwLTE2Ljk5LS4wMUE4LjUgOC41IDAgMCAwIDIyIDEzLjV6Ii8+PGNpcmNsZSBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBjeD0iMTMuNSIgY3k9IjEzLjUiIHI9IjExLjUiLz48Y2lyY2xlIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgY3g9IjEzLjUiIGN5PSIxMy41IiByPSI4LjUiLz48Zz48bGluZWFyR3JhZGllbnQgaWQ9InNoYWRvdy1ncmFkaWVudCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSItMzQwIiB5MT0iMzkxLjkiIHgyPSItMzM5LjEiIHkyPSIzOTIuNyIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgyMS4yMTYxIDAgMCAtMjEuNzg3OSA3MjYyLjA0IDg1NzUuMTEpIj48c3RvcCBvZmZzZXQ9IjAiIGNsYXNzPSJibGFja19zb2xpZF9zdGFydCIvPjxzdG9wIG9mZnNldD0iMSIgY2xhc3M9ImJsYWNrX3NvbGlkX2ZpbmlzaCIvPjwvbGluZWFyR3JhZGllbnQ+PHBhdGggY2xhc3M9InNoYWRvdyIgZmlsbD0idXJsKCNzaGFkb3ctZ3JhZGllbnQpIiBkPSJNNDguNzIgMzkuN2M0LjcxLTIuNCAxNy44Mi0xMS41MiAxOC4zLTExLjk4LjU2LS41MiAxLjA3LTEuMDYgMS41LTEuNjIgMy00IDEuMTEtNy42Mi00LjQ0LTguMDMtLjQ3LS4wMy0xLjA2LS4xLTEuNjgtLjE2LS45NiAzLjQzLTMuMjIgNy42LTYuNDMgMTIuMzNhMTE0LjEyIDExNC4xMiAwIDAgMS02LjE0IDguMmwtLjU0LjY3Yy0uMTIuMTUtLjI3LjMyLS40Ny41LS4wMy0uMDEtLjAyLS4wMS0uMTIuMDZoLjAyeiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNMzYgMTMuNUMzNiA2IDQyIDAgNDkuNSAwYTEzLjQ0IDEzLjQ0IDAgMCAxIDEzLjMgMTUuODJsLjAyLjE2LS4wNC4yM2MtLjYgMy43LTMuMDYgOC40Ny02LjggMTRhMTE4LjM0IDExOC4zNCAwIDAgMS02LjE0IDguMjJjLS4yNS4zLS40NC41Mi0uNTUuN2EzLjU5IDMuNTkgMCAwIDEtMS4yLjk3Yy0uNC4yLS44Ni4yNy0xLjQuMmwtLjIxLS4wNGEyLjI5IDIuMjkgMCAwIDEtMS42Ni0xLjY4Yy0uMS0uNDQtLjEtLjgyIDAtMS4xOSAwLS4wNy4wMi0uMTMuMDQtLjE5bDIuNzctMTAuMjZBMTMuNjEgMTMuNjEgMCAwIDEgMzYgMTMuNXoiLz48cGF0aCBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBkPSJNMzggMTMuNUMzOCA3LjEgNDMuMSAyIDQ5LjUgMmExMS40NCAxMS40NCAwIDAgMSAxMS4yOCAxMy43di4xNUM1OS41IDIzLjg1IDQ3LjcgMzcuOCA0Ny43IDM3LjhzLS4zOC41Mi0uNzMuNGMtLjM3LS4xLS4yLS41Ni0uMi0uNTZsMy40Mi0xMi43MWMtLjIxLjA3LS40OS4wNy0uNjkuMDdDNDMuMTUgMjUgMzggMTkuOSAzOCAxMy41eiIvPjxjaXJjbGUgY2xhc3M9IndoaXRlX3NvbGlkIiBjeD0iNDkuNSIgY3k9IjEzLjUiIHI9IjguNSIvPjwvZz48Zz48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgNjBoMTIwdjJIMHpNMCA4NWgxMjB2MkgweiIvPjxwYXRoIGNsYXNzPSJjdXN0b21fY29sb3Jfc29saWQiIGQ9Ik0wIDYyaDEyMHYzSDB6TTAgODJoMTIwdjNIMHoiLz48cGF0aCBjbGFzcz0id2hpdGVfc29saWQiIGQ9Ik0wIDY1aDEyMHYxN0gweiIvPjwvZz48L3N2Zz4=)}.ymaps-2-1-42-placemark_theme_orange .ymaps-2-1-42-placemark__r{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTIwIDEwMCI+PHN0eWxlPi53aGl0ZV9vcGFjaXR5e2ZpbGw6I2ZmZjtmaWxsLW9wYWNpdHk6Ljh9LmN1c3RvbV9jb2xvcl9zb2xpZHtmaWxsOiNmZjkzMWV9LndoaXRlX3NvbGlke2ZpbGw6I2ZmZn0uYmxhY2tfc29saWRfZmluaXNoLC5ibGFja19zb2xpZF9zdGFydHtzdG9wLWNvbG9yOiMwMDB9LmJsYWNrX3NvbGlkX2ZpbmlzaHtzdG9wLW9wYWNpdHk6MH0uc2hhZG93e29wYWNpdHk6LjV9PC9zdHlsZT48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgMTMuNUMwIDYgNiAwIDEzLjUgMFMyNyA2IDI3IDEzLjUgMjAuOTYgMjcgMTMuNSAyNyAwIDIxIDAgMTMuNXptMjIgMGE4LjUgOC41IDAgMSAwLTE2Ljk5LS4wMUE4LjUgOC41IDAgMCAwIDIyIDEzLjV6Ii8+PGNpcmNsZSBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBjeD0iMTMuNSIgY3k9IjEzLjUiIHI9IjExLjUiLz48Y2lyY2xlIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgY3g9IjEzLjUiIGN5PSIxMy41IiByPSI4LjUiLz48Zz48bGluZWFyR3JhZGllbnQgaWQ9InNoYWRvdy1ncmFkaWVudDIiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iLTYwOC40IiB5MT0iMzU0LjEiIHgyPSItNjA3LjQiIHkyPSIzNTQuOSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgyMS4yMTYxIDAgMCAtMjEuNzg3OSAxMjk5MS4xNiA3NzUyLjY0KSI+PHN0b3Agb2Zmc2V0PSIwIiBjbGFzcz0iYmxhY2tfc29saWRfc3RhcnQiLz48c3RvcCBvZmZzZXQ9IjEiIGNsYXNzPSJibGFja19zb2xpZF9maW5pc2giLz48L2xpbmVhckdyYWRpZW50PjxwYXRoIGNsYXNzPSJzaGFkb3ciIGZpbGw9InVybCgjc2hhZG93LWdyYWRpZW50MikiIGQ9Ik04NC43MiAzOS43YzQuNy0yLjQgMTcuODItMTEuNTIgMTguMy0xMS45OGExMy44IDEzLjggMCAwIDAgMS41LTEuNjJjMy00IDEuMTEtNy42Mi00LjQ0LTguMDMtLjQ3LS4wMy0xLjA2LS4xLTEuNjgtLjE2LS45NiAzLjQzLTMuMjIgNy42LTYuNDMgMTIuMzNhMTE2Ljc5IDExNi43OSAwIDAgMS02LjE0IDguMmwtLjU1LjY3Yy0uMTEuMTUtLjI3LjMyLS40Ni41LS4wMy0uMDEtLjAyLS4wMS0uMTIuMDZoLjAyeiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNODAgMjV2MmgzLjZsLTIuNzQgMTAuMTNhMi41MyAyLjUzIDAgMCAwLS4wNSAxLjM4Yy4yLjguOCAxLjUgMS43IDEuNjhoLjJjLjU0LjEgMSAwIDEuNC0uMTcuMjYtLjEyLjUtLjI5LjczLS40OC4yLS4xNy4zNS0uMzQuNDYtLjVsLjU1LS42NWMuNDYtLjU3Ljk4LTEuMiAxLjUyLTEuOSAxLjU3LTIuMDIgMy4xNS00LjE1IDQuNjItNi4zMiAzLjc1LTUuNTIgNi4yMS0xMC4zIDYuOC0xNGwuMDQtLjIzLS4wMy0uMTJBMTMuNDQgMTMuNDQgMCAwIDAgODUuNSAwSDgwdjIiLz48cGF0aCBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBkPSJNODAgMjJ2M2g1LjVjLjI0IDAgLjQ4IDAgLjcxLS4wMmwtMy40MyAxMi43cy0uMTYuNS4yLjZjLjM1LjEuNzMtLjQuNzMtLjRTOTUuNTEgMjMuOSA5Ni44IDE1Ljg5bC0uMDItLjE1QTExLjQ0IDExLjQ0IDAgMCAwIDg1LjUgMkg4MHYzIi8+PHBhdGggY2xhc3M9IndoaXRlX3NvbGlkIiBkPSJNODUuNSA1SDgwdjE3aDUuNWE4LjUgOC41IDAgMCAwIDAtMTd6Ii8+PC9nPjxnPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNMCA2MGgxMjB2Mkgwek0wIDg1aDEyMHYySDB6Ii8+PHBhdGggY2xhc3M9ImN1c3RvbV9jb2xvcl9zb2xpZCIgZD0iTTAgNjJoMTIwdjNIMHpNMCA4MmgxMjB2M0gweiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgZD0iTTAgNjVoMTIwdjE3SDB6Ii8+PC9nPjwvc3ZnPg==)}.ymaps-2-1-42-placemark_theme_lightblue,.ymaps-2-1-42-placemark_theme_lightblue .ymaps-2-1-42-placemark__l,.ymaps-2-1-42-placemark_type_blank.ymaps-2-1-42-placemark_theme_lightblue .ymaps-2-1-42-placemark__r{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTIwIDEwMCI+PHN0eWxlPi53aGl0ZV9vcGFjaXR5e2ZpbGw6I2ZmZjtmaWxsLW9wYWNpdHk6Ljh9LmN1c3RvbV9jb2xvcl9zb2xpZHtmaWxsOiM4MmNkZmZ9LndoaXRlX3NvbGlke2ZpbGw6I2ZmZn0uYmxhY2tfc29saWRfZmluaXNoLC5ibGFja19zb2xpZF9zdGFydHtzdG9wLWNvbG9yOiMwMDB9LmJsYWNrX3NvbGlkX2ZpbmlzaHtzdG9wLW9wYWNpdHk6MH0uc2hhZG93e29wYWNpdHk6LjV9PC9zdHlsZT48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgMTMuNUMwIDYgNiAwIDEzLjUgMFMyNyA2IDI3IDEzLjUgMjAuOTYgMjcgMTMuNSAyNyAwIDIxIDAgMTMuNXptMjIgMGE4LjUgOC41IDAgMSAwLTE2Ljk5LS4wMUE4LjUgOC41IDAgMCAwIDIyIDEzLjV6Ii8+PGNpcmNsZSBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBjeD0iMTMuNSIgY3k9IjEzLjUiIHI9IjExLjUiLz48Y2lyY2xlIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgY3g9IjEzLjUiIGN5PSIxMy41IiByPSI4LjUiLz48Zz48bGluZWFyR3JhZGllbnQgaWQ9InNoYWRvdy1ncmFkaWVudCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSItMzQwIiB5MT0iMzkxLjkiIHgyPSItMzM5LjEiIHkyPSIzOTIuNyIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgyMS4yMTYxIDAgMCAtMjEuNzg3OSA3MjYyLjA0IDg1NzUuMTEpIj48c3RvcCBvZmZzZXQ9IjAiIGNsYXNzPSJibGFja19zb2xpZF9zdGFydCIvPjxzdG9wIG9mZnNldD0iMSIgY2xhc3M9ImJsYWNrX3NvbGlkX2ZpbmlzaCIvPjwvbGluZWFyR3JhZGllbnQ+PHBhdGggY2xhc3M9InNoYWRvdyIgZmlsbD0idXJsKCNzaGFkb3ctZ3JhZGllbnQpIiBkPSJNNDguNzIgMzkuN2M0LjcxLTIuNCAxNy44Mi0xMS41MiAxOC4zLTExLjk4LjU2LS41MiAxLjA3LTEuMDYgMS41LTEuNjIgMy00IDEuMTEtNy42Mi00LjQ0LTguMDMtLjQ3LS4wMy0xLjA2LS4xLTEuNjgtLjE2LS45NiAzLjQzLTMuMjIgNy42LTYuNDMgMTIuMzNhMTE0LjEyIDExNC4xMiAwIDAgMS02LjE0IDguMmwtLjU0LjY3Yy0uMTIuMTUtLjI3LjMyLS40Ny41LS4wMy0uMDEtLjAyLS4wMS0uMTIuMDZoLjAyeiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNMzYgMTMuNUMzNiA2IDQyIDAgNDkuNSAwYTEzLjQ0IDEzLjQ0IDAgMCAxIDEzLjMgMTUuODJsLjAyLjE2LS4wNC4yM2MtLjYgMy43LTMuMDYgOC40Ny02LjggMTRhMTE4LjM0IDExOC4zNCAwIDAgMS02LjE0IDguMjJjLS4yNS4zLS40NC41Mi0uNTUuN2EzLjU5IDMuNTkgMCAwIDEtMS4yLjk3Yy0uNC4yLS44Ni4yNy0xLjQuMmwtLjIxLS4wNGEyLjI5IDIuMjkgMCAwIDEtMS42Ni0xLjY4Yy0uMS0uNDQtLjEtLjgyIDAtMS4xOSAwLS4wNy4wMi0uMTMuMDQtLjE5bDIuNzctMTAuMjZBMTMuNjEgMTMuNjEgMCAwIDEgMzYgMTMuNXoiLz48cGF0aCBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBkPSJNMzggMTMuNUMzOCA3LjEgNDMuMSAyIDQ5LjUgMmExMS40NCAxMS40NCAwIDAgMSAxMS4yOCAxMy43di4xNUM1OS41IDIzLjg1IDQ3LjcgMzcuOCA0Ny43IDM3LjhzLS4zOC41Mi0uNzMuNGMtLjM3LS4xLS4yLS41Ni0uMi0uNTZsMy40Mi0xMi43MWMtLjIxLjA3LS40OS4wNy0uNjkuMDdDNDMuMTUgMjUgMzggMTkuOSAzOCAxMy41eiIvPjxjaXJjbGUgY2xhc3M9IndoaXRlX3NvbGlkIiBjeD0iNDkuNSIgY3k9IjEzLjUiIHI9IjguNSIvPjwvZz48Zz48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgNjBoMTIwdjJIMHpNMCA4NWgxMjB2MkgweiIvPjxwYXRoIGNsYXNzPSJjdXN0b21fY29sb3Jfc29saWQiIGQ9Ik0wIDYyaDEyMHYzSDB6TTAgODJoMTIwdjNIMHoiLz48cGF0aCBjbGFzcz0id2hpdGVfc29saWQiIGQ9Ik0wIDY1aDEyMHYxN0gweiIvPjwvZz48L3N2Zz4=)}.ymaps-2-1-42-placemark_theme_lightblue .ymaps-2-1-42-placemark__r{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTIwIDEwMCI+PHN0eWxlPi53aGl0ZV9vcGFjaXR5e2ZpbGw6I2ZmZjtmaWxsLW9wYWNpdHk6Ljh9LmN1c3RvbV9jb2xvcl9zb2xpZHtmaWxsOiM4MmNkZmZ9LndoaXRlX3NvbGlke2ZpbGw6I2ZmZn0uYmxhY2tfc29saWRfZmluaXNoLC5ibGFja19zb2xpZF9zdGFydHtzdG9wLWNvbG9yOiMwMDB9LmJsYWNrX3NvbGlkX2ZpbmlzaHtzdG9wLW9wYWNpdHk6MH0uc2hhZG93e29wYWNpdHk6LjV9PC9zdHlsZT48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgMTMuNUMwIDYgNiAwIDEzLjUgMFMyNyA2IDI3IDEzLjUgMjAuOTYgMjcgMTMuNSAyNyAwIDIxIDAgMTMuNXptMjIgMGE4LjUgOC41IDAgMSAwLTE2Ljk5LS4wMUE4LjUgOC41IDAgMCAwIDIyIDEzLjV6Ii8+PGNpcmNsZSBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBjeD0iMTMuNSIgY3k9IjEzLjUiIHI9IjExLjUiLz48Y2lyY2xlIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgY3g9IjEzLjUiIGN5PSIxMy41IiByPSI4LjUiLz48Zz48bGluZWFyR3JhZGllbnQgaWQ9InNoYWRvdy1ncmFkaWVudDIiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iLTYwOC40IiB5MT0iMzU0LjEiIHgyPSItNjA3LjQiIHkyPSIzNTQuOSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgyMS4yMTYxIDAgMCAtMjEuNzg3OSAxMjk5MS4xNiA3NzUyLjY0KSI+PHN0b3Agb2Zmc2V0PSIwIiBjbGFzcz0iYmxhY2tfc29saWRfc3RhcnQiLz48c3RvcCBvZmZzZXQ9IjEiIGNsYXNzPSJibGFja19zb2xpZF9maW5pc2giLz48L2xpbmVhckdyYWRpZW50PjxwYXRoIGNsYXNzPSJzaGFkb3ciIGZpbGw9InVybCgjc2hhZG93LWdyYWRpZW50MikiIGQ9Ik04NC43MiAzOS43YzQuNy0yLjQgMTcuODItMTEuNTIgMTguMy0xMS45OGExMy44IDEzLjggMCAwIDAgMS41LTEuNjJjMy00IDEuMTEtNy42Mi00LjQ0LTguMDMtLjQ3LS4wMy0xLjA2LS4xLTEuNjgtLjE2LS45NiAzLjQzLTMuMjIgNy42LTYuNDMgMTIuMzNhMTE2Ljc5IDExNi43OSAwIDAgMS02LjE0IDguMmwtLjU1LjY3Yy0uMTEuMTUtLjI3LjMyLS40Ni41LS4wMy0uMDEtLjAyLS4wMS0uMTIuMDZoLjAyeiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNODAgMjV2MmgzLjZsLTIuNzQgMTAuMTNhMi41MyAyLjUzIDAgMCAwLS4wNSAxLjM4Yy4yLjguOCAxLjUgMS43IDEuNjhoLjJjLjU0LjEgMSAwIDEuNC0uMTcuMjYtLjEyLjUtLjI5LjczLS40OC4yLS4xNy4zNS0uMzQuNDYtLjVsLjU1LS42NWMuNDYtLjU3Ljk4LTEuMiAxLjUyLTEuOSAxLjU3LTIuMDIgMy4xNS00LjE1IDQuNjItNi4zMiAzLjc1LTUuNTIgNi4yMS0xMC4zIDYuOC0xNGwuMDQtLjIzLS4wMy0uMTJBMTMuNDQgMTMuNDQgMCAwIDAgODUuNSAwSDgwdjIiLz48cGF0aCBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBkPSJNODAgMjJ2M2g1LjVjLjI0IDAgLjQ4IDAgLjcxLS4wMmwtMy40MyAxMi43cy0uMTYuNS4yLjZjLjM1LjEuNzMtLjQuNzMtLjRTOTUuNTEgMjMuOSA5Ni44IDE1Ljg5bC0uMDItLjE1QTExLjQ0IDExLjQ0IDAgMCAwIDg1LjUgMkg4MHYzIi8+PHBhdGggY2xhc3M9IndoaXRlX3NvbGlkIiBkPSJNODUuNSA1SDgwdjE3aDUuNWE4LjUgOC41IDAgMCAwIDAtMTd6Ii8+PC9nPjxnPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNMCA2MGgxMjB2Mkgwek0wIDg1aDEyMHYySDB6Ii8+PHBhdGggY2xhc3M9ImN1c3RvbV9jb2xvcl9zb2xpZCIgZD0iTTAgNjJoMTIwdjNIMHpNMCA4MmgxMjB2M0gweiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgZD0iTTAgNjVoMTIwdjE3SDB6Ii8+PC9nPjwvc3ZnPg==)}.ymaps-2-1-42-placemark_theme_olive,.ymaps-2-1-42-placemark_theme_olive .ymaps-2-1-42-placemark__l,.ymaps-2-1-42-placemark_type_blank.ymaps-2-1-42-placemark_theme_olive .ymaps-2-1-42-placemark__r{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTIwIDEwMCI+PHN0eWxlPi53aGl0ZV9vcGFjaXR5e2ZpbGw6I2ZmZjtmaWxsLW9wYWNpdHk6Ljh9LmN1c3RvbV9jb2xvcl9zb2xpZHtmaWxsOiM5N2ExMDB9LndoaXRlX3NvbGlke2ZpbGw6I2ZmZn0uYmxhY2tfc29saWRfZmluaXNoLC5ibGFja19zb2xpZF9zdGFydHtzdG9wLWNvbG9yOiMwMDB9LmJsYWNrX3NvbGlkX2ZpbmlzaHtzdG9wLW9wYWNpdHk6MH0uc2hhZG93e29wYWNpdHk6LjV9PC9zdHlsZT48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgMTMuNUMwIDYgNiAwIDEzLjUgMFMyNyA2IDI3IDEzLjUgMjAuOTYgMjcgMTMuNSAyNyAwIDIxIDAgMTMuNXptMjIgMGE4LjUgOC41IDAgMSAwLTE2Ljk5LS4wMUE4LjUgOC41IDAgMCAwIDIyIDEzLjV6Ii8+PGNpcmNsZSBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBjeD0iMTMuNSIgY3k9IjEzLjUiIHI9IjExLjUiLz48Y2lyY2xlIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgY3g9IjEzLjUiIGN5PSIxMy41IiByPSI4LjUiLz48Zz48bGluZWFyR3JhZGllbnQgaWQ9InNoYWRvdy1ncmFkaWVudCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSItMzQwIiB5MT0iMzkxLjkiIHgyPSItMzM5LjEiIHkyPSIzOTIuNyIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgyMS4yMTYxIDAgMCAtMjEuNzg3OSA3MjYyLjA0IDg1NzUuMTEpIj48c3RvcCBvZmZzZXQ9IjAiIGNsYXNzPSJibGFja19zb2xpZF9zdGFydCIvPjxzdG9wIG9mZnNldD0iMSIgY2xhc3M9ImJsYWNrX3NvbGlkX2ZpbmlzaCIvPjwvbGluZWFyR3JhZGllbnQ+PHBhdGggY2xhc3M9InNoYWRvdyIgZmlsbD0idXJsKCNzaGFkb3ctZ3JhZGllbnQpIiBkPSJNNDguNzIgMzkuN2M0LjcxLTIuNCAxNy44Mi0xMS41MiAxOC4zLTExLjk4LjU2LS41MiAxLjA3LTEuMDYgMS41LTEuNjIgMy00IDEuMTEtNy42Mi00LjQ0LTguMDMtLjQ3LS4wMy0xLjA2LS4xLTEuNjgtLjE2LS45NiAzLjQzLTMuMjIgNy42LTYuNDMgMTIuMzNhMTE0LjEyIDExNC4xMiAwIDAgMS02LjE0IDguMmwtLjU0LjY3Yy0uMTIuMTUtLjI3LjMyLS40Ny41LS4wMy0uMDEtLjAyLS4wMS0uMTIuMDZoLjAyeiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNMzYgMTMuNUMzNiA2IDQyIDAgNDkuNSAwYTEzLjQ0IDEzLjQ0IDAgMCAxIDEzLjMgMTUuODJsLjAyLjE2LS4wNC4yM2MtLjYgMy43LTMuMDYgOC40Ny02LjggMTRhMTE4LjM0IDExOC4zNCAwIDAgMS02LjE0IDguMjJjLS4yNS4zLS40NC41Mi0uNTUuN2EzLjU5IDMuNTkgMCAwIDEtMS4yLjk3Yy0uNC4yLS44Ni4yNy0xLjQuMmwtLjIxLS4wNGEyLjI5IDIuMjkgMCAwIDEtMS42Ni0xLjY4Yy0uMS0uNDQtLjEtLjgyIDAtMS4xOSAwLS4wNy4wMi0uMTMuMDQtLjE5bDIuNzctMTAuMjZBMTMuNjEgMTMuNjEgMCAwIDEgMzYgMTMuNXoiLz48cGF0aCBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBkPSJNMzggMTMuNUMzOCA3LjEgNDMuMSAyIDQ5LjUgMmExMS40NCAxMS40NCAwIDAgMSAxMS4yOCAxMy43di4xNUM1OS41IDIzLjg1IDQ3LjcgMzcuOCA0Ny43IDM3LjhzLS4zOC41Mi0uNzMuNGMtLjM3LS4xLS4yLS41Ni0uMi0uNTZsMy40Mi0xMi43MWMtLjIxLjA3LS40OS4wNy0uNjkuMDdDNDMuMTUgMjUgMzggMTkuOSAzOCAxMy41eiIvPjxjaXJjbGUgY2xhc3M9IndoaXRlX3NvbGlkIiBjeD0iNDkuNSIgY3k9IjEzLjUiIHI9IjguNSIvPjwvZz48Zz48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgNjBoMTIwdjJIMHpNMCA4NWgxMjB2MkgweiIvPjxwYXRoIGNsYXNzPSJjdXN0b21fY29sb3Jfc29saWQiIGQ9Ik0wIDYyaDEyMHYzSDB6TTAgODJoMTIwdjNIMHoiLz48cGF0aCBjbGFzcz0id2hpdGVfc29saWQiIGQ9Ik0wIDY1aDEyMHYxN0gweiIvPjwvZz48L3N2Zz4=)}.ymaps-2-1-42-placemark_theme_olive .ymaps-2-1-42-placemark__r{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTIwIDEwMCI+PHN0eWxlPi53aGl0ZV9vcGFjaXR5e2ZpbGw6I2ZmZjtmaWxsLW9wYWNpdHk6Ljh9LmN1c3RvbV9jb2xvcl9zb2xpZHtmaWxsOiM5N2ExMDB9LndoaXRlX3NvbGlke2ZpbGw6I2ZmZn0uYmxhY2tfc29saWRfZmluaXNoLC5ibGFja19zb2xpZF9zdGFydHtzdG9wLWNvbG9yOiMwMDB9LmJsYWNrX3NvbGlkX2ZpbmlzaHtzdG9wLW9wYWNpdHk6MH0uc2hhZG93e29wYWNpdHk6LjV9PC9zdHlsZT48cGF0aCBjbGFzcz0id2hpdGVfb3BhY2l0eSIgZD0iTTAgMTMuNUMwIDYgNiAwIDEzLjUgMFMyNyA2IDI3IDEzLjUgMjAuOTYgMjcgMTMuNSAyNyAwIDIxIDAgMTMuNXptMjIgMGE4LjUgOC41IDAgMSAwLTE2Ljk5LS4wMUE4LjUgOC41IDAgMCAwIDIyIDEzLjV6Ii8+PGNpcmNsZSBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBjeD0iMTMuNSIgY3k9IjEzLjUiIHI9IjExLjUiLz48Y2lyY2xlIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgY3g9IjEzLjUiIGN5PSIxMy41IiByPSI4LjUiLz48Zz48bGluZWFyR3JhZGllbnQgaWQ9InNoYWRvdy1ncmFkaWVudDIiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iLTYwOC40IiB5MT0iMzU0LjEiIHgyPSItNjA3LjQiIHkyPSIzNTQuOSIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgyMS4yMTYxIDAgMCAtMjEuNzg3OSAxMjk5MS4xNiA3NzUyLjY0KSI+PHN0b3Agb2Zmc2V0PSIwIiBjbGFzcz0iYmxhY2tfc29saWRfc3RhcnQiLz48c3RvcCBvZmZzZXQ9IjEiIGNsYXNzPSJibGFja19zb2xpZF9maW5pc2giLz48L2xpbmVhckdyYWRpZW50PjxwYXRoIGNsYXNzPSJzaGFkb3ciIGZpbGw9InVybCgjc2hhZG93LWdyYWRpZW50MikiIGQ9Ik04NC43MiAzOS43YzQuNy0yLjQgMTcuODItMTEuNTIgMTguMy0xMS45OGExMy44IDEzLjggMCAwIDAgMS41LTEuNjJjMy00IDEuMTEtNy42Mi00LjQ0LTguMDMtLjQ3LS4wMy0xLjA2LS4xLTEuNjgtLjE2LS45NiAzLjQzLTMuMjIgNy42LTYuNDMgMTIuMzNhMTE2Ljc5IDExNi43OSAwIDAgMS02LjE0IDguMmwtLjU1LjY3Yy0uMTEuMTUtLjI3LjMyLS40Ni41LS4wMy0uMDEtLjAyLS4wMS0uMTIuMDZoLjAyeiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNODAgMjV2MmgzLjZsLTIuNzQgMTAuMTNhMi41MyAyLjUzIDAgMCAwLS4wNSAxLjM4Yy4yLjguOCAxLjUgMS43IDEuNjhoLjJjLjU0LjEgMSAwIDEuNC0uMTcuMjYtLjEyLjUtLjI5LjczLS40OC4yLS4xNy4zNS0uMzQuNDYtLjVsLjU1LS42NWMuNDYtLjU3Ljk4LTEuMiAxLjUyLTEuOSAxLjU3LTIuMDIgMy4xNS00LjE1IDQuNjItNi4zMiAzLjc1LTUuNTIgNi4yMS0xMC4zIDYuOC0xNGwuMDQtLjIzLS4wMy0uMTJBMTMuNDQgMTMuNDQgMCAwIDAgODUuNSAwSDgwdjIiLz48cGF0aCBjbGFzcz0iY3VzdG9tX2NvbG9yX3NvbGlkIiBkPSJNODAgMjJ2M2g1LjVjLjI0IDAgLjQ4IDAgLjcxLS4wMmwtMy40MyAxMi43cy0uMTYuNS4yLjZjLjM1LjEuNzMtLjQuNzMtLjRTOTUuNTEgMjMuOSA5Ni44IDE1Ljg5bC0uMDItLjE1QTExLjQ0IDExLjQ0IDAgMCAwIDg1LjUgMkg4MHYzIi8+PHBhdGggY2xhc3M9IndoaXRlX3NvbGlkIiBkPSJNODUuNSA1SDgwdjE3aDUuNWE4LjUgOC41IDAgMCAwIDAtMTd6Ii8+PC9nPjxnPjxwYXRoIGNsYXNzPSJ3aGl0ZV9vcGFjaXR5IiBkPSJNMCA2MGgxMjB2Mkgwek0wIDg1aDEyMHYySDB6Ii8+PHBhdGggY2xhc3M9ImN1c3RvbV9jb2xvcl9zb2xpZCIgZD0iTTAgNjJoMTIwdjNIMHpNMCA4MmgxMjB2M0gweiIvPjxwYXRoIGNsYXNzPSJ3aGl0ZV9zb2xpZCIgZD0iTTAgNjVoMTIwdjE3SDB6Ii8+PC9nPjwvc3ZnPg==)}", provide);
    });
  }],
  ['.H', function(ym) {
    ym.modules.define('placemark_type_blank', ['system.provideCss'], function(provide, provideCss) {
      provideCss(".ymaps-2-1-42-placemark_type_blank{width:28px;background-position:0 0;background-repeat:no-repeat}.ymaps-2-1-42-placemark_type_blank.ymaps-2-1-42-placemark_state_active{background-image:none;width:0}.ymaps-2-1-42-placemark_type_blank .ymaps-2-1-42-placemark__content{position:absolute;top:0;z-index:6;margin:0!important;width:27px;background:0 0}.ymaps-2-1-42-placemark_type_blank.ymaps-2-1-42-placemark_state_active .ymaps-2-1-42-placemark__content{left:-8px}.ymaps-2-1-42-placemark_type_blank .ymaps-2-1-42-placemark__l,.ymaps-2-1-42-placemark_type_blank .ymaps-2-1-42-placemark__r{display:none}.ymaps-2-1-42-placemark_state_active.ymaps-2-1-42-placemark_type_blank .ymaps-2-1-42-placemark__r{display:block;background-position:-36px 0!important;right:-28px;width:36px}", provide);
    });
  }],
  ['6g', function(ym) {
    ym.modules.define('placemarkNew.layout.html', ["placemark", "placemark_theme", "placemark_type_blank"], function(provide) {
      provide([0, "<ymaps class=\"ymaps-2-1-42-placemark ymaps-2-1-42-placemark_state_active ymaps-2-1-42-placemark_theme_blue\" style=\"right: 2px; bottom: 12px;\"><ymaps class=\"ymaps-2-1-42-placemark__l\"></ymaps><ymaps class=\"ymaps-2-1-42-placemark__r\"></ymaps><ymaps class=\"ymaps-2-1-42-placemark__content\"><ymaps class=\"ymaps-2-1-42-placemark__content-inner\">", 2002, ["options.contentLayout", [
        ["observeSize"],
        ["name", "\"iconContent\""],
        ["maxWidth", "options.maxWidth"]
      ]], 0, "</ymaps></ymaps></ymaps>"]);
    });
  }],
  ['6)', function(ym) {
    ym.modules.define("poi.dataSource", ["interactivityModel.storage", "interactivityModel.layer", "yandex.dataProvider", "projection.wgs84Mercator", "hotspot.layer.Object", "shape.Polygon", "geometry.pixel.Polygon", "event.Manager", "util.defineClass", "util.bounds", "util.cancelableCallback", "option.Manager", "yandex.layers"], function(e, t, s, i, o, a, r, n, h, u, l, p, c, g) {
      function _(e, t) {
        for (var s = [], i = 0, o = e.length; i < o; i++) s.push(d(e[i], t));
        return [].concat.apply([], s)
      }

      function d(e, t) {
        var s = [],
          i = e && e[t] && e[t].LayerMetaData;
        if (i)
          for (var o = 0, a = i.length; o < a; o++) {
            var r = i[o],
              n = [r && r.x, r && r.y],
              h = r && r.z;
            if (r && r.response && r.response.data)
              for (var u = r.response.data.features || [], l = 0, p = u.length; l < p; l++) {
                var c = u[l].geometry;
                c.coordinates && (c.coordinates = m ? [c.coordinates[0], c.coordinates[1]] : [c.coordinates[1], c.coordinates[0]]);
                var g = u[l].properties;
                if (g && g.HotspotMetaData && g.HotspotMetaData.TagsMetaData && g.HotspotMetaData.TagsMetaData.org_type) {
                  var _ = g.HotspotMetaData.TagsMetaData.org_type;
                  "string" == typeof _ && (g.rubrics = [_])
                }
                g.rubrics || (g.rubrics = []), s.push({
                  tileNumber: n,
                  zoom: h,
                  geometry: c,
                  properties: g
                })
              }
          }
        return s
      }

      function f(e, t) {
        var s = e.tileNumber,
          i = e.zoom,
          o = t - i,
          a = Math.pow(2, o);
        return [s[0] * a, s[1] * a]
      }

      function y(e, t) {
        for (var s = [], i = 0, o = e[0].length; i < o; i++) s.push([e[0][i][0] + t[0], e[0][i][1] + t[1]]);
        return [s]
      }
      var m = "latlong" == ym.env.coordinatesOrder,
        v = function(e, t) {
          this._map = e, this._mapListeners = this._map.events.group().add("boundschange", this._getPoi, this), this._shapesByTileNumber = {}, this._pendingRequests = [], this._isLoading = !1, this._currentZoom, this._inited = !1, this._queue = {}, this.options = new c(t), this._getPoi(), this.events = new h({
            context: this
          })
        };
      u(v, {
        destroy: function() {
          this._cancelRequests(), this._mapListeners.removeAll()
        },
        requestObjects: function(e, t, s, i) {
          if (null != this._currentZoom && Math.round(s) == Math.round(this._currentZoom)) {
            var o = t[0] + "_" + t[1],
              a = this._getShapesByTileNumber(e, o);
            a ? i(a) : this._isLoading ? this._queue.hasOwnProperty(o) ? this._queue[o].list.push(i) : this._queue[o] = {
              layer: e,
              list: [i]
            } : i([])
          } else i([])
        },
        cancelLastRequest: function() {},
        _getShapesByTileNumber: function(e, t) {
          var s, i = this._shapesByTileNumber[t];
          if (i && i.length) {
            s = [];
            for (var o = 0, a = i.length; o < a; o++) s.push(this._translateShape(e, i[o], this._currentZoom))
          }
          return s
        },
        _cancelRequests: function() {
          for (var e = 0, t = this._pendingRequests.length; e < t; e++) this._pendingRequests[e].cancel()
        },
        _getPoi: function() {
          function e(e) {
            var t = this.options.get("alias", "map") + "j";
            e.isRejected() || f.push(e.valueOf()), --d <= 0 && (f.length ? this._generateShapesByTileNumberCache(_(f, t)) : this._shapesByTileNumber = {}, this._callQueue(), this._isLoading = !1, this._pendingRequests = [], this._inited || (this._inited = !0, this.events.fire("update")))
          }
          this._cancelRequests();
          for (var t = this._map, s = "round" == t.options.get("tilesRoundingMethod", "round") ? Math.round(t.getZoom()) : Math.floor(t.getZoom()), o = this._getTileRanges(t.getBounds(), s), a = [], r = 0, n = o.length; r < n; r++) {
            var h = p.create(e, this),
              u = this.options.get("alias", "map"),
              l = {},
              c = g.getLayerVersion(u);
            u += "j", l[u + "_tile_range"] = o[r], l[u + "_version"] = c, i.getLayersInfo([u], t.getCenter(), s, null, l).always(h), a.push(h)
          }
          this._pendingRequests = a, this._currentZoom = s, this._isLoading = !0;
          var d = a.length,
            f = []
        },
        _generateShapesByTileNumberCache: function(e) {
          for (var t = {}, s = 0, i = e.length; s < i; s++) {
            var a = e[s],
              r = o.toGlobalPixels(a.geometry.coordinates, this._currentZoom),
              n = [Math.floor(r[0] / 256), Math.floor(r[1] / 256)],
              h = n[0] + "_" + n[1];
            t.hasOwnProperty(h) ? t[h].push(a) : t[h] = [a]
          }
          this._shapesByTileNumber = t
        },
        _callQueue: function() {
          for (var e in this._queue)
            if (this._queue.hasOwnProperty(e))
              for (var t = this._queue[e], s = this._getShapesByTileNumber(t.layer, e), i = 0, o = t.list.length; i < o; i++) t.list[i](s || []);
          this._queue = {}
        },
        _getTileRanges: function(e, t) {
          for (var s = l.toGlobalPixelBounds(e, t, o), i = this._splitPixelBounds(s, Math.pow(2, t + 8)), a = 0, r = i.length; a < r; a++) i[a][0][0] = Math.floor(i[a][0][0] / 256), i[a][1][0] = Math.floor(i[a][1][0] / 256), i[a][0][1] = Math.ceil(i[a][0][1] / 256), i[a][1][1] = Math.ceil(i[a][1][1] / 256);
          return i
        },
        _splitPixelBounds: function(e, t) {
          var s = e[0][1] > t,
            i = e[1][1] > t,
            o = [];
          return s && i ? o.push([
            [e[0][0], t - 1],
            [e[1][0], t - 1]
          ], [
            [0, e[0][1] - t],
            [e[1][0], t - 1]
          ], [
            [e[0][0], t - 1],
            [0, e[1][1] - t]
          ], [
            [0, e[0][1] - t],
            [0, e[1][1] - t]
          ]) : s ? o.push([
            [e[0][0], t - 1],
            [e[1][0], e[1][1]]
          ], [
            [0, e[0][1] - t],
            [e[1][0], e[1][1]]
          ]) : i ? o.push([
            [e[0][0], e[0][1]],
            [e[1][0], t - 1]
          ], [
            [e[0][0], e[0][1]],
            [0, e[1][1] - t]
          ]) : o.push(e), o
        },
        _translateShape: function(e, i, o) {
          var h = f(i, o),
            u = [256 * h[0], 256 * h[1]],
            l = i.properties.HotspotMetaData,
            p = l.RenderedGeometry.coordinates,
            c = y(p, u),
            g = e.options.get("interactivityModel") || s,
            _ = "string" == typeof g ? t.get(g) : g;
          return new a(new r(new n(c)), {
            geometry: i.geometry,
            properties: i.properties
          }, {
            zIndex: l.zIndex,
            interactivityModel: _
          })
        }
      }), e(v)
    });
  }],
  ['$M', function(ym) {
    ym.modules.define("Polygon", ["util.augment", "GeoObject"], function(e, n, o) {
      function t(e) {
        return e && "undefined" != typeof e.length ? {
          type: "Polygon",
          coordinates: e
        } : e
      }
      var r = function(e, n, o) {
        r.superclass.constructor.call(this, {
          geometry: t(e),
          properties: n
        }, o)
      };
      n(r, o), e(r)
    });
  }],
  ['$O', function(ym) {
    ym.modules.define("Polyline", ["util.augment", "GeoObject"], function(e, n, t) {
      function o(e) {
        return e && "undefined" != typeof e.length ? {
          type: "LineString",
          coordinates: e
        } : e
      }
      var i = function(e, n, t) {
        i.superclass.constructor.call(this, {
          geometry: o(e),
          properties: n
        }, t)
      };
      n(i, t), e(i)
    });
  }],
  ['6:', function(ym) {
    ym.modules.define("Popup", ["util.defineClass", "constants.mapDomEvents", "event.Manager", "geometry.pixel.Point", "option.Manager", "util.bind", "util.math.areEqual", "util.dom.element", "vow", "overlay.storage", "popup.states", "event.Mapper", "Event"], function(e, t, o, i, s, r, n, a, l, h, u, _, p, c) {
      function f(e, t) {
        this._map = e, this.events = new i({
          context: this
        }), this.options = new r(t), this._data = null, this._state = _.CLOSED, this._deferredOpen = null, this._deferredClose = null
      }

      function v(e) {
        this._popup = e, this._createMappings()
      }
      f.OpenError = function() {
        return new Error("Opening was canceled by another action")
      }, f.CloseError = function() {
        return new Error("Closing was canceled by another action")
      }, f.DestroyedError = function() {
        return new Error("Popup was destroyed")
      }, f.OverlayNotFound = function() {
        return new Error("Overlay wans't found")
      }, t(f, {
        open: function(e, t) {
          this._clearCloseAction();
          var o, i = h.defer(),
            s = i.promise();
          if (t && this.setData(t), e && (o = this.setPosition(e)), this._state == _.OPEN) o ? i.resolve(o) : i.resolve();
          else if (this._state == _.OPENING) i.resolve(this._deferredOpen.promise());
          else {
            this._clearOpenAction(), this._deferredOpen = i;
            var r = this.options.get("openTimeout");
            "number" == typeof r ? this._openTimeout = setTimeout(n(function() {
              this._openTimeout = null, i.resolve(this.doOpen())
            }, this), r) : i.resolve(this.doOpen()), s.then(this._onOpen, this)
          }
          return s
        },
        close: function(e) {
          e = e && "boolean" == typeof e, this._clearCloseAction(), this._clearOpenAction();
          var t = this._deferredClose = h.defer(),
            o = t.promise();
          if (this._state == _.OPEN) {
            var i = this.options.get("closeTimeout");
            "number" != typeof i || e ? t.resolve(this.doClose(e)) : this._closeTimeout = setTimeout(n(function() {
              this._closeTimeout = null, t.resolve(this.doClose(e))
            }, this), i), o.then(this._onClose, this)
          } else this._state = _.CLOSED, t.resolve();
          return o
        },
        isOpen: function() {
          return this._state == _.OPEN
        },
        getState: function() {
          return this._state
        },
        setPosition: function(e) {
          return this._position = e, this.setupGeometry(), h.resolve()
        },
        getPosition: function() {
          return this._position
        },
        setData: function(e) {
          return e && "object" == typeof e && !l.isNode(e) || (e = {
            content: e
          }), this._data = e, this._overlay && this._overlay.setData(this._data), h.resolve()
        },
        getData: function() {
          return this._data
        },
        getMap: function() {
          return this._map
        },
        getOverlay: function() {
          if (this._overlay) return h.resolve(this._overlay);
          if (this._overlayDeferred) return h.resolve(this._overlayDeferred.promise());
          var e = this._overlayDeferred = h.defer(),
            t = this.options.get("overlay"),
            o = {
              options: this.options
            },
            i = u.get(t, o);
          return "undefined" == typeof i ? u.require({
            keys: [t],
            data: o
          }).spread(function(t) {
            e.resolve(this._createOverlay(t))
          }, function() {
            e.reject(O)
          }, this) : e.resolve(this._createOverlay(i)), e.promise()
        },
        getOverlaySync: function() {
          return this._overlay
        },
        destroy: function() {
          this._clearCloseAction(), this._clearOpenAction(), this._clearOverlay(), this._state = _.DESTROYED
        },
        doOpen: function() {
          if ("DESTROYED" == this._state) return h.reject(m);
          var e = this.getOverlaySync();
          return e ? (this._state = _.OPEN, e.setMap(this._map), h.resolve()) : (this._state = _.OPENING, this.getOverlay().then(function(e) {
            this._state == _.OPENING && (this._state = _.OPEN, e.setMap(this._map))
          }, this))
        },
        doClose: function() {
          return this._state = _.CLOSED, this._overlay && this._overlay.setMap(null), h.resolve()
        },
        setupGeometry: function() {
          if (this._overlay) {
            var e = this._buildGeometry();
            this._geometry && a(this._geometry.getCoordinates(), e.getCoordinates()) || (this._overlay.setGeometry(e), this._geometry = e)
          }
        },
        _createOverlay: function(e) {
          this._geometry = this._buildGeometry();
          var t = this._overlay = new e(this._geometry, this._data);
          return t.options.setParent(this.options), t.events.setParent(new p(this.events, new v(this))), t
        },
        _clearOverlay: function() {
          this._overlay && (this._overlay.setMap(null), this._overlay.events.setParent(null), this._overlay = null)
        },
        _buildGeometry: function() {
          var e = this.options.get("projection");
          if (ym.env.debug) {
            if (!this._position) throw new Error("Popup.buildGeometry: Не заданы координаты.");
            if (!e) throw new Error("Popup.buildGeometry: Не задана проекция.")
          }
          return new s(e.toGlobalPixels(this._position, this._map.getZoom()))
        },
        _clearOpenAction: function() {
          this._openTimeout && (clearTimeout(this._openTimeout), this._openTimeout = null), this._deferredOpen && this._deferredOpen.reject(d)
        },
        _clearCloseAction: function() {
          this._closeTimeout && (clearTimeout(this._closeTimeout), this._closeTimeout = null), this._deferredClose && this._deferredClose.reject(y)
        },
        _onOpen: function() {
          this._state == _.OPEN && this.events.fire("open")
        },
        _onClose: function() {
          this._state == _.CLOSED && this.events.fire("close")
        }
      });
      var d = f.OpenError(),
        y = f.CloseError(),
        m = f.DestroyedError(),
        O = f.OverlayNotFound();
      t(v, {
        _createMappings: function() {
          for (var e = 0, t = o.length; e < t; e++) this[o[e]] = this._defaultMapping
        },
        _defaultMapping: function(e) {
          return new c({
            type: e.get("type"),
            target: this._popup,
            domEvent: e.get("domEvent")
          }, e)
        }
      }), e(f)
    });
  }],
  ['6@', function(ym) {
    ym.modules.define("popup.addonBuilder", ["event.Mapper", "popup.managerStorage", "util.defineProperty", "util.id", "Event"], function(e, t, n, a, r, o) {
      function i(e, t) {
        return e + t.charAt(0).toUpperCase() + t.substring(1)
      }

      function g(e) {
        return "string" == typeof e && (e = n.get(e)), e
      }

      function s(e) {
        function t(e) {
          var t = e.get("target");
          s(t), t.events && t.events.add("optionschange", f)
        }

        function n(e) {
          var t = e.get("target");
          v(t), t.events && t.events.remove("optionschange", f)
        }

        function s(e) {
          var t = r.get(e),
            n = !!e.options.get(M, !0);
          if (!b[t] && n) {
            var o = b[t] = {
              managerClass: g(e.options.get(h, E))
            };
            y ? a(e, l, function() {
              return o.manager || (o.manager = p(e, o.managerClass))
            }, null, {
              configurable: !0
            }) : e[l] = p(e, o.managerClass)
          }
        }

        function v(e) {
          var t = r.get(e),
            n = b[t];
          if (n) {
            var a = y ? n.manager : e[l];
            a && (m && a.events.remove(m, c, e), a.destroy()), delete b[t], delete e[l]
          }
        }

        function p(e, t) {
          if (ym.env.debug && "function" != typeof t) throw new Error("popup.addonBuilder.initManager: Не удалось получить конструктор менеджера инфо-объекта.");
          var n = new t(e);
          return m && n.events.add(m, c, e), n
        }

        function d(e) {
          return e[l] || s(e), e[l]
        }

        function f(e) {
          var t = e.get("target"),
            n = b[r.get(t)],
            a = !!t.options.get(M, !0);
          if (a) {
            var o = g(t.options.get(h, E));
            n ? n.managerClass != o && (v(t), s(t)) : s(t)
          } else n && v(t)
        }

        function c(e) {
          var t = l + e.get("type");
          this.events.fire(t, new o({
            type: t,
            currentTarget: this.events.params.context
          }, e))
        }
        var l = e.type,
          m = e.fireEvents || ["open", "close"],
          y = e.lazyInit && u,
          E = e.defaultManager,
          M = i("has", l),
          h = e.popupManagerOption || l + "Manager",
          b = {};
        return e.metaEventManager && (e.metaEventManager.add("create", t).add("destroy", n), y && e.initEvents && e.metaEventManager.add(e.initEvents, function(e) {
          d(e.get("target"))
        })), {
          get: d
        }
      }
      var u = !ym.env.browser.oldIE;
      e({
        build: s
      })
    });
  }],
  ['6j', function(ym) {
    ym.modules.define("popup.component.checkEmptiness", ["overlay.storage", "vow", "Hint", "Balloon"], function(e, n, t, o, s) {
      e(function(e, i, r, c) {
        function p(n) {
          if (n.hasOwnProperty("checkEmptiness")) a.resolve(n.checkEmptiness(c));
          else {
            var t = "hint" == i ? new o(e) : new s(e);
            t.setPosition(r), t.setData(c), t.options.setParent(c.options), t.getOverlay().done(function(e) {
              a.resolve(e.isEmpty())
            }, function(e) {
              a.reject(e)
            })
          }
        }
        var a = t.defer(),
          f = c.options.get("overlay"),
          u = n.get(f, c);
        return "undefined" == typeof u ? n.require({
          keys: [f],
          data: c
        }).spread(p, function(e) {
          a.reject(e)
        }, this).done() : p(u), a.promise()
      })
    });
  }],
  ['6z', function(ym) {
    ym.modules.define("popup.managerStorage", ["util.Storage"], function(e, n) {
      e(new n)
    });
  }],
  ['6I', function(ym) {
    ym.modules.define("popup.states", [], function(E) {
      E({
        OPENING: "OPENING",
        OPEN: "OPEN",
        CLOSED: "CLOSED",
        DESTROYED: "DESTROYED"
      })
    });
  }],
  ['6Z', function(ym) {
    ym.modules.define("projection.Cartesian", ["util.defineClass", "util.math.cycleRestrict", "coordSystem.Cartesian"], function(e, t, o, n) {
      function i(e, t, o) {
        if (ym.env.debug && (e[0][0] == e[1][0] || e[0][1] == e[1][1])) throw new Error("projection.Cartesian: Некорректные значения параметра bounds. Координаты углов не должны совпадать.");
        r && (e = [
          [e[0][1], e[0][0]],
          [e[1][1], e[1][0]]
        ]), this._bounds = e, this._cycled = t ? t : [!1, !1], this._xRange = e[1][0] - e[0][0], this._yRange = e[1][1] - e[0][1], this._coordSystem = new n(o)
      }
      var r = "latlong" == ym.env.coordinatesOrder;
      t(i, {
        toGlobalPixels: function(e, t) {
          if (ym.env.debug) {
            if (!e) throw new Error("Cartesian.toGlobalPixels: не передан параметр point");
            if ("undefined" == typeof t) throw new Error("Cartesian.toGlobalPixels: не передан параметр zoom")
          }
          var o = this._bounds,
            n = Math.pow(2, t + 8),
            i = e[r ? 1 : 0],
            s = e[r ? 0 : 1];
          return [(i - o[0][0]) / this._xRange * n, (o[1][1] - s) / this._yRange * n]
        },
        fromGlobalPixels: function(e, t) {
          if (ym.env.debug) {
            if (!e) throw new Error("Cartesian.fromGlobalPixels: не передан параметр point");
            if ("undefined" == typeof t) throw new Error("Cartesian.fromGlobalPixels: не передан параметр zoom")
          }
          var o = this._bounds,
            n = Math.pow(2, t + 8),
            i = ("latlong" == ym.env.coordinatesOrder, [e[0] * this._xRange / n + o[0][0], o[1][1] - this._yRange * e[1] / n]);
          return i = this._getFixedPoint(i), r ? [i[1], i[0]] : i
        },
        isCycled: function() {
          return this._cycled
        },
        getCoordSystem: function() {
          return this._coordSystem
        },
        _getFixedPoint: function(e) {
          var t = this._bounds;
          return [this._cycled[0] ? o(e[0], t[0][0], t[1][0]) : e[0], this._cycled[1] ? o(e[1], t[0][1], t[1][1]) : e[1]]
        }
      }), e(i)
    });
  }],
  ['7a', function(ym) {
    ym.modules.define("projection.GeoToGlobalPixels", ["projection.Mercator", "coordSystem.geo", "util.math.cycleRestrict"], function(o, e, t, r) {
      o(function(o) {
        var i = o && o.radius || 6378137,
          l = 2 * Math.PI * i,
          a = 1 / l,
          n = l / 2,
          s = 0,
          h = 180 / Math.PI,
          f = 256 * a,
          c = o && "latlong" == o.coordinatesOrder;
        this._mercator = new e(o), this.fromGlobalPixels = function(o, e) {
          if (ym.env.debug) {
            if (!o) throw new Error("GeoToGlobalPixels.fromGlobalPixels: не передан параметр vector");
            if ("undefined" == typeof e) throw new Error("GeoToGlobalPixels.fromGlobalPixels: не передан параметр zoom")
          }
          e != s && (f = Math.pow(2, e + 8) * a, s = e);
          var t = this._globalPixelXToGeo(o[0], e),
            r = this._mercator.yToLatitude(n - o[1] / f);
          return c ? [r, t] : [t, r]
        }, this.toGlobalPixels = function(o, e) {
          if (ym.env.debug) {
            if (!o) throw new Error("GeoToGlobalPixels.toGlobalPixels: не передан параметр point");
            if ("undefined" == typeof e) throw new Error("GeoToGlobalPixels.toGlobalPixels: не передан параметр zoom")
          }
          e != s && (f = Math.pow(2, e + 8) * a, s = e);
          var t = this._mercator.geoToMercator(o);
          return [(n + t[0]) * f, (n - t[1]) * f]
        }, this.distanceToGlobalPixels = function(o, e, t) {
          if (ym.env.debug) {
            if (!o) throw new Error("GeoToGlobalPixels.distanceToGlobalPixels: не передан параметр point");
            if ("undefined" == typeof t) throw new Error("GeoToGlobalPixels.distanceToGlobalPixels: не передан параметр zoom")
          }
          var r = l * Math.cos(o[c ? 0 : 1] * Math.PI / 180) / Math.pow(2, t + 8);
          return Math.abs(e / r)
        }, this.isCycled = function() {
          return [!0, !1]
        }, this.getCoordSystem = function() {
          return t
        }, this._globalPixelXToGeo = function(o, e) {
          return r(Math.PI * o / Math.pow(2, e + 7) - Math.PI, -Math.PI, Math.PI) * h
        }
      })
    });
  }],
  ['7d', function(ym) {
    ym.modules.define("projection.idle", ["coordSystem.cartesian"], function(e, n) {
      e({
        toGlobalPixels: function(e, n) {
          return e.slice()
        },
        fromGlobalPixels: function(e, n) {
          return e.slice()
        },
        isCycled: function() {
          return [!1, !1]
        },
        getCoordSystem: function() {
          return n
        }
      })
    });
  }],
  ['7e', function(ym) {
    ym.modules.define("projection.Mercator", ["util.math.restrict", "util.math.cycleRestrict"], function(t, a, i) {
      t(function(t) {
        var n = t && t.radius || 6378137,
          o = t && "undefined" != typeof t.e ? t.e : .0818191908426,
          e = t && "latlong" == t.coordinatesOrder,
          h = o * o,
          r = h * h,
          u = r * h,
          M = r * r,
          s = 1 / n,
          c = h / 2 + 5 * r / 24 + u / 12 + 13 * M / 360,
          d = 7 * r / 48 + 29 * u / 240 + 811 * M / 11520,
          f = 7 * u / 120 + 81 * M / 1120,
          l = 4279 * M / 161280,
          T = Math.PI / 180,
          I = 180 / Math.PI;
        this.mercatorToGeo = function(t) {
          var a = this.xToLongitude(t[0]),
            i = this.yToLatitude(t[1]);
          return e ? [i, a] : [a, i]
        }, this.geoToMercator = function(t) {
          return [this.longitudeToX(t[e ? 1 : 0]), this.latitudeToY(t[e ? 0 : 1])]
        }, this.xToLongitude = function(t) {
          return i(t * s, -Math.PI, Math.PI) * I
        }, this.yToLatitude = function(t) {
          var a = .5 * Math.PI - 2 * Math.atan(1 / Math.exp(t * s)),
            i = a + c * Math.sin(2 * a) + d * Math.sin(4 * a) + f * Math.sin(6 * a) + l * Math.sin(8 * a);
          return i * I
        }, this.longitudeToX = function(t) {
          var a = i(t * T, -Math.PI, Math.PI);
          return n * a
        }, this.latitudeToY = function(t) {
          var i = 1e-10,
            e = a(t, -90 + i, 90 - i) * T,
            h = o * Math.sin(e),
            r = Math.tan(.25 * Math.PI + .5 * e),
            u = Math.pow(Math.tan(.25 * Math.PI + .5 * Math.asin(h)), o),
            M = r / u;
          return n * Math.log(M)
        }
      })
    });
  }],
  ['7g', function(ym) {
    ym.modules.define("projection.sphericalMercator", ["projection.GeoToGlobalPixels"], function(e, o) {
      e(new o({
        e: 0,
        coordinatesOrder: ym.env.coordinatesOrder
      }))
    });
  }],
  ['7k', function(ym) {
    ym.modules.define("projection.wgs84Mercator", ["projection.GeoToGlobalPixels"], function(e, o) {
      e(new o({
        coordinatesOrder: ym.env.coordinatesOrder
      }))
    });
  }],
  ['7n', function(ym) {
    ym.modules.define("projection.zeroZoom", ["coordSystem.cartesian"], function(o, n) {
      o({
        toGlobalPixels: function(o, n) {
          var t = Math.pow(2, n);
          return [o[0] * t, o[1] * t]
        },
        fromGlobalPixels: function(o, n) {
          var t = Math.pow(2, -n);
          return [o[0] * t, o[1] * t]
        },
        isCycled: function() {
          return [!1, !1]
        },
        getCoordSystem: function() {
          return n
        }
      })
    });
  }],
  ['2e', function(ym) {
    ym.modules.define("ReadOnlyCollection", ["util.defineClass", "component.collection.BaseCollection", "event.Manager", "Event", "option.Manager"], function(e, t, n, o, i, c) {
      var l = function(e) {
        this.events = new o({
          context: this
        }), this.options = new c, this._collectionComponent = new n({
          onAdd: {
            callback: this.onChildAdd,
            context: this
          },
          onRemove: {
            callback: this.onChildRemove,
            context: this
          }
        }), this._editingEventManager = e, this._editingEventManager.add("add", this._addObject, this).add("remove", this._removeObject, this).add("removeall", this._removeAll, this)
      };
      t(l, {
        getLength: function() {
          return this._collectionComponent.getLength()
        },
        getIterator: function() {
          return this._collectionComponent.getIterator()
        },
        each: function(e, t) {
          this._collectionComponent.each(e, t)
        },
        getAll: function() {
          for (var e, t = this.getIterator(), n = [];
            (e = t.getNext()) != t.STOP_ITERATION;) n.push(e);
          return n
        },
        _addObject: function(e) {
          this._collectionComponent.add(e.get("object"))
        },
        _removeObject: function(e) {
          this._collectionComponent.remove(e.get("object"))
        },
        _removeAll: function() {
          this._collectionComponent.removeAll()
        },
        onChildAdd: function(e) {
          var t = new i({
            type: "add",
            target: this,
            child: e
          });
          this.events.fire("add", t)
        },
        onChildRemove: function(e) {
          var t = new i({
            type: "remove",
            target: this,
            child: e
          });
          this.events.fire("remove", t)
        }
      }), e(l)
    });
  }],
  ['$P', function(ym) {
    ym.modules.define("Rectangle", ["util.augment", "GeoObject"], function(e, t, n) {
      function o(e) {
        return e && "undefined" != typeof e.length ? {
          type: "Rectangle",
          coordinates: e
        } : e
      }
      var c = function(e, t, n) {
        c.superclass.constructor.call(this, {
          geometry: o(e),
          properties: t
        }, n)
      };
      t(c, n), e(c)
    });
  }], 0
]);
